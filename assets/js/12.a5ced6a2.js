(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{454:function(v,_,t){"use strict";t.r(_);var e=t(26),l=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"执行上下文-闭包-作用域链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文-闭包-作用域链"}},[v._v("#")]),v._v(" 执行上下文/ 闭包/ 作用域链")]),v._v(" "),t("h2",{attrs:{id:"介绍一下闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下闭包"}},[v._v("#")]),v._v(" 介绍一下闭包"),t("badge",{attrs:{text:"特别重要",type:"error"}})],1),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("概念")]),v._v(" "),t("p",[v._v("闭包是指有权访问另一个函数作用域里面的函数，最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域")])]),v._v(" "),t("p",[v._v("用途：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("通过闭包，可以在外部调用闭包函数 从而从外部调用函数内部的变量，创建私有变量")])]),v._v(" "),t("li",[t("p",[v._v("闭包另一个用途是使已经运行结束的函数上下文的变量对象继续留在内存中，因为闭包保留这个变量对象对象的引用，不会被回收")])])]),v._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[v._v("对于闭包的惰性解析")]),v._v(" "),t("p",[t("code",[v._v("V8")]),v._v("的惰性解析是指解析器在解析过程中，如果遇到函数声明，则跳过函数内部代码，仅生成顶层代码的"),t("code",[v._v("AST")]),v._v("和字节码。利用惰性解析可以加速"),t("code",[v._v("JS")]),v._v("的编译速度和节约内存。")]),v._v(" "),t("p",[t("code",[v._v("V8")]),v._v("解析函数的时候，会使用预解析器快速解析"),t("strong",[v._v("函数内部是否包含了外部函数声明的变量")]),v._v("，如果引用了，就会将该变量复制存放到堆中，即使当前函数执行完也不会释放该变量，从而实现闭包的功能,如果没引用，则根本不会产生这个闭包。")])]),v._v(" "),t("h2",{attrs:{id:"对作用域-作用域链的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对作用域-作用域链的理解"}},[v._v("#")]),v._v(" 对作用域 作用域链的理解"),t("badge",{attrs:{text:"特别重要",type:"error"}})],1),v._v(" "),t("ul",[t("li",[t("p",[v._v("全局作用域")]),v._v(" "),t("ul",[t("li",[v._v("最外层函数及外面定义的变量拥有全局作用域")]),v._v(" "),t("li",[v._v("未定义直接赋值的变量拥有全局作用域")]),v._v(" "),t("li",[v._v("所有"),t("code",[v._v("window")]),v._v("对象属性拥有全局作用域")]),v._v(" "),t("li",[v._v("会污染全局命名空间，引起命名冲突")])])]),v._v(" "),t("li",[t("p",[v._v("函数作用域")]),v._v(" "),t("ul",[t("li",[v._v("函数作用域声明在函数内部，一般只有固定代码片段可以访问到")]),v._v(" "),t("li",[v._v("内层作用域可以访问到外层，反之不行")])])]),v._v(" "),t("li",[t("p",[v._v("块级作用域")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("let")]),v._v(" "),t("code",[v._v("const")]),v._v("可以声明块级作用域 可以在函数也可以在"),t("code",[v._v("{}")]),v._v("里面")]),v._v(" "),t("li",[v._v("循环中适合绑定块级作用域 可以将声明的计数器变量限制在循环内部")])])])]),v._v(" "),t("p",[t("strong",[v._v("作用域链是 在当前作用域查找所需的变量，如果在自己的作用域找不到该变量就去父级作用域查找，依次像上级作用域查找，知道访问到"),t("code",[v._v("window")]),v._v("对象终止，这一层层关系就是作用域链")])]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("作用域链的作用是")]),v._v(" "),t("p",[v._v("保证对执行环境有权访问的所有变量和函数的有序访问 ，通过作用域可以访问到外层环境的函数或变量")])]),v._v(" "),t("div",{staticClass:"custom-block note"},[t("p",{staticClass:"custom-block-title"},[v._v("什么是VO和AO")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("AO")]),v._v("："),t("code",[v._v("Activetion Object")]),v._v("（活动对象）")]),v._v(" "),t("li",[t("code",[v._v("VO")]),v._v("："),t("code",[v._v("Variable Object")]),v._v("（变量对象）")])]),v._v(" "),t("p",[t("code",[v._v("VO")]),v._v("对应的是函数创建阶段，"),t("code",[v._v("JS")]),v._v("解析引擎进行预解析时，所有的变量和函数的声明，统称为"),t("code",[v._v("Variable Object")]),v._v("。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。"),t("code",[v._v("VO")]),v._v("是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：")]),v._v(" "),t("ul",[t("li",[v._v("变量 ("),t("code",[v._v("var")]),v._v(", 变量声明);")]),v._v(" "),t("li",[v._v("函数声明 "),t("code",[v._v("(FunctionDeclaration, 缩写为FD);")])]),v._v(" "),t("li",[v._v("函数的形参")])]),v._v(" "),t("p",[t("code",[v._v("AO")]),v._v("对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是"),t("code",[v._v("Activetion Object")]),v._v("。该对象包含了：")]),v._v(" "),t("ul",[t("li",[v._v("函数的所有局部变量")]),v._v(" "),t("li",[v._v("函数的所有命名参数")]),v._v(" "),t("li",[v._v("函数的参数集合")]),v._v(" "),t("li",[v._v("函数的"),t("code",[v._v("this")]),v._v("指向")])])]),v._v(" "),t("h2",{attrs:{id:"对执行上下文的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对执行上下文的理解"}},[v._v("#")]),v._v(" 对执行上下文的理解"),t("badge",{attrs:{text:"特别重要",type:"error"}})],1),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("全局上下文")])]),v._v(" "),t("ul",[t("li",[v._v("任何不在函数内部的都是全局执行上下文 会首先创建一个全局的"),t("code",[v._v("window")]),v._v("对象，并设置"),t("code",[v._v("this")]),v._v("等于全局对象")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("函数执行上下文")])]),v._v(" "),t("ul",[t("li",[v._v("当一个函数被调用 会为这个函数创建一个新的执行上下文")])])]),v._v(" "),t("li",[t("p",[t("strong",[t("code",[v._v("eval")]),v._v("函数上下文")])]),v._v(" "),t("ul",[t("li",[v._v("执行"),t("code",[v._v("eval")]),v._v("函数代码会有属于他的执行上下文")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("执行上下文栈")])]),v._v(" "),t("ul",[t("li",[v._v("用来管理执行上下文 程序执行时，遇到全局代码，会创建一个全局执行上下文并压入执行栈中，每遇到一个函数调用 会为该函数创建一个新的执行上下文并压入栈顶，当执行完执行上下文从栈顶弹出，继续下一个函数，最后执行完会从栈中弹出全局上下文")])])])]),v._v(" "),t("h2",{attrs:{id:"并行和并发的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并行和并发的区别"}},[v._v("#")]),v._v(" 并行和并发的区别"),t("badge",{attrs:{text:"重要",type:"warning"}})],1),v._v(" "),t("ul",[t("li",[v._v("并发是"),t("strong",[v._v("宏观概念")]),v._v("，我分别有任务 "),t("code",[v._v("A")]),v._v(" 和任务 "),t("code",[v._v("B")]),v._v("，在一段时间内通过任务间的切换完成了这两个任务，称之为并发。")]),v._v(" "),t("li",[v._v("并行是"),t("strong",[v._v("微观概念")]),v._v("，假设 "),t("code",[v._v("CPU")]),v._v(" 中存在两个核心，那么我就可以同时完成任务 "),t("code",[v._v("A")]),v._v("、"),t("code",[v._v("B")]),v._v("。同时完成多个任务的情况就可以称之为并行。")])]),v._v(" "),t("h2",{attrs:{id:"浏览器的垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的垃圾回收机制"}},[v._v("#")]),v._v(" 浏览器的垃圾回收机制"),t("badge",{attrs:{text:"特别重要",type:"error"}})],1),v._v(" "),t("div",{staticClass:"custom-block theorem"},[t("p",{staticClass:"title"},[v._v("概念")]),t("p",[t("code",[v._v("js")]),v._v("代码运行时 需要分配内存来存储变量和值 当变量不参与运行时就需要系统回收被占用的内存空间")])]),t("blockquote",[t("p",[t("strong",[v._v("垃圾回收的方式")]),v._v("：")])]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[t("mark",[v._v("标记清除")])]),v._v(' 当变量进入执行环境的时候，会被标记"进入环境"，内存不能被回收，因为正在被使用，当变量离开环境的时候，会被标记离开环境，系统会释放该内存')]),v._v(" "),t("ul",[t("li",[v._v("垃圾回收器的作用是给所有变量都加上标记，然后去除那些被使用的变量的标记，在此之后被加上标记的都是准备删除的变量")])])]),v._v(" "),t("li",[t("p",[t("strong",[t("mark",[v._v("引用计数")])]),v._v(" 简单的来说但变量的引用次数为"),t("code",[v._v("0")]),v._v("的时候就会被销毁，内存被释放")])]),v._v(" "),t("li",[t("p",[v._v("但是当有循环引用的时候就不会被释放 需要手动设置释放内存"),t("code",[v._v("xxx = null")])])])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("减少垃圾回收")])])]),v._v(" "),t("p",[t("strong",[v._v("当代码很复杂的时候，垃圾回收带来的代价比较大，我们应该尽量减少垃圾回收")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("对数组进行优化：最简单的方法是赋值为"),t("code",[v._v("[]")]),v._v("，但是同时会创建一个新的空对象，所以我们可以把数组的长度设为"),t("code",[v._v("0")])])]),v._v(" "),t("li",[t("p",[v._v("对"),t("code",[v._v("Object")]),v._v("进行优化：对象尽量复用，对不使用的对象，将其设置为"),t("code",[v._v("null")])])]),v._v(" "),t("li",[t("p",[v._v("对函数的优化：在循环的函数表达式中，如果可以复用，就尽量放在函数外面")])])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("哪些会导致内存泄露")])])]),v._v(" "),t("ul",[t("li",[v._v("意外的全局变量：使用未声明的变量会变成全局变量")]),v._v(" "),t("li",[v._v("被遗忘的计数器")]),v._v(" "),t("li",[v._v("闭包")]),v._v(" "),t("li",[v._v("脱离"),t("code",[v._v("DOM")]),v._v("的引用：获取"),t("code",[v._v("DOM")]),v._v("元素的引用，后面这个元素被删除，由于一直保留这个元素的引用，无法被回收")]),v._v(" "),t("li",[v._v("循环引用")]),v._v(" "),t("li",[v._v("控制台日志("),t("code",[v._v("console.log")]),v._v(")")])])])}),[],!1,null,null,null);_.default=l.exports}}]);