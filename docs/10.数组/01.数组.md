---
title: 数组
date: 2021-12-20 21:40:03
permalink: /pages/251490/
---

# 双指针或哈希表

## lc88. 合并两个有序数组<Badge text="简单" vertical="top"/>

::: tip 题目描述：

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。



初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

:::

示例 1：

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112202144854.png)

```plain
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```



示例 2：



```plain
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```



思路：





- 倒叙比较 如果`nums2[len2]` 比 `nums1[len1]`大的话，就放进`nums1[len]`处

- 反之则把`nums1[len1]`放进`nums1[len]`处

- 若`len2`'指针'先走完，则`nums1`为已经排序好的数组
  - 若`len1`'指针'先走完，则说明`nums2[len2]`以前的元素全都比`nums1`小，就把剩余的逐个放进`nums1`中即可



**时间复杂度为O（m + n）**



```javascript
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let len1 = m - 1
    let len2 = n - 1
    let len = nums1.length - 1
    while(len2 >= 0) {
        if(len < 0) {
            num1[len1--] = nums2[len2--]
        }

        nums1[len--] = nums1[len1] >= nums2[len2] ? nums1[len1--] : nums2[len2--]
    }
};
```

另题解：

用`js`自带的`sort`方法



`js` 的`sort`方法时间复杂度为`O(nlogn)`

时间复杂度为 `O(n+ nlogn)`



```javascript
var merge = function(nums1, m, nums2, n) {
    for(let i = 0; i < n; i++){ 
        nums1[i+m] = nums2[i] 
    } 
    nums1.sort((a,b) => a - b)
};
```

## lc1. 两数之和<Badge text="简单" vertical="top"/>



::: tip 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值**`target` 的那两个整数，并返回它们的数组下标

:::

示例：

```plain
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]
```

> 法1 暴力法

```javascript
// 两层for循环暴力求解
// 时间复杂度O（n^2）
var twoSum = function(nums, target) {
    if(nums.length < 2) return false
    for(let i = 0; i < nums.length; i++) {
        const temp = target - nums[i]
        for(let j = i + 1; j < nums.length; j++) {
            if(temp === nums[j]) return [i, j]
            else continue
        }
    }
};
```

> 法2 利用数组查找

思路：

使用一层循环，把要找的第二个数命名为`n`，新增一个数组`temp`，并遍历`nums`数组，如果在`temp`数组下标为n中找不到，就把第一个数的位置存进数组里

```javascript
// 时间复杂度On

var twoSum = function(nums, target) {
	const temp = []
	for(let i = 0; i < nums.length; i++) {
        const diff = target - nums[i]
		if(temp[diff] != undefined) {
			return [i, temp[diff]]
		} else {
			temp[nums[i]] = i
		}
	}
}
```

> 法3 同法2 利用`js`的`map`数据结构

```javascript
const twoSum = function(nums, target) {    
    let map = new Map()    
    for(let i = 0; i< nums.length; i++) {
        let k = target-nums[i]        
        if(map.has(k)) return [map.get(k), i]        
        map.set(nums[i], i)         
    }    
    return []; 
}
```

## lc15. 三数之和<Badge text="中等" vertical="top"/>





:::tip 题目描述

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c` ，使得 `a + b + c = 0` ？请你找出所有和为 `0` 且不重复的三元组。



注意：答案中不可以包含重复的三元组。

:::

示例 1：



```plain
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```



示例 2：



```plain
输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]
```



> 法一 模仿两数之和



可以模仿两数之和，先循环一遍将`nums[i]`当成两数之和的`target`，然后重复两数之和的操作



```javascript
const threeSum = function(nums) {
    let map = new Map()
    let result = []
    for(let i = 0; i < nums.length - 2; i++) {
		// 第一个数
		let first = nums[i]
		for(let j = i+1; j < nums.length; j++) {
			// 第三个数
			let second = 0 - nums[j] - first
			if(map.has(second)) {
				result.push([first, second, nums[j]]) 
			}
			map.set(nums[j], j)
		}
		map.clear()
	}
	return result
}

// 测试
var nums = [-1, 0, 1, 2, -1, -4] 
threeSum(nums)
// [[-1,0,1],[-1,2,-1],[0,1,-1]] // 存在重复元组
```



因为通不过测试用例，就更谈不上击败执行用时和内存消耗了

在数组中去重元组会消耗更多的内存和时间，这种做法不推荐



**pass**



> 法二 排序加双指针



思路：



![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112202259528.png)



- 先对数组元素进行排序，然后进行循环，把`nums[i]`和`nums[i - 1]`的元素去重，然后将`first`置为`i`，`second`置为`i + 1`，`third`置为数组的最后一位
- 然后三位数相加

- 如果`sum === 0` 那就推进`result`里面 

- - 判断重复情况 

- - - 如果数组中下标为`second`的值和`second + 1`的值相等 那么`second`往后走一位
    - 同理 如果数组中下标为`third`的值和`third - 1`的值相等 那么`third`往回走一位



- 如果 `sum > 0` 那就`third`往回走一位
- 如果 `sum < 0` 那就`second`往后走一位



```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    if(!nums || nums.length < 3) return []

    let result = [], first, second, third
    nums.sort((a, b) => a - b)
    for(let i = 0; i < nums.length - 2; i++) {
        // 因为数组为升序 假如这个first都小于0 那肯定整体加起来肯定大于0
        if(nums[i] > 0) break

        // 去重
        while(i > 0 && nums[i] === nums[i - 1]) i++

        // 第一个数
        first = i
        // 第二个数
        second = i + 1
        // 第三个数
        third = nums.length - 1

        while(second < third) {
            const sum = nums[first] + nums[second] + nums[third]
            if(sum === 0) {
                result.push([nums[first], nums[second], nums[third]])
                // 去重
                while(second < third && nums[second] === nums[second + 1]) second++
                while(second < third && nums[third] === nums[third - 1]) third--

                second++
                third--
            } else if(sum > 0) third--
            else if(sum < 0) second++
        }
    }
    return result
};
```

**效果还是不错滴**

## lc18. 四数之和<Badge text="中等" vertical="top"/>





:::tip 题目描述



给你一个由 `n` 个整数组成的数组`nums`，和一个目标值`target` 。请你找出并返回满足下述全部条件且不重复的四元组 `[nums[a], nums[b], nums[c], nums[d]] ：`



`0 <= a, b, c, d < n`
`a`、`b`、`c` 和 `d` 互不相同
`nums[a] + nums[b] + nums[c] + nums[d] == target`
你可以按 任意顺序 返回答案

:::

示例 1：



```plain
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```



示例 2：



```plain
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```



思路：



和三数之和类似，多套了一层



```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums.sort((a,b) => a - b)
    const result = []

    for (let i = 0;i < nums.length -3;i++) {
        // 去重
        while (i > 0 && nums[i] === nums[i-1]) i++

        for(j = i + 1;j < nums.length - 2; j++) {
            while (j > i + 1 && nums[j] === nums[j - 1])  j++

            let third = j + 1, fourth = nums.length - 1
            while(third < fourth) {
                const sum = nums[i] + nums[j] + nums[third] + nums[fourth]
                if (sum == target) {
                    result.push([nums[i], nums[j], nums[third], nums[fourth]])
                }
                if (sum <= target) {
                    // 如果头部指针等于后一个元素，则third一直往后移
                    while (nums[third] === nums[++third]);
                } else {
                    // 如果尾部指针等于前一个元素，则fourth一直往前移
                    while (nums[fourth] === nums[--fourth]);
                }
            }
        }
    }
    return result
};
```

## lc05. 最长回文子串

:::tip 题目描述

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

 :::

示例 1：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```
输入：s = "cbbd"
输出："bb"
```


示例 3：

```
输入：s = "a"
输出："a"
```


示例 4：

```
输入：s = "ac"
输出："a"
```

> 思路

就是以字符串的每一个字符为中心点，然后分别向左和向右进行延伸

```js
var longestPalindrome = function(s) {
  if(!s || !s.length) return ''
  if(s.length === 1) return s
  let res = ''
  const fn = (left, right) => {
    while(left >= 0 && right < s.length && s[left] === s[right]) {
      left--
      right++
    }
    res = right - left - 1 > res.length ? s.slice(left + 1, right) : res
  }
  for(let i = 0; i < s.length - 1; i++) {
    fn(i, i)
    fn(i, i + 1)
  }
  return res
};
```

时间复杂度:`O(n^2)`

空间复杂度`O(1)`

## lc349. 两个数组的交集

:::tip 题目描述

给定两个数组，编写一个函数来计算它们的交集。

 :::

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
```

> 思路

这道题很简单就用`hash`

```js
var intersection = function(nums1, nums2) {
  const map = new Map()
  const res = []
  for(let i = 0; i < nums1.length; i++) {
    if(!map.has(nums1[i])) map.set(nums1[i], 1)
  }
  for(let i = 0; i < nums2.length; i++) {
    if(map.has(nums2[i])) {
      res.push(nums2[i])
      map.delete(nums2[i])
    }
  }
  return res
};
```

时间复杂度`O(m + n)`

空间复杂度:`O(m + n)`

## lc350. 两个数组的交集 II<Badge text="简单" vertical="top"/>

:::tip 题目描述

给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

 :::

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

> 思路：排序后双指针

```js
var intersect = function(nums1, nums2) {
  nums1.sort((a, b) => a - b)
  nums2.sort((a, b) => a - b)
  let l1 = 0, l2 = 0
  const res = []
  while(l1 < nums1.length && l2 < nums2.length) {
    if(nums1[l1] === nums2[l2]) {
      res.push(nums1[l1])
      l1++
      l2++
    }
    if(nums1[l1] > nums2[l2]) l2++
    if(nums1[l1] < nums2[l2]) l1++
  }
  return res
};
```



## lc611. 有效的三角形个数<Badge text="中等" vertical="top"/>

::: tip 题目描述



给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

:::

示例 1:



```plain
输入: [2,2,3,4]
输出: 3

解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```



思路：



和上面的三数之和类似



首先明白三角形是两边之和大于第三边 两边之差小于第三边



如果数组是升序的 那么只用考虑两边之和



利用双指针

- 对数组进行升序排序 



-  设置变量`k`从尾开始遍历
-  设置变量`j`为`k - 1 `
-  设置变量`i`为`0` 
-  判断`nums[i] + nums[j]`是否大于`nums[k]`的值
  - 如果`nums[i] + nums[j] > nums[k]` 那么在`i∈[i, j]`中的值都满足 **(不信自己试试看！)**
    - 然后`j`往回走再试
  - 如果`nums[i] + nums[j] <= nums[k]` 那么`i`往后走一个
-  返回`count` 





```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var triangleNumber = function(nums) {
    if(!nums || nums.length < 3) return 0

    let count = 0
    nums.sort((a, b) => a - b)
    for(let k = nums.length - 1; k > 1; k--) {
        let i = 0
        let j = k - 1
        while(i < j) {
            if(nums[i] + nums[j] > nums[k]) {
                count += j - i
                j--
            } else {
                i++
            }
        }
    }
    return count
};
```

## lc42. 接雨水<Badge text="困难but中等" vertical="top" type="warning"/>



::: tip 题目描述

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

:::

示例 1：

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112202325163.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]

输出：6

解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 
表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

示例 2：
输入：height = [4,2,0,3,2,5]

输出：9
```



思路还是双指针

当左边最大挡板＜右边最大挡板，左边向前挺近，最终值加上当前左最大挡板-当前左指针所指值（相当于左边只要不超过右边，右边最大挡板稳定兜底，左边无脑挺近累加）

```javascript
/**
 * max water
 * @param arr int整型一维数组 the array
 * @return long长整型
 */
function maxWater( arr ) {
    // write code here
    let left = 0, right = arr.length - 1
    let lmax = 0, rmax = 0, sum = 0
    while(left < right) {
        lmax = Math.max(lmax, arr[left])
        rmax = Math.max(rmax, arr[right])
        if(lmax < rmax) {
            sum += (lmax - arr[left])
            left++
        } else {
            sum += (rmax - arr[right])
            right--
        }
    }
    return sum
}
```

lc11:盛最多水的容器

:::tip 题目描述

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

:::

 

示例 1：

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201151009079.png)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```


示例 2：

```
输入：height = [1,1]
输出：1
```


示例 3：

```
输入：height = [4,3,2,1,4]
输出：16
```


示例 4：

```
输入：height = [1,2,1]
输出：2
```

> 思路

这道题远比上一道题简单，用一个简单的双指针就好了

```js
var maxArea = function(height) {
  let left = 0, right = height.length - 1
  let sum = 0
  while(left < right) {
    let res = Math.min(height[left], height[right]) * (right - left)
    sum = Math.max(res, sum)
    height[left] > height[right] ? right-- : left++
  }
  return sum
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

# 螃蟹🦀️走法

## 剑指04. 二维数组中的查找

:::tip 题目描述

在一个 `n * m` 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

::: 

示例:

```
现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。

给定 target = 20，返回 false。
```

> 思路一：直接暴力

暴力的话就是二维数组遍历，没什么好说的

> 思路二：螃蟹走法

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201131049466.png)

这张图一目了然，或者也可以从右上角开始遍历

```js
var findNumberIn2DArray = function(matrix, target) {
    if(!matrix.length || !matrix[0].length) return false
    let i = matrix.length - 1, j = 0
    while(i >= 0 && j < matrix[0].length) {
        if(matrix[i][j] === target) return true
        else if(matrix[i][j] > target) {
            i--
        } else {
            j++
        }
    }
    return false
};
```

# `DFS` + 回溯

## 剑指12. 矩阵中的路径

:::tip 题目描述

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word`。如果 word 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

例如，在下面的 `3×4` 的矩阵中包含单词 `"ABCCED"`（单词中的字母已标出）。

:::

 ![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201131139385.png)

示例 1：

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```


示例 2：

```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

> 思路： `DFS`

递归参数： 当前元素在矩阵 `board` 中的行列索引 `i` 和 `j` ，当前目标字符在 `word` 中的索引 `k` 。
终止条件：
返回 `false`  ： 

1. 行或列索引越界
2. 当前矩阵元素与目标字符不同
3. 当前矩阵元素已访问过 （ (3) 可合并至 (2) 

返回 `true` ： `k = len(word) - 1` ，即字符串 `word` 已全部匹配。
递推工作：
标记当前矩阵元素： 将 `board[i][j]` 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。
搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 `DFS` ），并记录结果至 `res` 。
还原当前矩阵元素： 将 `board[i][j]` 元素还原至初始值，即 `word[k]` 。
返回值： 返回布尔量 `res` ，代表是否搜索到目标字符串。

```js
var exist = function(board, word) {
  for(let i = 0; i < board.length; i++) {
    for(let j = 0; j < board[0].length; j++) {
      if(dfs(board, word, i, j, 0)) return true
    }
  }
  return false
};

function dfs(board, word, i, j, k) {
  if(i < 0 || j < 0 || i > board.length - 1 || j > board[0].length - 1 || board[i][j] !== word[k]) return false

  if(k === word.length - 1) return true
  
  board[i][j] = ''
  let res = dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i, j - 1, k + 1) || dfs(board, word, i, j + 1, k + 1)
  board[i][j] = word[k]
  return res
}
```

> `M,N` 分别为矩阵行列大小， `K` 为字符串 `word` 长度。

时间复杂度` O(3^K * MN)` 最差情况下，需要遍历矩阵中长度为 `K` 字符串的所有方案，时间复杂度为 `O(3^K)`
矩阵中共有 `MN` 个起点，时间复杂度为 `O(MN)`
方案数计算： 设字符串长度为 `K` ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 `3` 种选择，因此方案数的复杂度为 `O(3^K)`
空间复杂度 `O(K)` ： 搜索过程中的递归深度不超过 `K` ，因此系统因函数调用累计使用的栈空间占用 `O(K)`  最坏情况下 `K = MN`，递归深度为 `MN` ，此时系统栈使用 `	O(MN)`的额外空间

## lc46. 全排列

:::tip 题目描述

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

 :::

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

> 思路

由题可得如果用暴力法面试会被直接挂掉，或者算法超时，可以采用dfs + 回溯(撤销)进行解答

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201171748355.png)

看了这个图就对这道全排列比较直观了，同时也有一定的解题模版

```
const result = []
function backtrack(路径, 选择列表) {
    if 满足结束条件:
        result.push(路径)
        return
    
    for 选择 of 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
}
```

> 下面就来干起

```js
var permute = function(nums) {
    const result = []
    backTrack(nums, result, [])
    return result
};

function backTrack (nums, result, track) {
    if (track.length === nums.length) {
        // 更改引用类型的指针。目的；防止回溯行为影响到当前数组状态。
        result.push([...track])
        return
    }
    for (let i = 0; i < nums.length; i++) {
        if (track.includes(nums[i])) {
            continue
        }
        track.push(nums[i])
        backTrack(nums, result, track)
        track.pop()
    }
}
```

## lc77. 组合

:::tip 题目描述

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 :::

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```
输入：n = 1, k = 1
输出：[[1]]
```

> 思路

还是套模版,只不过原来的按模版的会超时，我们可以剪一下枝

```js
var combine = function(n, k) {
  const s = new Set()
  const res = []
  let start = 1
  const dfs = (start, nums) => {
    if(nums.length === k) {
      res.push([...nums])
      return
    }
    for(let i = start; i <= n; i++) {
      if(nums.includes(i)) {
        continue
      } else {
        nums.push(i)
        dfs(i + 1, nums)
        nums.pop()
      }
    }
  }
  dfs(start, [])
  return res
};
```

## lc78. 子集

:::tip 题目描述

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 :::

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

> 思路

这一道题就可以套模板了，只不过这里的`dfs`的`push`要在`if`外面，因为输出的`res`不一定与`nums`的`length`相等

```js
var subsets = function(nums) {
  const result = [];
  helper(nums, 0, [], result);
  return result;
};

function helper(nums, start, track, result) {

  result.push([...track]);

  if (track.length === nums.length) {
    return
  }

  for (let i = start; i < nums.length; i++) {
    track.push(nums[i]);
    helper(nums, i + 1, track, result);
    track.pop();
  }
}
```



## lc17. 电话号码的字母组合

:::tip 题目描述

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 `1` 不对应任何字母。

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201161117364.png)

 

:::

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

> 思路：`dfs` + 回溯

这道题有暴力法可以解，但是要嵌套三次循环，采用`dfs`可以降时间复杂度

```js
var letterCombinations = function (digits) {
  // 为空特殊处理
  if (digits.length === 0) return [];
  let numMap = new Map([
    ['0', ''],
    ['1', ''],
    ['2', 'abc'],
    ['3', 'def'],
    ['4', 'ghi'],
    ['5', 'jkl'],
    ['6', 'mno'],
    ['7', 'pqrs'],
    ['8', 'tuv'],
    ['9', 'wxyz']
  ])
  let res = [];
  dfs("", digits);
  return res;

  function dfs(str, digit) {
    // 如果字符串为空了，将拼接好的字符加入数组
    if (digit.length === 0) res.push(str);
    else {
      // 拿到字符串第一个字符，拿到其对应的数字
      let numstr = numMap.get(digit[0]);
      // 对可能性进行组合
      for (let i = 0; i < numstr.length; i++) {
        str += numstr[i];
        // 递归组好的 str和下一段字符串
        dfs(str, digit.slice(1))
        // 回溯
        str = str.slice(0, -1);
        // dfs(str+numstr[i], digit.slice(1))
      }
    }
  }
};
```



# 二分

## lc153. 寻找旋转排序数组中的最小值

:::tip 题目描述

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

::: 

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

**示例 3：**

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

> 思路

常规做法一般是一次遍历判断前一个数是否大于后一个数

采用二分可以降低时间复杂度

```js
var findMin = function(nums) {
  if(!nums.length) return null
  if(nums.length === 1) return nums[0]
  let left = 0, right = nums.length - 1, mid
  if(nums[right] > nums[left]) return nums[left]
  while(left <= right) {
    mid = Math.floor(left + (right - left) / 2)
    if(nums[mid] >  nums[mid + 1]) return nums[mid + 1]
    if(nums[mid] < nums[mid - 1]) return nums[mid]
    if(nums[mid] < nums[left]) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return null
};
```

时间复杂度:`O(logn)`

空间复杂度:`O(1)`

## lc33. 搜索旋转排序数组

:::tip 题目描述

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

 :::

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

> 思路还是二分法

```js
var search = function(nums, target) {
  if(!nums.length) return -1
  let left = 0, right = nums.length - 1, mid
  while(left <= right) {
    mid = Math.floor(left + (right - left) / 2)
    if(nums[mid] === target) {
      return mid
    }
    if(nums[mid] >= nums[left]) {
      if(target >= nums[left] && target < nums[mid]) {
        right = mid - 1
      } else {
        left = mid + 1
      }
    } else {
      if(target > nums[mid] && target <= nums[right]) {
        left = mid + 1
      } else {
        right = mid - 1
      }
    }
  }
  return -1
};
```

时间复杂度:`O(logn)`

空间复杂度:`O(1)`

## lc81. 搜索旋转排序数组 II

:::tip 题目描述

已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。

 :::

**示例 1：**

```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
```

**示例 2：**

```
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```

> 思路

和上一题不同的是他增加了重复的值

只需要额外判断一个`mid`的值是否和`left`的值相同，相同的话就`left`往后移一位即可

```js
var search = function(nums, target) {
  if(!nums.length) return false
  let left = 0, right = nums.length - 1, mid
  while(left <= right) {
    mid = Math.floor(left + (right - left) / 2)
    if(nums[mid] === target) {
      return true
    }
    if(nums[mid] === nums[left]) {
      left++
      continue
    }
    if(nums[mid] >= nums[left]) {
      if(target >= nums[left] && target < nums[mid]) {
        right = mid - 1
      } else {
        left = mid + 1
      }
    } else {
      if(target > nums[mid] && target <= nums[right]) {
        left = mid + 1
      } else {
        right = mid - 1
      }
    }
  }
  return false
};
```

时间复杂度:`O(logn)`

空间复杂度:`O(1)`

## lc34. 在排序数组中查找元素的第一个和最后一个位置

:::tip 题目描述

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

 :::

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

> 思路

看到`logn`时间复杂度肯定会想起二分

```js
var searchRange = function(nums, target) {
  let left = 0, right = nums.length - 1, mid
  while(left <= right) {
    mid = Math.floor(left + (right - left) / 2)
    if(nums[mid] === target) {
      left = mid - 1
      right = mid + 1
      while(true) {
        if(nums[left] === target) left--
        else if(nums[right] === target) right++
        else {
          return [left + 1, right - 1]
        }
      }
    }
    if(nums[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return [-1, -1]
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

# 有关区间

## lc56. 合并区间<Badge text="字节中等" vertical="top"/>

:::tip 题目描述

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 :::

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

> 思路

没什么技巧就是暴力

```js
var merge = function(intervals) {
    if (!intervals || !intervals.length) return [];
    intervals.sort((a, b) => a[0] - b[0]);
    let ans = [intervals[0]];
    for (let i = 1; i < intervals.length; i++) {
        if (ans[ans.length - 1][1] >= intervals[i][0]) {
            ans[ans.length - 1][1] = Math.max(ans[ans.length - 1][1], intervals[i][1])
        } else {
            ans.push(intervals[i])
        }
    }
    return ans;
};
```

时间复杂度`O(n)`

空间复杂度`O(n)`

## lc57. 插入区间

:::tip 题目描述

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

 :::

**示例 1：**

```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
```

**示例 2：**

```
输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
```

**示例 3：**

```
输入：intervals = [], newInterval = [5,7]
输出：[[5,7]]
```

**示例 4：**

```
输入：intervals = [[1,5]], newInterval = [2,3]
输出：[[1,5]]
```

**示例 5：**

```
输入：intervals = [[1,5]], newInterval = [2,7]
输出：[[1,7]]
```

> 思路

还是常规暴力法

```js
var insert = function(intervals, newInterval) {
  let left = newInterval[0], right = newInterval[1]
  let i = 0
  while(i < intervals.length) {
    if(newInterval[0] > intervals[i][1]) {
      i++
      continue
    } else if(newInterval[1] < intervals[i][0]) {
      break
    } else {
      left = Math.min(left, intervals[i][0])
      right = Math.max(right, intervals[i][1])
      intervals.splice(i, 1)
    }
  }

  intervals.splice(i, 0, [left, right])
  return intervals
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

# 数学问题

## lc136. 只出现一次的数字

:::tip 题目描述

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

:::

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

> 思路

这道题要求不用额外空间实现，那就是使用异或

- 任何数和自己做异或运算，结果为 `0`，即` a⊕a=0`。
- 任何数和` 0` 做异或运算，结果还是自己，即 `a⊕0=a`。
- 异或运算中，满足交换律和结合律，也就是`a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b`

```js
var singleNumber = function(nums) {
  let init = nums[0];
  for(let i = 1; i < nums.length; i++){
      init ^=  nums[i];
  }
  return init;
};
```

## lc191. 位1的个数

:::tip 题目描述

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

:::

**示例 1：**

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2：**

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：**

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

 

**提示：**

- 输入必须是长度为 `32` 的 **二进制串** 。

**进阶**：

- 如果多次调用这个函数，你将如何优化你的算法？

> 思路

首先介绍一下`&`运算符

直接上🌰

`console.log(12 & 5);  //返回值4`

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201181616569.png)

`|`运算符

`console.log(12 | 5);  //返回值13`

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201181616437.png)

很明显 `&` 是与 `｜`是或

```js
var hammingWeight = function(n) {
    let count = 0
    while(n) {
      n &= n - 1
      count++
    }
    return count
};
```

## lc283. 移动零

:::tip 题目描述

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

:::

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

> 思路

```js
var moveZeroes = function(nums) {
  let i = 0, j = 0
  while(i < nums.length) {
    if(nums[i] !== 0) {
      [nums[i], nums[j]] = [nums[j], nums[i]]
      j++
    }

    i++
  }
};
```

## lc118. 杨辉三角

:::tip 题目描述

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201181726895.gif)

 

:::

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```

> 思路

常规思路

```js
var generate = function(numRows) {
  if(!numRows) return []
  const arr = new Array()
  for(let i = 0; i < numRows; i++){
    arr[i] = new Array()
    arr[i][0] = 1; arr[i][i] = 1;
      for(let j = 1; j < i; j++){
      arr[i][j] = arr[i-1][j-1] + arr[i-1][j] 
    }
  }
  return arr
};
```

## lc66. 加一

:::tip 题目描述

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 `0` 之外，这个整数不会以零开头。

:::

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2：**

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3：**

```
输入：digits = [0]
输出：[1]
```

> 思路

很简单，跟两数相加一样

```js
var plusOne = function(digits) {
  let car = 1
  let sum = 0
  for(let i = digits.length - 1; i >= 0; i--) {
    if(car) {
      sum = digits[i] + car
      digits[i] = sum % 10
      car = Math.floor(sum / 10)
    } else {
      break
    }
  }
  if(car) digits.unshift(car)
  return digits
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

## lc268. 丢失的数字

:::tip 题目描述

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

:::

**示例 1：**

```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 2：**

```
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 3：**

```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 4：**

```
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```

> 思路

直接上代码，等差数列求和然后依次减去数组每一项的值，剩下的就是丢失的那个数字

```js
var missingNumber = function(nums) {
  let len = nums.length
  let sum = (len + 1) * len / 2
  for(let i = 0; i < len; i++) {
    sum -= nums[i]
  }
  return sum
};
```

## lc326. 3 的幂

:::tip 题目描述

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

整数 `n` 是 3 的幂次方需满足：存在整数 `x` 使得 `n == 3x`

 :::

**示例 1：**

```
输入：n = 27
输出：true
```

**示例 2：**

```
输入：n = 0
输出：false
```

**示例 3：**

```
输入：n = 9
输出：true
```

**示例 4：**

```
输入：n = 45
输出：false
```

```js
var isPowerOfThree = function(n) {
  while(n >= 3) {
    n = n / 3
  }

  return n === 1
};
```

#### lc7. 整数反转

:::tip 题目描述

给你一个 `32` 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 `32` 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 `0`。

**假设环境不允许存储 `64` 位整数（有符号或无符号）。**

 :::

**示例 1：**

```
输入：x = 123
输出：321
```

**示例 2：**

```
输入：x = -123
输出：-321
```

**示例 3：**

```
输入：x = 120
输出：21
```

**示例 4：**

```
输入：x = 0
输出：0
```

> 法一：字符串拼接

```js
var reverse = function(x) {
  if(x === 0) return 0
  else if(x > 0) {
    let str = String(x)
    let res = Number(str.split('').reverse().join(''))
    return res > Math.pow(2, 31) - 1 ? 0 : res
  } else {
    let str = String(x).slice(1)
    let res = Number(`-${str.split('').reverse().join('')}`)
    return res < Math.pow(-2, 31) ? 0 : res
  }
};
```

> 法二

- 声明一个变量`ret`存放结果

- 用`x % 10`获取最后一个数
- `ret`每次加上他自身乘以`10` 和 最后一个数，也就相当于取原来数字的最后一位拼接到新数字的最后面

```js
var reverse = function(x) {
    let ret = 0;
    while(x){
        ret = ret * 10 + x % 10;
        if(ret > Math.pow(2, 31) - 1 || ret < Math.pow(-2, 31)) return 0;
        x = (x / 10) | 0
    }
    return ret
};
```

# 其他

## lc26. 删除有序数组的重复项

:::tip 题目描述

给你一个有序数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **原地 修改输入数组** 并在使用 `O(1)` 额外空间的条件下完成。

 

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「**引用**」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

:::

示例 1：

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

示例 2：

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

> **思路：**

设置一个变量`len`，作用是标注每次处理`nums`数组后共有几个不重复的数字

因为是有序数组，所以`nums`数组遇到相同的跳过，找到后一个不相同的，然后把不相同的赋值给`len` 然后`len++`

```js
var removeDuplicates = function(nums) {
  let len = 1
  for(let i = 1; i < nums.length; i++) {
    if(nums[i] === nums[i - 1]) {
      continue
    }
    nums[len++] = nums[i]
  }
  return len
};
```

