---
title: 数组
date: 2021-12-20 21:40:03
permalink: /pages/251490/
---

# 双指针

## lc88:合并两个有序数组



::: tip 题目描述：

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。



初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

:::

示例 1：

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112202144854.png)

```plain
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```



示例 2：



```plain
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```



思路：





- 倒叙比较 如果`nums2[len2]` 比 `nums1[len1]`大的话，就放进`nums1[len]`处

- 反之则把`nums1[len1]`放进`nums1[len]`处

- 若`len2`'指针'先走完，则`nums1`为已经排序好的数组
  - 若`len1`'指针'先走完，则说明`nums2[len2]`以前的元素全都比`nums1`小，就把剩余的逐个放进`nums1`中即可



**时间复杂度为O（m + n）**



```javascript
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let len1 = m - 1
    let len2 = n - 1
    let len = nums1.length - 1
    while(len2 >= 0) {
        if(len < 0) {
            num1[len1--] = nums2[len2--]
        }

        nums1[len--] = nums1[len1] >= nums2[len2] ? nums1[len1--] : nums2[len2--]
    }
};
```

另题解：

用`js`自带的`sort`方法



`js` 的`sort`方法时间复杂度为`O(nlogn)`

时间复杂度为 `O(n+ nlogn)`



```javascript
var merge = function(nums1, m, nums2, n) {
    for(let i = 0; i < n; i++){ 
        nums1[i+m] = nums2[i] 
    } 
    nums1.sort((a,b) => a - b)
};
```

## lc1:两数之和

::: tip 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值**`target` 的那两个整数，并返回它们的数组下标

:::

示例：

```plain
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]
```

> 法1 暴力法

```javascript
// 两层for循环暴力求解
// 时间复杂度O（n^2）
var twoSum = function(nums, target) {
    if(nums.length < 2) return false
    for(let i = 0; i < nums.length; i++) {
        const temp = target - nums[i]
        for(let j = i + 1; j < nums.length; j++) {
            if(temp === nums[j]) return [i, j]
            else continue
        }
    }
};
```

> 法2 利用数组查找

思路：

使用一层循环，把要找的第二个数命名为`n`，新增一个数组`temp`，并遍历`nums`数组，如果在`temp`数组下标为n中找不到，就把第一个数的位置存进数组里

```javascript
// 时间复杂度On

var twoSum = function(nums, target) {
	const temp = []
	for(let i = 0; i < nums.length; i++) {
        const diff = target - nums[i]
		if(temp[diff] != undefined) {
			return [i, temp[diff]]
		} else {
			temp[nums[i]] = i
		}
	}
}
```

> 法3 同法2 利用`js`的`map`数据结构

```javascript
const twoSum = function(nums, target) {    
    let map = new Map()    
    for(let i = 0; i< nums.length; i++) {
        let k = target-nums[i]        
        if(map.has(k)) return [map.get(k), i]        
        map.set(nums[i], i)         
    }    
    return []; 
}
```

## lc15:三数之和



:::tip 题目描述

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c` ，使得 `a + b + c = 0` ？请你找出所有和为 `0` 且不重复的三元组。



注意：答案中不可以包含重复的三元组。

:::

示例 1：



```plain
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```



示例 2：



```plain
输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]
```



> 法一 模仿两数之和



可以模仿两数之和，先循环一遍将`nums[i]`当成两数之和的`target`，然后重复两数之和的操作



```javascript
const threeSum = function(nums) {
    let map = new Map()
    let result = []
    for(let i = 0; i < nums.length - 2; i++) {
		// 第一个数
		let first = nums[i]
		for(let j = i+1; j < nums.length; j++) {
			// 第三个数
			let second = 0 - nums[j] - first
			if(map.has(second)) {
				result.push([first, second, nums[j]]) 
			}
			map.set(nums[j], j)
		}
		map.clear()
	}
	return result
}

// 测试
var nums = [-1, 0, 1, 2, -1, -4] 
threeSum(nums)
// [[-1,0,1],[-1,2,-1],[0,1,-1]] // 存在重复元组
```



因为通不过测试用例，就更谈不上击败执行用时和内存消耗了

在数组中去重元组会消耗更多的内存和时间，这种做法不推荐



**pass**



> 法二 排序加双指针



思路：



![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112202259528.png)



- 先对数组元素进行排序，然后进行循环，把`nums[i]`和`nums[i - 1]`的元素去重，然后将`first`置为`i`，`second`置为`i + 1`，`third`置为数组的最后一位
- 然后三位数相加

- 如果`sum === 0` 那就推进`result`里面 

- - 判断重复情况 

- - - 如果数组中下标为`second`的值和`second + 1`的值相等 那么`second`往后走一位
    - 同理 如果数组中下标为`third`的值和`third - 1`的值相等 那么`third`往回走一位



- 如果 `sum > 0` 那就`third`往回走一位
- 如果 `sum < 0` 那就`second`往后走一位



```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    if(!nums || nums.length < 3) return []

    let result = [], first, second, third
    nums.sort((a, b) => a - b)
    for(let i = 0; i < nums.length - 2; i++) {
        // 因为数组为升序 假如这个first都小于0 那肯定整体加起来肯定大于0
        if(nums[i] > 0) break

        // 去重
        while(i > 0 && nums[i] === nums[i - 1]) i++

        // 第一个数
        first = i
        // 第二个数
        second = i + 1
        // 第三个数
        third = nums.length - 1

        while(second < third) {
            const sum = nums[first] + nums[second] + nums[third]
            if(sum === 0) {
                result.push([nums[first], nums[second], nums[third]])
                // 去重
                while(second < third && nums[second] === nums[second + 1]) second++
                while(second < third && nums[third] === nums[third - 1]) third--

                second++
                third--
            } else if(sum > 0) third--
            else if(sum < 0) second++
        }
    }
    return result
};
```

**效果还是不错滴**

## lc18:四数之和



:::tip 题目描述



给你一个由 `n` 个整数组成的数组`nums`，和一个目标值`target` 。请你找出并返回满足下述全部条件且不重复的四元组 `[nums[a], nums[b], nums[c], nums[d]] ：`



`0 <= a, b, c, d < n`
`a`、`b`、`c` 和 `d` 互不相同
`nums[a] + nums[b] + nums[c] + nums[d] == target`
你可以按 任意顺序 返回答案

:::

示例 1：



```plain
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```



示例 2：



```plain
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```



思路：



和三数之和类似，多套了一层



```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums.sort((a,b) => a - b)
    const result = []

    for (let i = 0;i < nums.length -3;i++) {
        // 去重
        while (i > 0 && nums[i] === nums[i-1]) i++

        for(j = i + 1;j < nums.length - 2; j++) {
            while (j > i + 1 && nums[j] === nums[j - 1])  j++

            let third = j + 1, fourth = nums.length - 1
            while(third < fourth) {
                const sum = nums[i] + nums[j] + nums[third] + nums[fourth]
                if (sum == target) {
                    result.push([nums[i], nums[j], nums[third], nums[fourth]])
                }
                if (sum <= target) {
                    // 如果头部指针等于后一个元素，则third一直往后移
                    while (nums[third] === nums[++third]);
                } else {
                    // 如果尾部指针等于前一个元素，则fourth一直往前移
                    while (nums[fourth] === nums[--fourth]);
                }
            }
        }
    }
    return result
};
```

## lc611:有效的三角形个数



::: tip 题目描述



给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

:::

示例 1:



```plain
输入: [2,2,3,4]
输出: 3

解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```



思路：



和上面的三数之和类似



首先明白三角形是两边之和大于第三边 两边之差小于第三边



如果数组是升序的 那么只用考虑两边之和



利用双指针

- 对数组进行升序排序 



-  设置变量`k`从尾开始遍历
-  设置变量`j`为`k - 1 `
-  设置变量`i`为`0` 
-  判断`nums[i] + nums[j]`是否大于`nums[k]`的值
  - 如果`nums[i] + nums[j] > nums[k]` 那么在`i∈[i, j]`中的值都满足 **(不信自己试试看！)**
    - 然后`j`往回走再试
  - 如果`nums[i] + nums[j] <= nums[k]` 那么`i`往后走一个
-  返回`count` 





```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var triangleNumber = function(nums) {
    if(!nums || nums.length < 3) return 0

    let count = 0
    nums.sort((a, b) => a - b)
    for(let k = nums.length - 1; k > 1; k--) {
        let i = 0
        let j = k - 1
        while(i < j) {
            if(nums[i] + nums[j] > nums[k]) {
                count += j - i
                j--
            } else {
                i++
            }
        }
    }
    return count
};
```

## lc42: 接雨水

::: tip 题目描述

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

:::

示例 1：

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112202325163.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]

输出：6

解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 
表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

示例 2：
输入：height = [4,2,0,3,2,5]

输出：9
```



思路还是双指针

当左边最大挡板＜右边最大挡板，左边向前挺近，最终值加上当前左最大挡板-当前左指针所指值（相当于左边只要不超过右边，右边最大挡板稳定兜底，左边无脑挺近累加）

```javascript
/**
 * max water
 * @param arr int整型一维数组 the array
 * @return long长整型
 */
function maxWater( arr ) {
    // write code here
    let left = 0, right = arr.length - 1
    let lmax = 0, rmax = 0, sum = 0
    while(left < right) {
        lmax = Math.max(lmax, arr[left])
        rmax = Math.max(rmax, arr[right])
        if(lmax < rmax) {
            sum += (lmax - arr[left])
            left++
        } else {
            sum += (rmax - arr[right])
            right--
        }
    }
    return sum
}
```
