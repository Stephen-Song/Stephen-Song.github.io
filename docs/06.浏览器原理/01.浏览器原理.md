---
title: 浏览器原理
date: 2021-11-24 15:31:36
permalink: /pages/7c5778/
---
# 浏览器安全

## 介绍一下什么是xss

概念：

xss是跨站脚本攻击，是一种代码注入攻击，攻击者通过，攻击者通过网站注入恶意脚本，使之在用户的浏览器上运行，进而盗取用户的信息如cookies等



本质：

网站对恶意代码进行过滤，与正常的代码混合在一起，浏览器无法分辨哪些是可信的，导致恶意代码执行



方式:

- 获取页面的数据，如DOM cookies localstorge
- dos攻击 发送合理请求 占用服务器资源，使得服务器无法访问服务器

- 破坏页面结构
- 流量劫持(将链接指向某网络)



攻击类型

xss可分为存储型 反射型 DOM型

- 存储型指恶意脚本会存储到目标服务器上，当浏览器请求数据，脚本从服务器传回并执行
- 反射型指的是攻击者诱导用户访问一个带有恶意的代码的URL后，服务端接收数据后处理，把带有恶意代码发送到浏览器端，浏览器端解析这段xss代码的数据当做脚本执行，最终完成xss攻击

- dom型指的是修改页面的dom节点形成的xss



存储xss攻击步骤

- 攻击者将恶意代码提交到目标网站的数据库
- 用户打开目标网站，网站服务端从数据库中取出，拼接在html中返回给浏览器

- 用户浏览器接收到响应后解析执行，混在其中的恶意代码被执行
- 恶意代码窃取用户数据并发送到攻击者网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定操作

多用于带有用户保存数据的网站功能，如论坛发帖 商品评论 用户私信



反射性xss攻击步骤

- 攻击者构造出特殊URL，包含恶意代码
- 用户打开这个URL，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器

- 用户浏览器接收到响应后解析执行，恶意代码也被执行
- 恶意代码窃取用户数据并发送到攻击者网站，或冒充用户

反射型漏洞常见于通过URL传递参数，如网站的搜索，跳转等，由于用户需要主动打开恶意的URL才能生效，攻击者会结合多种手段诱导点击



**反射型和存储型主要区别是：反射型恶意代码存储在URL中，存储型恶意代码存储在数据库中**

dom型xss攻击步骤

- 构造特殊的URL，包含恶意代码
- 用户打开这个URL

- 用户浏览器接收到响应后解析执行，前端js取出URL中的恶意代码并执行
- 恶意代码窃取用户数据并发送到攻击者网站，或冒充用户

dom和反射型的区别是反射型是他点击了一个链接然后他在服务端拦截然后操作你的信息或让你跳转到某个页面去，而dom型就是控制你的dom，当你点击之后他会弹出信息或者操作你的信息或者在页面中嵌入插入一个链接，其地址为用户输入的内容

## 如何防范xss攻击

- 不使用服务端渲染，或者对插入到html中的代码充分转义
- 使用csp，意思就是建立一个白名单，告诉浏览器那些外部资源是可以加载执行的，防止恶意代码的注入

- - CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式

- 对一些敏感信息进行保护，比如cookies使用http-only，使得脚本无法获得，也可以使用验证码，避免脚本伪装成用户进行操作

## 介绍一下什么是csrf

概念：

指的是跨站请求伪造攻击，攻击者诱导用户进入第三方网站，然后该网站向被攻击网站发送跨站请求，如果用户在被攻击的网站保存了登录状态，那么攻击者就可以利用这个登录状态来冒充用户向原有网站发出请求了

本质：

利用cookies会在同源请求中携带发送给服务器的特点来实现用户的冒充



攻击类型：

get类型的csrf攻击：在网站的img标签构建一个请求，当用户打开这个网站就自动发起请求

post类型的：构建一个表单，隐藏他，当用户进入页面的时候自动提交这个表单

链接类型的csrf：在a标签里面构建一个请求，诱导用户去点击

## 如何防范csrf攻击

- **进行同源检测**，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）
- **使用 CSRF Token 进行验证**，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。

- **对 Cookie 进行双重验证**，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
- **在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用**，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。



## 介绍一下什么是中间人攻击

中间人攻击是指攻击者在通讯两端分别创立的联系，并交换其收到的数据，是通讯两端认为他们正在一个私密的连接与对方直接对话，但是事实上整个会话都被攻击者完全控制，在中间人攻击中，攻击者可以拦截通讯对方的内容进行篡改或插入新内容



攻击过程：

- 客户端发请求到服务端，请求被中间人截获
- 服务器想客户端发送公钥

- 中间人获取公钥，保留在自己手中，给客户端发送中间人自己伪造的公钥
- 客户端收到伪造的公钥，生成加密hash发给服务器

- 中间人截获加密hash，用自己的私钥解密获得真正的密钥，同时生成假的加密hash发送给服务器
- 服务器用私钥解密获得假密钥，然后加密数据传输给客户端



## 介绍一下有哪些可能造成前端安全问题

- 跨站攻击脚本
- iframe的滥用：iframe中的内容是由第三方提供的，默认不受控制，可以在iframe上运行js脚本，flash脚本弹出对话框等破坏前端用户体验

- csrf
- 恶意第三方库



## 网络劫持有哪几种，如何防范

- DMS劫持：输入jd.com强制跳转到taobao.com属于dns劫持

- - dns强制解析：通过修改运营商的本地dns记录，来引导用户流量到缓存服务器
  - 302跳转：通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的，再对劫持的内存发起302跳转的回复，引导用户获得内容

- HTTP劫持：访问google.com一直有贪玩蓝月广告，由于http明文传输，运营商会修改你的http响应内容

dns劫持由于涉嫌违法，已经被监管起来，现在很少有dns劫持，而http劫持依然非常盛行，最有效的方法还是使用https，使得运营商无法获取明文，就无法劫持你的响应内容



# 进程和线程

## 介绍一下进程和线程

概念：从本质来说，进程和线程都是cpu工作时间片的描述

- 进程描述了cpu在运行指令及加载和保存上下文所需的时间，放在应用上来说就是一个程序
- 线程是进程更小的单位，描述了执行一段指令所需的时间

进程是资源分配的最小单位，而线程cpu调度的最小单位

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。**进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间**

如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。

进程和线程之间的关系有以下四个特点：

**（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

**（2）线程之间共享进程中的数据。**

**（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，** 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

**（4）进程之间的内容相互隔离。** 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。

**Chrome浏览器的架构图**： ![img](https://cdn.nlark.com/yuque/0/2021/webp/1190141/1636790236543-0e666368-b3eb-4495-8b17-fd51a50d06d5.webp) 从图中可以看出，最新的 Chrome 浏览器包括：

- 1 个浏览器主进程
- 1 个 GPU 进程

- 1 个网络进程
- 多个渲染进程

- 多个插件进程

这些进程的功能：

- **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- **GPU 进程**：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **网络进程**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- **插件进程**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

所以，**打开一个网页，最少需要四个进程**：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- **更高的资源占用**：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- **更复杂的体系架构**：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。



## 进程和线程的区别

- 进程可以看做独立应用，线程不能
- 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。

- 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
- 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

## 浏览器的渲染进程的线程有哪些

![img](https://cdn.nlark.com/yuque/0/2021/webp/1190141/1636818920702-d2989b1a-5303-4bed-99f2-ad91bdcd900d.webp)

- **GUI渲染线程** 负责渲染浏览器页面，解析html、css，构建dom树、cssom树、render树和绘制页面，当界面需要重绘或者某些操作引发的回流，该线程就会执行

- - GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列等到JS引擎空闲时候立即被执行

- **JS引擎线程** 也称为JS内核，负责处理js，解析js并运行，JS引擎线程一直等待任务队列中任务的到来，然后处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序

- - 由于GUI和js引擎的互斥，如果JS执行时间过长，会导致页面渲染不连贯，导致页面渲染加载阻塞

- **事件触发线程** 用来控制事件循环，当js引擎执行到setTimeout(或者鼠标点击，ajax请求)，会将对应任务加入到事件触发线程，当对应的事件符合触发条件的时候，该线程会把事件添加到待处理队尾，等待JS引擎线程处理

- - 由于JS是单线程，所以待处理队列的事件都得排队等待

- **定时器触发线程** 即setInterval与setTimeout所在线程，浏览器定时计数器并不是由js引擎计数的，因为JS引擎是单线程，如果处于阻塞就会影响计时的准确性，因此使用单独的线程来计时并且触发定时器，到时就添加进事件队列里面，等待JS引擎空闲的时候执行，所以不一定准确，定时器只是将指定时间点的任务添加进事件队列

- - W3C规定 定时器定时不能小于4ms 如果小于4ms默认为4ms

- **异步http请求线程** XMLHttpRequest连接后通过浏览器新开一个线程请求，当他检测到状态变更的时候如果设有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行



## 进程之前的通信方法

- 管道通信

- - 管道是最基本的进程间通信机制，**管道是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到缓存区中供进程2读取**
  - 特点

- - - 单向通信
    - 只能血缘关系的进程进行通信

- - - 依赖于文件系统
    - 生命周期跟进程一样

- - - 面向字节流的服务
    - 管道内部提供同步机制

- 消息队列通信

- - 消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。
  - 使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。

- 信号量通信

- - 共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。

- 信号通信

- - 信号(Signals)是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。

- 共享内存通信

- - 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

- 套接字通信

- - 上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。

## 僵尸进程和孤儿进程是什么

- **孤儿进程**：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
- **僵尸进程**：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。



## 死锁产生的原因和解决办法

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

系统中的资源可以分为两类：

- 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
- 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

**产生死锁的原因：**

**（1）竞争资源**

- 产生死锁中的竞争资源之一指的是**竞争不可剥夺资源**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
- 产生死锁中的竞争资源另外一种资源指的是**竞争临时资源**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

**（2）进程间推进顺序非法**

若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁

**产生死锁的必要条件：**

- 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
- 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。

- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- 环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。

**预防死锁的方法：**

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）

- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

## 如何实现浏览器多个标签页之间的通信

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：

- **使用 websocket 协议**，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
- **使用 ShareWorker 的方式**，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。

- **使用 localStorage 的方式**，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
- **使用 postMessage 方法**，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。

## 对service Worker的理解

Service Worker 是运行在浏览器背后的**独立线程**，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 **HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：

// index.js if (navigator.serviceWorker) {   navigator.serviceWorker     .register('sw.js')     .then(function(registration) {       console.log('service worker 注册成功')     })     .catch(function(err) {       console.log('servcie worker 注册失败')     }) } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener('install', e => {   e.waitUntil(     caches.open('my-cache').then(function(cache) {       return cache.addAll(['./index.html', './index.js'])     })   ) }) // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener('fetch', e => {   e.respondWith(     caches.match(e.request).then(function(response) {       if (response) {         return response       }       console.log('fetch source')     })   ) }) 复制代码

打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了： ![img](https://cdn.nlark.com/yuque/0/2021/webp/1190141/1636879586496-7d122d55-5995-4934-b270-acceb26182fb.webp) 在 Cache 中也可以发现所需的文件已被缓存： ![img](https://cdn.nlark.com/yuque/0/2021/webp/1190141/1636879587498-953a3df1-9aed-4df4-afd7-13921d6cd087.webp)

# 浏览器缓存

## 介绍一下浏览器的缓存机制

全过程：

- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；

- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；

- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

![img](https://cdn.nlark.com/yuque/0/2021/png/1190141/1636881130887-5dd957dc-ed89-4086-a606-f2e3a229dd59.png)很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。



## 浏览器资源缓存的位置有哪些

资源缓存的位置一共有 3 种，按优先级从高到低分别是：

1. **Service Worker：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且**缓存是持续性的**。当 Service Worker 没有命中缓存的时候，需要去调用 fetch 函数获取数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。**但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。**
2. **Memory Cache：** Memory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

1. **Disk Cache：** Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据**

1. 1.  Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：

- - 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
  - 可以推送 no-cache 和 no-store 的资源

- - 一旦连接被关闭，Push Cache 就被释放
  - 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存

- - Push Cache 中的缓存只能被使用一次
  - 浏览器可以拒绝接受已经存在的资源推送

- - 可以给其他域名推送资源

## 协商缓存和强缓存的区别

- **强缓存**

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。

强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。

（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，

Cache-Control可设置的字段：

- public：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
- private：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；

- no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；

- max-age=：设置缓存的最大有效期，单位为秒；
- s-maxage=：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；

- max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。

**no-cache和no-store很容易混淆：**

- no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
- no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。



- **协商缓存**

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。

上面已经说到了，命中协商缓存的条件有两个：

- max-age=xxx 过期了
- 值为no-store

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。

协商缓存也可以通过两种方式来设置，分别是 http 头信息中的**Etag** 和**Last-Modified**属性。

（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

**总结：**

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。



## 为什么需要浏览器缓存

对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。

如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。

**浏览器缓存**指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。

使用浏览器缓存，有以下优点：

- 减少了服务器的负担，提高了网站的性能
- 加快了客户端网页的加载速度

- 减少了多余网络数据传输

## 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

- **点击刷新按钮或者按 F5：** 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
- **用户按 Ctrl+F5（强制刷新）：** 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。

- **地址栏回车**： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

# 浏览器组成

## 对浏览器的理解

浏览器的功能就是将用户选择的web资源呈现出来，资源的格式通常是html，也包括PDF和image，用户通过URL（统一资源标识符）来指定请求资源的位置。浏览器分为两部分，shell和内核

- shell是指浏览器的外壳，例如菜单，工具栏等，主要是提供给用户界面操作，参数设置等等，他是调用内核来实现各种功能的
- 内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块

## 对浏览器内核的理解

浏览器内核主要分成两部分：

- 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。
- JS 引擎：解析和执行 javascript 来实现网页的动态效果。

最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎

## 一些主流浏览器的内核

- IE 浏览器内核：Trident 内核，也是俗称的 IE 内核
-  Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核

-  Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核
- Safari 浏览器内核：Webkit 内核

- Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核
- 360浏览器、猎豹浏览器内核：IE + Chrome 双内核

- 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）
- 百度浏览器、世界之窗内核：IE 内核

- 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了
- UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident

## 浏览器的主要组成部分 

- **⽤户界⾯** 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。
- **浏览器引擎** 在⽤户界⾯和呈现引擎之间传送指令。

- **呈现引擎** 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
- **⽹络** ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。

- **⽤户界⾯后端** ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。
- **JavaScript 解释器**。⽤于解析和执⾏ JavaScript 代码。

- **数据存储** 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。

值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程

# 浏览器的渲染原理

## 简述一下浏览器的渲染过程

- 首先解析收到的文档，根据文档的定义构建一棵DOM树，DOM树是由DOM元素及属性节点组成的
- 然后对css进行解析，生成CSSOM树

- 根据DOM树和CSSOM树构建render树，渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM元素相对应，但是不可见的DOM元素不会被插入render树上，还有一个dom元素对应几个可见对象，是一些具有复杂结构的元素，无法用矩形来描述
- 当渲染对象被创建并添加到树中，他们没有位置和大小，所以当浏览器生成render树之后，会根据render树进行布局(也可以叫回流)，此时浏览器要弄清楚各个节点在页面的确切位置和大小，也被称为自动重排

- 布局结束后是绘制阶段，遍历渲染树并调用渲染对象的paint方法将内容显示在屏幕上，绘制使用UI基础组件

![img](https://cdn.nlark.com/yuque/0/2021/png/1190141/1636961676478-01af36b3-7e4a-403d-9fe3-f9a27cbca5c8.png)**注意：** 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容

## 介绍一下浏览器的渲染优化

- 针对JS：js会阻塞html解析，也会阻塞css解析

- - 尽量将js文件放在body最后
  - body中间尽量不要写script标签

- - script的三种引入方式

- - - **script** 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
    - **async** 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；

- - - **defer** 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。

- 针对CSS：使用css的方法：link @import 内联样式

- - link：浏览器会派发一个线程（http线程）去加载资源文件，同时GUI渲染线程会继续向下渲染代码
  - @import：GUI渲染线程会暂停渲染，去服务器加载资源文件，资源文件没返回之前不会继续渲染(阻碍浏览器渲染)

- - 内联样式：GUI直接渲染
  - 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在header中，让浏览器尽快发送请求去获取css样式。所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中

- 针对DOM树 CSSOM树

- - html文件代码层级尽量不要太深
  - 使用语义化标签，避免不标准语义化的特殊处理

- - 减少css代码的层级，因为选择器是从右向左进行解析的

- 减少回流和重绘

- - 操作dom时，尽量在底层级的dom节点进行操作
  - 不要使用table，一个小的改动会使整个table进行重新布局

- - 不能频繁操作元素的样式，对于静态页面，尽量修改类名，而不是样式
  - 使用css表达式

- - 使用absolute或者fixed，使元素脱离文档流，这样发生变化不会影响其他元素
  - 避免频繁操作dom，可以创建一个文档片段，documentFragment,在他上面应用所有dom操作，然后把他添加到文档中

- - 将元素先display：none，操作结束后再把他显示出来，因为display为none中进行dom操作不会引发回流和重绘
  - 将dom的多个读写操作放在一个，而不是读写操作穿插，得益于浏览器的渲染队列机制

- - - **浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

## 渲染过程中遇到的js文件如何处理

js的加载、解析和执行会阻塞文档的解析，也就是说在构建dom是，html解析器遇到js的话会暂停文档的解析，然后将控制权移交给JS引擎，等他完成之后浏览器再从中断等地方恢复继续解析文档，也就是说，如果想要首屏渲染地越快，就越不应该再首屏加载JS文件，还是建议把script放到body的底部，或者加上defer或async

## 什么是文档的预解析

webkit和firefox都做了优化，当执行JS脚本的时候，另一个线程解析剩下的文档并加载后面需要用到的网络资源，这种方式可以使资源并行加载从而使整体速度更快，值得注意的是预解析并不改变dom树，他将整个工作留给了主解析过程，自己只解析外部资源的引用，比如外部script、css、image

## CSS如何阻塞文档解析

理论上即使css不改变dom树，也就没有必要停下文档的解析等待他们，然而当JS执行时可能在文档解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然会导致很多问题，所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析

## 如何优化关键渲染路径

为了尽快完成首次渲染，需要最大限度减小以下三种可变因素

- 关键资源的数量
- 关键路径长度

- 关键字节的数量

关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

优化关键渲染路径的常规步骤如下：

（1）对关键路径进行分析和特性描述：资源数、字节数、长度。

（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。

（3）优化关键字节数以缩短下载时间（往返次数）。

（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度

## 什么情况下会阻塞渲染

首先渲染的前提是生成render树，所以html和css肯定会阻止渲染，如果想更快，那只能降低文件大小或者压缩，扁平层级，优化选择器。然后当浏览器解析道script标签时，会暂停构建DOM，完成之后才会从暂停的地方重新开始，所以想更快，就不应该在首屏加载JS文件，全是建议在body标签底部写入script标签的

或者给script标签加上defer或者async属性，都会并行下载，同时不会阻塞渲染



## 浏览器的本地存储

## 浏览器本地存储的方式和使用场景

- cookies

cookies的大小只有4kb，他是一种纯文本文件，每次发起http请求都会携带cookies

特性：

- 一旦创建成功，名称就无法更改
- 无法跨域名，可以阻断非法获取其他网站的cookies

- 每个域名下的cookies不能超过20个，每个大小不能超过4kb
- 如果cookies被拦截，那就可以获得session所有信息，无需知道cookies的意义，只要转发cookies就能达到目的

- cookies在请求一个页面的时候也会被发送过去

需要域名之间跨域共享cookies的方法

1. 使用nginx反向代理
2. 在一个站点登陆之后，往其他网站写cookies，服务端的session存储到一个节点中，cookies存储sessionId

使用场景：

- 将sessionId存储到cookies中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发出的请求，从而响应
- 统计页面的点击次数



- LocalStorge

优点：

- 大小一般5MB，可以存储更多信息
- 是持久存储，不会随着页面的关闭而消失，除非主动清理，不然永久存在

- 仅存储在本地，不像cookies一样每次HTTP请求都被携带

缺点：

- IE8以下不兼容
- 若浏览器设置为隐私模式，无法读取localstorage

- 收到同源策略的限制，即端口、协议、主机有任何一个不同都不会访问

API

```javascript
// 保存数据到 localStorage
localStorage.setItem('key', 'value');

// 从 localStorage 获取数据
let data = localStorage.getItem('key');

// 从 localStorage 删除保存的数据
localStorage.removeItem('key');

// 从 localStorage 删除所有保存的数据
localStorage.clear();

// 获取某个索引的Key
localStorage.key(index)
```

使用场景：

- 有些网站有换肤功能，将换肤信息存储在localstorage中
- 用户浏览信息也存储在localstorage中，主要存储一些不常变动的信息



- SessionStorage

主要用于临时保存同一窗口（或标签页）的数据，刷新页面不会删除，关闭窗口或者标签页才会删除这些数据

API

```javascript
// 保存数据到 sessionStorage
sessionStorage.setItem('key', 'value');

// 从 sessionStorage 获取数据
let data = sessionStorage.getItem('key');

// 从 sessionStorage 删除保存的数据
sessionStorage.removeItem('key');

// 从 sessionStorage 删除所有保存的数据
sessionStorage.clear();

// 获取某个索引的Key
sessionStorage.key(index)
```

## cookies有哪些字段和作用

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问

## Cookies LocalStorage SessionStorage的区别

- **cookie：** 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。
- **sessionStorage：** html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。

- **localStorage：** html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

当需要存储大量数据的时候，就可以采用浏览器的indexDB，内部采用对象仓库的形式存储数据



## 前端的储存方式有哪些

- cookies： 优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；
- localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ 

- sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式
- IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便利

## 介绍一下indexDB

- **键值对储存**：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误
- **异步**：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现

- **支持事务**：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
- **同源限制：** IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。

- **储存空间大**：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
- **支持二进制储存**：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）

# 浏览器的同源策略

## 介绍一下什么是同源策略

同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：**协议**、**端口号**、**域名**必须一致

同源策略主要限制了

- 当前域下的js不能访问到其他域下的cookies、localstorage和indexDB
- 当前域不能操作和访问其他域下的DOM

- 当前域下的ajax无法发送跨域请求

同源策略主要是保证用户的信息安全，只是对js脚本的一种限制，并不是对浏览器的限制，对于一般的img都不会有跨域的限制，因为这些都不会出现安全问题

## 如何解决跨域问题

- cors

mdn的解释是跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源

简单地来说就是只要服务器端实现了cors请求就可以跨源通信了

浏览器将cors分为简单请求和非简单请求



简单请求不会触发cors预检请求

HTTP请求方法是HEAD GET POST

HTTP请求头信息不超过以下的字段Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

但比较常见的json就不是简单请求了

## 简述一下简单请求的过程

浏览器会直接发出CORS请求，他会在他会在请求的头信息上增加一个Origin字段，该字段用来说明本次请求来自于哪一个源（协议+端口+域名），如果origin指定的域名在许可范围内，服务器返回的响应会多出以下信息

```javascript
Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直
Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
Access-Control-Expose-Headers: FooBar   // 指定返回其他字段的值
Content-Type: text/html; charset=utf-8   // 表示文档类型
```

如果指定的域名不在许可范围内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin，表示就出错了，这个是无法通过状态吗进行判断的

## 简述一下非简单请求的过程

非简单请求比如DELETE PUT会在正式通信之前会进行一次预检请求，就是当前所在的网页是否在服务器允许访问的范围内，以及可以使用的请求方法，只有得到服务端肯定的回复才能进行正式的HTTP请求，否则就会报错

预检的请求方法是option，他的头信息关键就是origin，除此之外还有

- **Access-Control-Request-Method**：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。
- **Access-Control-Request-Headers**： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段

如果服务器根据头信息的三个字段进行判断，如果返回的头信息有Access-Control-Allow-Origin就是允许跨域请求

服务器返回的cors字段有

```javascript
Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址
Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法
Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段
Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒
```

前三个是服务端是必须返回的字段



要值得注意的是我们在日常的开发中要减少options请求次数，因为

- 请求次数过多会损耗页面的加载性能，降低用户体验度
- 可以在后端返回头部添加Access-Control-Max-Age表示可以被缓存多久，单位是秒，对完全一样的URL缓存设置生效，在这个时间段内就不需要预检了

还有一个是CORS中的cookies问题

在CORS请求中如果想传递cookies，要满足以下三个条件：

- 在请求中加上withCredentials

```javascript
// 原生 xml 的设置方式
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
// axios 设置方式
axios.defaults.withCredentials = true;
```

- Access-Control-Allow-Credentials 设置为 true
- Access-Control-Allow-Origin 设置为非 *****

## 其他跨域方式

### JSONP

**jsonp**的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 

```javascript
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';
    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);
    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

服务端返回如下（返回时即执行全局函数）

```javascript
handleCallback({"success": true, "user": "admin"})
```

Vue axios实现

```javascript
this.$http = axios;
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

nodejs代码

```javascript
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();
server.on('request', function(req, res) {
    var params = querystring.parse(req.url.split('?')[1]);
    var fn = params.callback;
    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
```

当然缺点就是仅支持get方法和不安全，可能遭到xss攻击

### postMessage跨域

主要解决了

- 页面和其打开的新窗口的数据传递
- 多窗口之间的消息传递

- 页面与嵌套的iframe消息传递

用法：postMessage(data,origin)方法接受两个参数：

- **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
- **origin**： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

1）a.html：(domain1.com/a.html)

```javascript
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };
    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>
```

2）b.html：(domain2.com/b.html)

```javascript
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);
        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;
            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
</script>
```

### nginx代理跨域

实际上与CORS跨域原理一样，都是配置Access-Control-Allow-Origin…等字段。

nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置

```javascript
location / {
  add_header Access-Control-Allow-Origin *;
}
```

nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问

```nginx
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;
        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

### nodejs中间件代理跨域

原理也与nginx大致相同，都是通过代理然后进行转发，也可以通过设置cookiesDomainRewrite参数修改响应头中cookies中域名，实现当前域的cookies写入，方便接口登陆认证

**非vue框架的跨域** 使用node + express + http-proxy-middleware搭建一个proxy服务器

前端：

```javascript
var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问http-proxy-middleware代理服务器
xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
xhr.send();
```

中间件服务器代码

```javascript
var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();
app.use('/', proxy({
    // 代理跨域目标接口
    target: 'http://www.domain2.com:8080',
    changeOrigin: true,
    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },
    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
}));
app.listen(3000);
console.log('Proxy server is listen at port 3000...');
```

### document.domain + iframe跨域

仅限主域相同，子域不同的跨域应用场景，实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域

1）父窗口：(domain.com/a.html)

```javascript
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

子窗口：(child.domain.com/a.html)

```javascript
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    console.log('get js data from parent ---> ' + window.parent.user);
</script>
```

### location.hash + iframe跨域

实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象

a.html：(www.domain1.com/a.html)

```javascript
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>
```

2）b.html：(www.domain2.com/b.html)

```javascript
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>
```

3）c.html：(www.domain1.com/c.html)

```javascript
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

### window.name + iframe跨域

window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）

1）a.html：(domain1.com/a.html)

```javascript
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');
    // 加载跨域页面
    iframe.src = url;
    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();
        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };
    document.body.appendChild(iframe);
    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};
// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});
```

2）proxy.html：(domain1.com/proxy.html)

中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)

```javascript
<script>    
    window.name = 'This is domain2 data!';
</script>
```

通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作

### WebSocket协议跨域

原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容



前端：

```javascript
<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');
// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });
    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});
document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

node:

```javascript
var http = require('http');
var socket = require('socket.io');
// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });
    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.'); 
    });
});
```

## 介绍一下正向代理和反向代理

- 正向代理

- - 客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置

- 反向代理

- - 服务器为了能够将工作负载分配到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了

![img](https://cdn.nlark.com/yuque/0/2021/png/1190141/1637306984094-e9a023db-3454-494a-9757-3846eeb3f4b4.png)

区别：

正向代理和反向代理结构都是一样的，都是client-proxy-server的结构，他们主要的区别是在于中间的proxy是哪一方设置的，在正向代理中，proxy是client设置的，用来隐藏client，而在反向代理中，proxy是server设置的，用于隐藏server



## nginx概念及其工作原理

Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。

传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。

Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个



# 浏览器的事件循环

## 什么是事件，什么事件模型

事件是用户操作网页的时候发生的交互动作，比如click/move，除了这些还可以是文档加载，窗口滚动和大小调整，事件被封装成一个event对象，包含了该事件发生的所有相关信息以及可以对事件进行的操作

事件模型

- DOM 0级事件模型，这种模型不会传播，所以没有时间流的概念，他在网页中直接定义监听函数，在dom对象上注册事件名称
- IE事件模型 一次事件共有两个过程，事件处理阶段和事件冒泡阶段，事件处理阶段会首先执行目标元素绑定的监听事件，然后是事件冒泡阶段，就是事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，有的话就执行，这种通过attachEvent添加监听函数，可以添加多个监听函数，会按顺序执行

- DOM 2级事件模型 一个是事件捕获，是从是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

## 如何阻止事件冒泡

- 普通浏览器使用：event.stopPropagation()
- IE浏览器使用：event.cancelBubble = true;

## 对事件委托的理解

概念：

本质上是利用了**浏览器事件冒泡**的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）

使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理

特点：

- 减少内存消耗

- - 如果把列表的每一个元素都绑定一个函数就会消耗很大的内存，效率比较低，绑定到父级上的话点击的时候再去匹配目标元素就可以大量减少内存消耗

- 动态绑定事件

- - 如果事件绑定在父级上的话，那么增加和删减子元素就不用重新监听或解绑事件

- 局限性

- - focus、blur没有事件冒泡机制，无法实现事件委托，mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的

当然事件委托不是只有优点，它也是有**缺点**的，事件委托会影响页面性能，主要影响因素有：

- 元素中，绑定事件委托的次数；
- 点击的最底层元素，到绑定事件元素之间的DOM层数；

在必须使用事件委托的地方，可以进行如下的处理：

- 只在必须的地方，使用事件委托，比如：ajax的局部刷新区域
- 尽量的减少绑定的层级，不在body元素上，进行绑定

- 减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。

## 同步和异步的区别

- **同步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
- **异步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。

## 对事件循环的理解

因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当同步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。

![img](https://cdn.nlark.com/yuque/0/2021/png/1190141/1637331947853-d35f389e-2983-45a3-97cf-d8dd0faccec5.png)

Event Loop 执行顺序如下所示：

- 首先执行同步代码，这属于宏任务
- 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行

- 执行所有微任务
- 当执行完所有微任务后，如有必要会渲染页面

- 然后开始下一轮 Event Loop，执行宏任务中的异步代码

## 宏任务和微任务分别有哪些

- 微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。
- 宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等

## 介绍一下什么是执行栈

![img](https://cdn.nlark.com/yuque/0/2021/png/1190141/1637332083984-ce32e9cc-d877-47ce-8c47-02b0ca9f2773.png)

当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，**foo** 函数后执行，当执行完毕后就从栈中弹出了



## node中的EventLoop和浏览器的区别？process.nextTick执行顺序是什么

Node 的 Event Loop 分为 6 个阶段，它们会按照**顺序**反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段

![img](https://cdn.nlark.com/yuque/0/2021/png/1190141/1637332372839-5222a50b-e5aa-4672-807f-db9ba6195c9a.png)

（1）**Timers（计时器阶段）**：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。

（2）**Pending callbacks**：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。

（3）**Idle/Prepare**：仅供内部使用。

（4）**Poll（轮询阶段）**：

- 当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。
- 当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。

（5）**Check（查询阶段）**：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。

（6）**Close callbacks**：执行一些关闭回调，比如socket.on('close', ...)等。

下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是**随机**的

```javascript
setTimeout(() => {    
  console.log('setTimeout')
}, 0)
setImmediate(() => { 
  console.log('setImmediate')
})
```

对于以上代码来说，**setTimeout** 可能执行在前，也可能执行在后

- 首先 **setTimeout(fn, 0) === setTimeout(fn, 1)**，这是由源码决定的
- 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 **setTimeout** 回调

- 那么如果准备时间花费小于 1ms，那么就是 **setImmediate** 回调先执行了

当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：

```javascript
const fs = require('fs')
fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
```

在上述代码中，**setImmediate** 永远**先执行**。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 **setImmediate** 回调，所以就直接跳转到 check 阶段去执行回调了。

上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前**清空** microtask 队列，下图中的 Tick 就代表了 microtask ![img](https://cdn.nlark.com/yuque/0/2021/webp/1190141/1637333214436-6592e19b-51f4-4c43-8d24-ea52d4d40e31.webp)

```javascript
setTimeout(() => {
  console.log('timer21')
}, 0)
Promise.resolve().then(function() {
  console.log('promise1')
})
```

对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。



最后来看 Node 中的 **process.nextTick**，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会**清空队列中的所有回调函数**，并且优先于其他 microtask 执行。

```javascript
setTimeout(() => {
 console.log('timer1')
 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)
process.nextTick(() => {
 console.log('nextTick')
 process.nextTick(() => {
   console.log('nextTick')
   process.nextTick(() => {
     console.log('nextTick')
     process.nextTick(() => {
       console.log('nextTick')
     })
   })
 })
})
```

对于以上代码，永远都是先把 nextTick 全部打印出来。

##  事件触发的过程是怎么样的

事件触发有三个阶段：

- **window** 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件

- 从事件触发处往 **window** 传播，遇到注册的冒泡事件会触发

事件触发一般来说会按照上面的顺序进行，但是也有特例，**如果给一个** **body** **中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行**

```javascript
// 以下会先打印冒泡然后是捕获
node.addEventListener(
  'click',
  event => {
    console.log('冒泡')
  },
  false
)
node.addEventListener(
  'click',
  event => {
    console.log('捕获 ')
  },
  true
)
```

通常使用 **addEventListener** 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 **useCapture** 参数来说，该参数默认值为 **false** ，**useCapture** 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：

- **capture**：布尔值，和 **useCapture** 作用一样
- **once**：布尔值，值为 **true** 表示该回调只会调用一次，调用后会移除监听

- **passive**：布尔值，表示永远不会调用 **preventDefault**

一般来说，如果只希望事件只触发在目标上，这时候可以使用 **stopPropagation** 来阻止事件的进一步传播。通常认为 **stopPropagation** 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。

**stopImmediatePropagation** 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。

```javascript
node.addEventListener(
  'click',
  event => {
    event.stopImmediatePropagation()
    console.log('冒泡')
  },
  false
)
// 点击 node 只会执行上面的函数，该函数不会执行
node.addEventListener(
  'click',
  event => {
    console.log('捕获 ')
  },
  true
)
```

# 浏览器的垃圾回收机制

## 介绍一下v8的垃圾回收机制

V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分

**（1）新生代算法**

新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

**（2）老生代算法**

老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。

先来说下什么情况下对象会出现在老生代空间中：

- 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

老生代中的空间很复杂，有如下几个空间

```javascript
enum AllocationSpace {
  // TODO(v8:7464): Actually map this space's memory as read-only.
  RO_SPACE,    // 不变的对象空间
  NEW_SPACE,   // 新生代用于 GC 复制算法的空间
  OLD_SPACE,   // 老生代常驻对象空间
  CODE_SPACE,  // 老生代代码对象空间
  MAP_SPACE,   // 老生代 map 对象
  LO_SPACE,    // 老生代大空间对象
  NEW_LO_SPACE,  // 新生代大空间对象
  FIRST_SPACE = RO_SPACE,
  LAST_SPACE = NEW_LO_SPACE,
  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,
  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE
};
```

在老生代中，以下情况会先启动标记清除算法：

- 某一个空间没有分块的时候
- 空间中被对象超过一定限制

- 空间不能保证新生代中的对象移动到老生代中

在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。

清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。

## 哪些操作会造成内存泄漏

- 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

- 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。
