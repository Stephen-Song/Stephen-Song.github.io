---
title: Vue3
date: 2021-11-28 19:54:05
permalink: /pages/8630df/
---
# Vue3.0

## `vue3.0`相对于`vue2.x`有什么更新

- 监测机制的改动：基于`proxy`的`observer`的实现，消除了`Vue2.x`的`Object.defineProperty` 的实现所存在的很多限制

- 只监测属性，不监测对象

    - 监测属性的添加和删除

    - 监测数组的索引和长度的变更

    - 支持`map` `set` `weakmap` `weakset`

- 模板

    - 3.0版本将作用域插槽改成函数的形式，这样只会影响子组件的重新渲染，提升性能

    - 对象式组件声明方式

    - `vue2.x`通过声明形式传入`option`，和`ts`的结合需要通过装饰器，3.0改成类式的写法，和ts更方便结合

- 其他

    - 支持自定义渲染

    - 支持`fragment`(多根节点)和`portal`组件

    - 基于`tree shaking`

## `proxy`和`defineProperty`区别

`Vue2.x`在实例初始化的时候遍历`data`对象中所有的属性，利用`Object.defineProperty`将这些属性转换成`getter/setter`，当数据发生变化自动触发`setter`

`defineProperty`是`es5`无法使用`polyfill`的特性，所以不支持`ie8`以下

但是`defineProperty`缺点

- 无法监测添加和删除对象的属性，因为没有初始化的时候添加`getter/setter`，只能通过`$set`进行处理

- 无法监测到数组下标和长度的变化



采用`proxy`来监测数据的变化，`proxy`是`es6`的功能，有以下优点

- `proxy`可以直接代理整个对象而非对象属性，只需做一层代理就可以监听同级一下所有属性的变化，包括新增属性和删除属性

- `proxy`可以监听数组的变化

## `proxy`在`vue`中的工作原理

- `get`依赖收集

- `set` `delete`触发依赖

- 对于集合类型，就是在集合对象做一层包装：原方法执行后执行依赖相关的收集或者触发逻辑
