---
title: Vue
date: 2021-11-28 17:11:45
permalink: /pages/f0a671/
---

# Vue基础

## 介绍一下`Vue`原理

创建实例 -> 遍历data的属性 -> 用(`object.defineProperty/proxy`)转化为`getter`/`setter`）-> 在实例中的`watcher`收集`data`的属性 -> 当`data`的属性改变触发`setter`的时候通知`watcher` -> `watch`会将关联的组件都更新一遍

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202111281717626.png)

## 介绍一下`Vue`双向绑定的原理

采用了**数据劫持**和**发布订阅的方式**

::: tip 数据劫持的笼统意思
`observe`的数据对象进行递归遍历，然后添加上`getter`和`setter`，当值改变的时候会触发`setter`，就能监听到数据的变化了
:::


::: tip 发布订阅的意思
`compile`解析模板数据，然后将模板上面的变量替换成数据，然后初始化渲染视图，将每个指令对应的节点绑定更新函数 添加监听数据的订阅者 ，数据变动 -> 收到通知 -> 更新视图
:::


而`watcher`订阅者就是连接`observe`和`compile`的桥梁

1. 在属性订阅器中(`dep`) 添加实例化的`watcher`

2. watcher的实例自身有个`update`方法

3. 属性变动的时候调用`dep.notice()`

4. 调用`update()`

1. 触发`compile`绑定的函数

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202111281723812.png)

## 介绍一下什么是`MVVM`、`MVC`、`MVP`

>`mvvm`是 `model` `view` `viewModel`


- `model`层代表数据模型 数据和业务逻辑都在`model`层
- `view`代表`ui`视图 负责数据的展示

- `viewModel` 监听`model`数据的改变并控制视图更新，处理交互

`model`和`view`无直接连接 而是通过`viewModel`进行联系，`model`和`viewModel`数据双向绑定，`view`层交互改变的数据 `model`层也会改变，`model`层数据改变也会触发`view`层的更新，这样程序猿们就可以专心在`viewModel`层编写业务逻辑，不用关心数据的传递

>`mvc`是`model` `view` `controller`

- `view`代表`ui`视图

- `model`储存页面的数据

- `controller`层负责用户与应用的响应操作

`view`和`model`层应用了观察者模式，`model`层数据变化会通知`view`进行更新，用户操作 `controller`触发，调用`model`修改 然后在通知`view`进行更新


>`mvp`跟`mvc`大致相同
- mvc中的`model`和`view`层都耦合在一起，当逻辑复杂时候会造成代码混乱，通过`mvp`的`presenter`层，将`model`和`view`绑定在一起，实现同步更新，实现对`view`和`model`层的解耦



## 说一下`computed`和`watch`的区别

`computed`计算属性：依赖其他属性值，不支持异步，并且有缓存，只有当依赖的属性值发生改变 才会重新计算`computed`的值（例如购物车的价格就可以用`computed`）

`watch`监听器：只是充当观察作用，支持异步，无缓存，类似某种数据监听回调，当监听的数据变化执行回调进行后续操作（适用于当数据变化需要执行异步方法或开销比较大的操作）

## 说一下`slot`都有哪些用法 原理是什么

默认插槽：没有指定`name`的时候 会指定默认插槽，一个组件只能有一个

具名插槽：指定了`name`属性的`slot`，一个组件可以有多个具名插槽

作用域插槽：可以是匿名插槽也可以是作用域插槽，可以将子组件内部的数据传递给父组件

>原理：当子组件实例化时，获取父组件传入`slot`标签的内容，存在`vm.$slot`，默认插槽为`vm.$slot.default` 具名插槽为`vm.$slot.xxx`，当组件执行渲染函数的时候，遇到`slot`，使用`$slot`内容替换，此时可以为插槽传递数据，则叫作用域插槽

## 介绍一下保存页面状态的方法

>前组件会被卸载

- 将当前组件的`state`通过`JSON.stringify()`储存在`LocalStorage` / `SessionStorage`

    - 优点：兼容性好，不需要额外使用库和工具

    - 缺点：相当于JSON.stringify()的缺点(Date对象Reg对象会出错) 组件回退或者前进会出bug

- 通过`react-router` 的 `Link` 组件的 `prop —— to` 可以实现路由间传递参数 通过`history.location.state`拿到状态进行传参

- 优点 简单快捷 不污染`LocalStorage` / `SessionStorage` 解决`JSON.stringify()`的缺点

- 缺点 当前组件可以跳转至多个组件 在跳转组件要多次写相同逻辑

>前组件不会被卸载

- 单页面渲染 要写换的组件作为子组件全屏渲染

    - 优点 代码少 状态传递不出错
    
    - 缺点 需要传递额外prop到子组件 无法利用路由定位

>利用 `keep-alive` 切换时的`actived` `deactivate`被执行

```javascript
<keep-alive>
	<router-view v-if="$route.meta.keepAlive"></router-view>
</kepp-alive>

// router.js
{
  path: '/',
  name: 'xxx',
  component: ()=>import('../src/views/xxx.vue'),
  meta:{
    keepAlive: true // 需要被缓存
  }
},
```

## `v-if` 和 `v-show`的区别

- 手段：`v-if`是动态向`dom`树中添加或者删除`dom` `v-show`是设置`display`来隐藏

- 编译过程：`v-if`有一个局部编译和卸载的过程，切换过程合适地销毁和重建内部的事件监听和子组件 `v-show`只是基于`css`切换

- 编译条件：`v-if`是惰性的 初始条件为假则什么都不做，只有第一次条件为真的时候才局部编译 `v-show`一开始就编译然后被缓存

- 性能消耗：`v-if`更高的切换消耗 `v-show`有更高的初始渲染消耗

- 使用场景：`v-if`适合运营条件不太改变的场景 `v-show`适合频繁切换

## `data`为什么是一个函数而不是对象？

>如果`data`是对象时，当组件多次被实例化时，引用的是同一个`data`对象，会导致不同实例操作数据，会相互影响，所以要写成函数形式，数据以返回值的形式定义，每次复用组件时，会返回新的`data`，每个组件都有自己私有数据空间，各自维护数据，不干扰其他组件正常运行

## 对`keep-alive`的理解 如何实现 具体是如何缓存的？

::: tip理解
当组件需要切换是，保存一些组件 防止多次渲染，用keep-alive包裹
:::

有三个属性：

- `include` 字符串或正则表达式 只有名称匹配的组件会被匹配

- `exclude` 字符串或正则表达式，任何名称匹配的组件都不会被缓存

- `max`数字 最多可以缓存多少组件实例

流程：

1. 判断组件的`name` 不在`include`或在`exclude`中，直接返回`vNode`不缓存

2. 获取组件实例`key`

    - `key`生成规则 `cid + "::" tag` 仅靠`cid`不够，因为相同构造函数都可以注册为不同本地组件

3. 如果组件已缓存 就从缓存对象中获取组件实例给`vNode`，不存在则添加进缓存对象里面

4. 超过最大缓存数量，就用`LRU`清除数组内第一个组件



::: warning keep-alive中的LRU算法(least recently used)
通过`cache`数组存放所有组件的`vNode` 当`cache`中原有的组件被使用的时候，会将该组件的`key`从`keys`数组中删去，然后`push`到`keys`数组最后，以便超出`max`后删除最不常用的组件
:::


## `$nextTick`原理
::: tip 原理
利用`JS`原生的`Promise` `MutationObserver` `setImmediate` `setTimeout`的原生`JS`模拟对应的微/宏任务，为了利用`js`这种异步回调任务队列来实现`Vue`中自己的异步回调队列
:::

**<mark>引入原因：</mark>**

- 如果是同步更新 那么会频繁触发`UI/DOM`的渲染，可以减少无用渲染

- 由于`VirtualDOM`的引入 每一次状态改变 信号都会发给`DOM`进行更新 每次更新状态都会需要更多的计算 这种无用功会浪费更多性能

- `Vue`采用`MVVM`，也就是开发者只需`modelView`层进行业务逻辑，利用数据驱动视图的方式，但是避免不了还是要操作`dom`，有时候`DOM1`数据发生变化，此时`DOM2`需要从`DOM1`中获取数据，却发现`DOM2`视图并没有更新，这时候就需要用到`nextTick`

- 还有的情况是在`Vue`生命周期里面，`created`钩子进行`DOM`的操作要放在`nextTick`中，因为执行`created`钩子时，`DOM`还未渲染 无法操作`DOM`



## `Vue`中`template`到`render`的过程

>vue模板编译过程： `template` -> `AST` -> `render`函数

利用`compileToFunctions`

1. 调用`parse`方法将`template`转化为`AST` `constast = parse(template.trim(), options)`

2. 利用正则表达式解析模板，当解析到开始标签 闭合标签 文本 会执行响应的回调

3. `AST`共三种类型 `type`为1 表示普通元素 2为表达式 3为纯文本

>对静态节点优化 `optimize(ast, options)`

1. 分析静态节点，打上tag 在后续的更新render中跳过

2. 生成代码 

3.将AST树编译成render字符串放到staticRenderFns中，通过new Function()生成render 函数

## `Vue` `data` 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？

不会立即同步执行渲染 而是按照一定的策略进行`DOM`异步更新，当侦听到数据变化的时候，`Vue`会开启一个队列，并缓冲同一事件循环中发生的所有数据变更，如果同一个`watcher`被多次触发，只会被推入队列中一次，这时候去除重复数据对避免不必要的计算和`DOM`操作，在下一个时间循环`Tick`中刷新队列并执行(已去重)的工作



## 子组件可以直接改变父组件的数据吗

>子组件不可以改变父组件的数据 

主要是为了维护父子组件的单向数据流，为了意外的改变父组件的状态，使得应用的数据流变得难得理解，只能通过`$emit`派发一个自定义事件，父组件接收到后，由父组件修改



## `Vue`和`React`的理解和异同

相似：

- 都将路由和全局状态管理交给相关库
- 都用了`Virtual Dom`提高重绘性能

- 都有`props` 允许组件数据传递
- 都提倡组件化

不同：

- 数据流：`Vue`默认支持数据双向绑定，`React`提倡单向数据流
- `Virtual DOM`：`Vue`会跟踪每一个组件的依赖关系，不需要重新渲染整棵树 而`React`每当应用改变 全部子组件都会重新渲染，可以通过`PureComponent`/`shouldComponentUpdate`来控制

- 模板编写：`Vue`鼓励常规的`HTML`模板编写 `React`推荐用`JS`的语法扩展 -- `JSX`

- 监听数据变化的原理：`Vue`通过`getter`/`setter`以及函数劫持，精确知道数据的变化 `React`通过比较引用的方式进行的，不优化的话会导致大量不必要的`vDOM`重新渲染

- 高阶组件：`Vue`通过`mixins`扩展 `React`通过`HOC`来扩展



## `Vue`的优点

- 轻量级框架：只关注`modelView`层

- 双向数据绑定： 在数据操作方面更为简单

- 组件化：实现了`html`形式的封装和重用 

- `model` `modelView` `view`层分离 是开发者只需要操作数据就能完成操作

- `virtualDOM` 不用原生的`DOM`操作节点



## assets和static的区别

>相同点：都用来存放静态资源

>不同点：
`static`里面的资源文件不经过压缩直接进入打包的目录，而`asset`里面的文件则经过压缩同`static`一起上传到服务器上，所以`static`里面的文件相对`assets`大一些，我们可以将项目中的`js`文件放在`assets`中，项目的`iconfont`等第三方资源文件放在`static`中，因为他们已经被处理过了



## `Vue`如何监听对象和数组的某个属性改变

1. `this.$set(target, key, value)`

2. `splice()`、 `push()`、`pop()`、`shift()`、`unshift()`、`sort()`、`reverse()`

**<mark>`Vue.$set`原理 </mark>**

- 如果是数组，直接用数组的`splice`方法触发

- 如果是对象，判断属性是否存在 是否为响应式 ，通过调用`defineReactive`(就是`Vue`初始化对象，给对象采用(`Object.defineProperty`动态添加`getter/setter`)



## 对`ssr`的理解

`ssr`是服务端渲染，也就是`Vue`在客户端将标签渲染成`HTML`放在服务端，服务端直接返回给客户端

`ssr`优势：更好的`SEO`、首屏速度变快

`ssr`缺点：服务端渲染只支持`beforeCreate`和`Created`两个钩子 更多的服务端负载

## `Vue`的性能优化

>编码阶段

1. 减少`data`中的数据，因为`data`的数据会增加`getter`和`setter` 会收集相应的`watcher`

2. `v-for`里面不能嵌套`v-if`(因为`v-for`优先级比`v-if`高，所以哪怕渲染一小部分的用户的元素，也得在每次重渲染的时候遍历整个列表)

3. `spa`页面采用`keep-alive`缓存组件

4. `key`保证唯一

5. 使用路由懒加载 异步组件

6. 防抖节流

7. 第三方模块按需导入

8. 懒加载

>`SEO`优化

1. 预渲染
2. `ssr`

>打包优化

1. 压缩`uglify`代码

2. `tree shaking`/ `scope Hoisting`

3. `cdn`加载第三方模块

5. `splitChunk`抽离公共文件

1. `sourceMap`优化

>用户体验

1. 骨架屏

2. `PWA`

3. 服务端开启`gzip`压缩

## 对`SPA`的理解 优缺点是什么

::: tip 概念
`SPA`是`single-page application`是仅在`web`应用初始化的时候加载相应的`html` `css`和`js` ，一旦页面加载完成`SPA`不会因为用户的操作而进行页面的重新加载或跳转，取而代之的是`html`内容的变换，`ui`和用户的交互
:::

>优点：

1. 用户体验好 内容改变不会重新加载页面，避免了不必要的跳转和重复渲染 对服务器压力小

>缺点：

1. 初次加载耗时长，需要在加载页面的时候将`js`和`css`统一加载 部分页面按需加载

2. 前进后退路由管理：不能使用浏览器的前进后退功能

3. SEO难度大，所有内容都在一个页面中动态替换


## `template`和`jsx`区别

对于`runtime`来说只要组件存在`render`函数即可

- `vue`中利用`vue-loader`编译`.vue`文件 内部依赖的`vue-template-compiler` 将`template`预编译成`render`函数

- `react`利用`babel-plugin-transform-vue-jsx`这个`jsx`语法糖解析器就可以了

所以两者都是`render` 的表现形式 但是`jsx`更具有灵活性在复杂组件中有优势 而`template`在代码结构上符合视图和逻辑分离，更简单 更好维护

## `Vue`初始化页面为什么会闪动

在`vue`初始化之前，由于`div`是不归`vue`管的 所以在还没解析的情况可能会出现`{{message}}`的情况

解决方法

- 在根元素标签上加上`v-cloak` ，添加`css`样式 `[v-cloak] {display: none;}`

- 在根元素加上`style="display: none;" :style="{display: 'block'}"`



## `mixin`和`mixins`区别

>`mixin`用于全局混入，会影响到每个组件实例

```javascript
Vue.mixin({    beforeCreate() {        
    // ...逻辑        
    // 这种方式会影响到每个组件的 beforeCreate 钩子函数    
}})
```

可以全局混入封装好的`axios`等

`mixins`用于扩展组件的方式，如果多个组件有相同业务逻辑，可以将逻辑剥离开，通过`mixins`混入代码，比如上拉下拉加载数据等，另外`mixins`混入函数会先于组件的钩子函数，当重名的时候，组件的同名函数会覆盖`mixins`函数


## `MVVM`优缺点

>优点：

- `view`和`model`层相互独立，降低代码耦合，提高视图和逻辑的重用性，`view`层可以独立于`model`层的变化和修改，一个`viewmodel`层可以绑定不同的`view`上
- 自动更新`dom`：利用双向绑定 数据更新后视图自动更新

>缺点：

- `bug`难以调试，使用双向绑定 当页面异常是，可能是`view`层也可能是`model`层的代码问题，另外数据绑定的声明是写在`view`的模板中，没办法断点`debug`

- 一个大模块的`model`层也很大，当长期持有，不释放内存会花费更多内存

1. 对于大型的图形应用程序，视图较多，`viewmodel`的构建和维护成本较高

# Vue生命周期

## 介绍一下`Vue`的生命周期

>开始创建 -> 初始化数据 -> 编译模板 -> 挂载DOM -> 渲染、更新 -> 渲染卸载

1. `beforeCreate`：`data`响应式追踪 `event/watcher`还没设置，访问不到`data` `computed` `watch` `methods`的方法或数据

2. `created`：实例创建完成 可以访问到`data` `computed` `watch` `methods`的方法或数据，但是尚未挂载`dom`，访问不到`$el`属性

3. `beforeMount`：在挂载开始之前被调用，相关`render`函数被调用，实例已完成编译模板，利用`data`里面的数据和模板初次生成`html`，但还没将`html`挂载到文档上

4. `mounted`：完成模板中的`html`渲染到文档上

5. `beforeUpdate`：响应式数据更新时调用，虽然数据更新了，但是对应的真实`dom`还没被渲染

6. `updated`：在数据更改后`dom`重新渲染完成，可以执行依赖于`dom`的操作，但是应该避免在此期间改变状态，会导致更新无限循环，在服务端渲染不被调用(**因为只有初次渲染在服务端进行**)

7. `beforeDestroy`：实例销毁前调用，此处还能获取实例和访问`this`

8. `destroy`：实例销毁，所有时间监听器都被移除

`keep-alive`生命周期

`activated`和`deactivated`，用`keep-alive`包裹的组件在切换是不会进行销毁，而是缓存到内存并执行`deactived`钩子函数，命中缓存渲染执行`activated`钩子函数（`beforeDestroy`、`destroy`不会触发，因为组件都保存在内存中了）



## `Vue`父组件和子组件的执行顺序

**加载渲染过程**

父`beforeCreate` -> 父`created` -> 父`beforeMount` -> 子`beforeCreate` -> 子`created` -> 子`beforeMount` -> 子`mounted` -> 父`mounted`

根据上面的生命周期`mounted`就可以知道，父组件要等子组件把他的`html`代码生成并加入到父组件中，才能一起挂载到文档上

**更新过程**

父`beforeUpdate` -> 子`beforeUpdate` -> 子`update` -> 父`updated`

**销毁过程**

父`beforeDestory` -> 子`beforeDestroy` -> 父`destroyed` -> 子`destroyed`



## `created` `mounted`区别

- `created`在模板渲染`html`前调用，即通常初始化某些属性值，再渲染成视图

- `mounted`在模板渲染`html`后调用，通常是初始化页面完成后，再对`html`的`dom`节点进行一些需要的操作


## 一般在哪个生命周期请求异步数据

推荐在`created`调用异步请求，因为可以更快获取服务端数据、减少页面加载时间，同时`ssr`不支持`beforeMount` 、`mounted` 钩子函数，放在 `created` 中有助于一致性



# 组件通信

>父子

- 父组件通过`props`向子组件传递数据，父组件在子组件上注册监听事件，子组件通过 `emit` 触发事件来向父组件发送数据

- 通过`refs`给子组件设置名字，父组件通过`$refs`获得子组件(`$children` 无序数组)，子组件通过`$parent`获得上一级父组件(对象)，实现通信 在根组件`#app`上拿`$parent`得到的是`new Vue()`的实例，在这实例上再拿`$parent`得到的是`undefined`，而在最底层的子组件拿`$children`是个空数组

- `provide/inject`在父组件通过`provide`提供变量，在子组件通过`inject`注入到组件中，适用于祖孙组件

>兄弟

- 使用`eventBus`，创建一个空的`Vue`实例作为消息传递的对象，通信的组件引入这个实例，通信组件通过实例监听和触发事件，实现通信
- 通过`$parent/$refs`获取兄弟组件

# `Vue-Router`

## 路由的`hash`和`history`区别

<mark>默认是`hash`</mark>

`hash`：他的`url`带着`#` `www.crucial.cn/#/xiaosong,hash`值为`#/xiaosong`

特点：`hash`只出现在`url`里面，不会出现在`http`请求中，改变`hash`值不会重新加载页面，但是浏览器不会自主地记录前后的路径变换，低版本`IE`支持这种模式

原理：针对上面的浏览器不会自主记录前进和后退的路由，可以通过`onhashchange`来监听

```javascript
window.onhashchange = function(event){
	console.log(event.oldURL, event.newURL);
	let hash = location.hash.slice(1);
}
```

这样可以无须通过后端请求就可以监听事件变化从而来加载相应的代码，实现页面的前进和后退

`history`：传统的路由分发模式，即用户输入一个`url`,服务器接收`url`并解析，然后处理逻辑，这样就是没有`#`更好看一点，但是需要后台配置支持，否则出现404

>`API：`

- 修改状态：`pushState`和`replaceState` 这两个`API`也是当路径变化的时候不会访问后端
- 切换状态：`history.forward()` `back` `go`分别是前进后退跳转操作

>**</mark>对比</mark>**

调用`history.pushState`相比`hash`的优势有

- `pushState`设置的`url`可以是当前`URL`同源的任意`URL`，而`hash`只可修改`#`后面的部分，只能设置当前`url`同文档的`url`

- `pushState`可以设置与当前相同的`url`，可以将记录添加进栈中，而`hash`设置的新值必须与原来的不一样才能入栈

- `pushState`通过`stateObject`参数可以添加任意类型的数据进记录中，而`hash`只能添加短字符串

- `pushState`可以额外设置`title`属性

- `hash`情况下后台没有对路由全覆盖也不会返回`404`，而`history`必须跟后端的`url`一致才不会报404



## 如何获取`hash`变化

>监听`$route`

```javascript
// 监听,当路由发生变化的时候执行
watch: {
  $route: {
    handler: function(val, oldVal){
      console.log(val);
    },
    // 深度观察监听
    deep: true
  }
},
```

window.location.hash读取#值，可读可写，写入是可以在不重载网页的前提下添加一条历史访问记录



## $route和$router的区别

- $route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数
- $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。

## Vue-router路由钩子在生命周期的体现

1. 全局钩子

1. 1. router.beforeEach全局前置守卫，进入路由之前(判断是否登录，没登录就重定向到登录页)
   2. router.beforeResovle在beforeRouterEnter调用之后调用

1. 1. router.afterEach全局后置钩子，进入路由之后(一般用于跳转后滚动条回到顶部)

1. 单个路由独享

1. 1. 不想全局配置守卫，可以为某些路由单独配置

```javascript
export default [    
    {        
        path: '/',        
        name: 'login',        
        component: login,        
        beforeEnter: (to, from, next) => {          
            console.log('即将进入登录页面')          
            next()        
        }    
    }
]
```

1. 组件内钩子

1. 1. beforeRouteEnter进入组件前触发

1. 1. 1. 注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问

```javascript
beforeRouteEnter(to, from, next) {      
    next(target => {        
        if (from.path == '/classProcess') {          
            target.isFromProcess = true        
        }      
    })    
}
```

1. 1. beforeRouteUpdate当前地址改变且复用当前组件时触发，例如/foo/1 -> /foo/2
   2. beforeRouteLeave离开组件前触发



## params和query的区别

query用this.$route.query.name引入 params用this.$route.params.name

url显示 query更像get传参，params类似post

query在刷新时不会丢失参数，params在刷新时会丢失参数



# Vuex

## 介绍一下Vuex的工作原理

![img](https://cdn.nlark.com/yuque/0/2021/webp/1190141/1635132363014-82040b1c-d958-489b-9d91-7991934dad60.webp)

- 组件触发(dispatch)一些事件或动作，就是action
- 数据不能直接修改，要把这个动作提交(commit)给mutations

- mutation去改变state的数据
- state被改变会重新render

## Vuex中action和mutation的区别

- mutation专注于修改state 理论是修改state的唯一途径，action进行业务处理和异步请求
- mutation必须同步执行 而action可以异步但不能直接操作state

- 在视图更新时，先触发actions，actions再触发mutation
- mutation的参数是state，它包含store中的数据；actions的参数是context，它是 state 的父级，包含 state、getters



## Vuex和localStorge的区别

- 存储形式不同：vuex存储在内存，而localstorge以文件形式存储在本地，只能存储字符串(JSON.stringify和parse处理过的)，读取内存比读取硬盘的速度快
- 应用场景不同：vuex存储管理应用的所有组件状态，用于组件之间的传值，而localstorge将数据存储到浏览器，一般用于跨页面传输数据，vuex可以做到数据响应式，而localstorge不能

- 永久性：刷新页面时vuex存储的值会丢失，但localstorge不会

理论上localstorge可以代替vuex，当两个组件共用数据源时，如果一个组件改变了该数据源，而利用localstorge存储的数据做不到响应式，原因还是得益于vue中的mvvm的双向绑定



## Redux和vuex的区别和共同思想

区别：vuex弱化了dispatch，通过commit进行store的状态变更，不用传入action形式进行指定变更；弱化了reducer，基于commit参数直接对数据进行转变

共同思想：都是单一数据源，都是基于mvvm思想，将视图和数据分离，形式上vuex借鉴了redux，将store作为全局的数据中心，进行mode管理



## Vuex和单纯全局对象有什么区别

vuex状态存储是响应式的，当vue组件从store读取状态，若store中状态改变，相应的组件得到更新

不能直接改变store的状态，改变store唯一途径是提交mutation，可以方便跟踪每一个状态的变化



## 为什么Vuex的mutation不能做异步操作

因为vuex所有状态更新唯一途径都是mutation，异步操作通过action提交mutation实现，方便跟踪每一个状态的变化，如果mutation支持异步，就没有办法知道状态是何时更新的，给调试带来困难



# Vue3.0

## vue3.0相对于vue2.x有什么更新

1. 监测机制的改动：基于proxy的observer的实现，消除了Vue2.x的Object.defineProperty 的实现所存在的很多限制
2. 只监测属性，不监测对象

1. 1. 监测属性的添加和删除
   2. 监测数组的索引和长度的变更

1. 1. 支持map set weakmap weakset

1. 模板

1. 1. 3.0版本将作用域插槽改成函数的形式，这样只会影响子组件的重新渲染，提升性能

1. 对象式组件声明方式

1. 1. vue2.x通过声明形式传入option，和ts的结合需要通过装饰器，3.0改成类式的写法，和ts更方便结合

1. 其他

1. 1. 支持自定义渲染
   2. 支持fragment(多根节点)和portal组件

1. 1. 基于tree shaking

## proxy和defineProperty区别

Vue2.x在实例初始化的时候遍历data对象中所有的属性，利用Object.defineProperty将这些属性转换成getter/setter，当数据发生变化自动触发setter

defineProperty是es5无法使用polyfill的特性，所以不支持ie8以下

但是defineProperty缺点

- 无法监测添加和删除对象的属性，因为没有初始化的时候添加getter/setter，只能通过$set进行处理
- 无法监测到数组下标和长度的变化



采用proxy来监测数据的变化，proxy是es6的功能，有以下优点

1. proxy可以直接代理整个对象而非对象属性，只需做一层代理就可以监听同级一下所有属性的变化，包括新增属性和删除属性
2. proxy可以监听数组的变化

## proxy在vue中的工作原理

- get依赖收集
- set delete触发依赖

- 对于集合类型，就是在集合对象做一层包装：原方法执行后执行依赖相关的收集或者触发逻辑



# Virtual DOM

## 对虚拟DOM的理解

从本质来说，虚拟dom就是一个js对象，通过对象的形式来表示dom结构，将页面的装填抽象成js对象，配合不同渲染工具可以更容易的跨平台，通过事物处理机制，将多次修改dom一次性更新到页面中，防止页面渲染多次，减少修改dom的重绘和重排，提高性能

设计虚拟dom就是为了更好的跨平台，比如nodejs就没有dom，想要达成ssr，就得借助虚拟dom，在代码渲染到页面之前，vue会将代码转化为虚拟dom，以对象的形式描述真实dom，每次变化之前，虚拟dom会缓存一份，和变化后的进行diff比较，重新渲染改变了的dom节点



## 虚拟dom的解析过程

- 对要插入的文档的dom树进行分析，使用js对象表示出来(包含tagName，props，children等)，然后保存起来，最后将dom片段插入文档
- 当页面状态发生改变，需要对dom结构进行调整，根据变更的状态，重新构建一颗对象树，将新旧树进行对比，记录差异

- 最后将有差异的地方应用到真实dom树上，就更新视图了



## 为什么要使用虚拟dom

保证性能的下限，提供过的去的性能，页面的渲染流程包括：解析HTML -> 生成dom -> 生成cssdom -> layout -> paint -> compile

重排重绘性能消耗

- 真实DOM：生成html字符串 -> 重建所有DOM元素
- 虚拟DOM：生成vNode -> DOMdiff -> 必要的DOM更新



## 虚拟DOM会比真实DOM性能好吗

在首次渲染大量dom的时候由于多了一层虚拟dom的计算，会比innerHTML慢一些

但是他保证了性能的下限，在真实dom操作的时候进行针对性的优化(diff比较)，还是更快的



## diff算法的原理

在新老节点的dom对比时：

- 首先对比节点本身，判断是不是同一个节点

- - 如果不是就删除该节点重新创建节点来替换

- 如果是的话，进行patchVnode，判断如何对该节点的子节点进行处理，首先判断一方有子节点一方没有的情况

- - 如果新的children没有子节点，就把旧的子节点去掉

- 如果都有子节点，进行updateChildren,判断如何对这些新老子节点进行操作
- 匹配时找到相同子节点，递归比较子节点

在diff中，只对同层的子节点进行比较，放弃跨级的比较，时间复杂度从O(n^3)  -> O(n)，也就是说当新旧children都为多个子节点才要核心的diff算法进行同层级比较



## Vue中key的作用

- 在v-if中使用key，由于Vue会高效渲染元素，通常会复原已有元素而不是从头渲染，如果有相同类型的元素，那么元素就会复用，如果是相同的input元素也会复用，这样可能会出现input输入一开始就有值的情况，我们通过key来表示独立的元素
- v-for使用key v-for更新已渲染过的元素列表，默认使用就地复用的策略，如果数据项顺序发生改变,vue不会移动dom来匹配顺序，而是简单复用，提供key来跟踪元素的身份高效更新虚拟DOM

我们不使用index作为key是因为，无论数组怎么颠倒顺序，index都是0,1,2,3,4这样排列，导致Vue会复用错误的旧节点
