---
title: 动态规划
date: 2022-02-06 22:25:24
permalink: /pages/008f9d/
---

# 动态规划

## lc91. 解码方法<Badge text="中等" vertical="top"/>

:::tip 题目描述

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 :::

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```

**示例 4：**

```
输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```

> 思路：动态规划

设`dp[i]`为`[0, i)`区间的解码方法总数；

那么，对于`s[i]`:

- 可以自己单独作为一个字符进行解码，此时需保证`s[i] !== '0'`，结果数为`a = dp[i]`（为什么单独作为字符进行解码时等于`dp[i]`是因为要和前面的情况组合，不能只是等于`1`）     （条件不满足则为`0`）
- 可以与前一个字符一同进行解码，此时需保证`+(s[i-1] + s[i]) >= 10 && +(s[i-1] + s[i]) <= 26`，结果数为`b = dp[i-1]`；（条件不满足则为`0`）
- `dp[i+1] = a + b`;
- 因为只用到了`i-1`和i两个`dp`位置，因此可以对空间进行压缩为一个长度为`2`的数组

```js
var numDecodings = function(s) {
  const dp = new Array(2).fill(0)
  dp[1] = 1
  for(let i = 0; i < s.length; i++) {
    let a = (+s[i] !== 0) ? dp[1] : 0
    let b
    if(i === 0) b = 0
    else {
      let temp = +(s[i - 1] + s[i])
      if(temp >= 10 && temp <= 26) b = dp[0]
      else b = 0
    } 
    dp[0] = dp[1]
    dp[1] = a + b
  }
  return dp[1]
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

## lc131. 分割回文串<Badge text="中等" vertical="top"/>

:::tip 题目描述

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

 :::

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

> 思路

标准动态规划

```js
var partition = function(s) {
  var res = [], path = []
  var backTrack = (start) => {
      if (start > s.length) return false
      if (start === s.length) {
          res.push(path.slice())
          return false
      }
      for (let i = start; i < s.length; i ++) {
          if(isValid(s, start, i)) {
              var str = s.substr(start, i - start + 1);
              path.push(str)
              backTrack(i + 1)
              path.pop()
          }
      }
  }
  backTrack(0)
  return res
};
// 双指针判断回文串
var isValid = (str, start, end) => {
  for(let i = start, j = end; i < j; i ++, j--) {
      if (str[i] !== str[j]) return false
  }
  return true
}
```

## lc05. 最长回文子串<Badge text="中等" vertical="top"/>

:::tip 题目描述

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

 :::

示例 1：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```
输入：s = "cbbd"
输出："bb"
```


示例 3：

```
输入：s = "a"
输出："a"
```


示例 4：

```
输入：s = "ac"
输出："a"
```

> 思路

就是以字符串的每一个字符为中心点，然后分别向左和向右进行延伸

```js
var longestPalindrome = function(s) {
  if(!s || !s.length) return ''
  if(s.length === 1) return s
  let res = ''
  const fn = (left, right) => {
    while(left >= 0 && right < s.length && s[left] === s[right]) {
      left--
      right++
    }
    res = right - left - 1 > res.length ? s.slice(left + 1, right) : res
  }
  for(let i = 0; i < s.length - 1; i++) {
    fn(i, i)
    fn(i, i + 1)
  }
  return res
};
```

时间复杂度:`O(n^2)`

空间复杂度`O(1)`

> 思路二

动态规划

首先先要了解回文子串，假如第`i`个数和第`j`个数相等，若想他是回文串，那必须`[i + 1, j - 1]`是回文串，这样就相当于填表，创建一个二维数组只需要填对角线的右上方

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201211257497.png)

- 考虑边界情况 如果数组长度小于等于2 就判断两端是否相等即可

```js
/**
状态dp[i][j]: 以下标i开头j结尾的字串是否是回文串（boolean）
 */
var longestPalindrome = function (s) {
    let res = '';
    let n = s.length;
    let dp = Array.from(Array(n), () => Array(n).fill(false));
  // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]
    for (let i = n - 1; i >= 0; i--) {
      // 上图一样填充对角线的右上方
        for (let j = i; j < n; j++) {
      // j - i < 2只用判断前后是否相等即可
            dp[i][j] = (s[i] === s[j] && (j - i < 2 || dp[i + 1][j - 1]));
            if (dp[i][j] && j - i + 1 > res.length) {
                res = s.substring(i, j + 1);
            }
        }
    }
    return res;
};
```

时间复杂度:`O(n^2)`

空间复杂度:`O(n^2)`

 

## lc279. 完全平方数<Badge text="中等" vertical="top"/>

:::tip 题目描述

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 :::

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

> 思路

`dp[i]` 表示`i`的完全平方和的最少数量，`dp[i - j * j] + 1`表示减去一个完全平方数`j`的完全平方之后的数量加`1`就等于`dp[i]`，只要在`dp[i], dp[i - j * j] + 1`中寻找一个较少的就是最后`dp[i]`的值

```js
var numSquares = function(n) {
  const dp = new Array(n).fill(0)

  for(let i = 1; i <= n; i++) {
    dp[i] = i

    for(let j = 1; i - j * j >= 0; j++) {
      dp[i] = Math.min(dp[i], dp[i - j * j] + 1)
    }
  }
  return dp[n]
};
```

时间复杂度:`O(n sqrtn)`

空间复杂度:`O(n)`
