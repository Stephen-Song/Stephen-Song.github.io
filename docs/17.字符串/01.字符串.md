---
title: 字符串
date: 2022-01-15 10:33:36
permalink: /pages/8ac126/
---

# 字符串

## lc13. 罗马数字转整数

:::tip 题目描述

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```


例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 `1` 。`12` 写做 `XII` ，即为 `X + II` 。 `27` 写做  `XXVII`, 即为 `XX + V + II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 `4` 不写做 `IIII`，而是 `IV`。数字 `1` 在数字 `5` 的左边，所表示的数等于大数 `5` 减小数 `1` 得到的数值 `4` 。同样地，数字 `9` 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

```
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
```


给定一个罗马数字，将其转换成整数。

:::

示例 1:

```
输入: s = "III"
输出: 3
```


示例 2:

```
输入: s = "IV"
输出: 4
```


示例 3:

```
输入: s = "IX"
输出: 9
```


示例 4:

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```


示例 5:

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

```js
var romanToInt = function(s) {
  const map = new Map()
  map.set('I', 1)
  map.set('V', 5)
  map.set('X', 10)
  map.set('L', 50)
  map.set('C', 100)
  map.set('D', 500)
  map.set('M', 1000)
  let sum = 0
  for(let i = 0; i < s.length; i++) {
    if(s[i] === 'I' && s[i + 1] && (s[i + 1] === 'V' || s[i + 1] === 'X')) {
      sum += (-1 + map.get(s[i + 1]))
      i++
    } else if(s[i] === 'X' && s[i + 1] && (s[i + 1] === 'L' || s[i + 1] === 'C')) {
      sum += (-10 + map.get(s[i + 1]))
      i++
    } else if(s[i] === 'C' && s[i + 1] && (s[i + 1] === 'D' || s[i + 1] === 'M')) {
      sum += (-100 + map.get(s[i + 1]))
      i++
    } else {
      sum += map.get(s[i])
    }
  }
  return sum
};
```

时间复杂度`O(n)`

空间复杂度`O(1)`

## lc14. 求最长公共前缀

:::tip 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

:::

示例：

```
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

> 思路：

1. 要是空数组就返回 ""
2. 要是数组长度为`1`， 就返回数组的第一位
3. 先按长度排序，然后只用对比第一位和最后一位的字符串，比较一下哪一个字符短，循环判断每一位是不是一样， 一样的话继续下一位判断，时间复杂度为`On`

```js
var longestCommonPrefix = function(strs) {
   strs.sort()
  let short = strs[0]
  let long = strs[strs.length - 1]
  let res = ''
  for(let i = 0; i < short.length; i++) {
    if(short[i] === long[i]) res += short[i]
    else return res
  }
  return res
};
```

## lc22. 括号生成

:::tip 题目描述

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

:::

示例 1：

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```


示例 2：

```
输入：n = 1
输出：["()"]
```

> 思路

可以看成🌲的`dfs`

![截屏2022-01-16 下午4.56.04](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201161656681.png)

然后对🌲进行剪枝

剪枝标准

- 右括号数量大于左括号(其中就包括了开头是右括号的情况)
- 左括号数量大于`n`的值

终止条件，字符串长度等于`2 * n`

```js
var generateParenthesis = function(n) {
  const dfs = (path, open, close) => {
    if(close > open || open > n) return false

    if(path.length === 2 * n) {
      res.push(path)
      return res
    }
    dfs(path + '(', open + 1, close)
    dfs(path + ')', open, close + 1)
  }
  const res = []
  dfs('', 0, 0)
  return res 
};
```



# `KMP`算法

## lc28. 实现`strStr()`

:::tip 题目描述

实现 `strStr()` 函数。

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 `0` 开始）。如果不存在，则返回  `-1` 。

 

说明：

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 `0` 。这与 `C 语言`的 `strstr()` 以及 `Java` 的 `indexOf()` 定义相符。

::: 

示例 1：

```
输入：haystack = "hello", needle = "ll"
输出：2
```


示例 2：

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```


示例 3：

```
输入：haystack = "", needle = ""
输出：0
```

> 思路：`KMP`算法

正常的暴力解法是`O(m * n)`,而`KMP`算法是`O(m + n)` 

```
直接举例：
 * haystack：   aabaabaafa
 * needle：     aabaaf

 * 
 * needle：
 *  前缀：不包含末尾的所有字符串
 *  后缀：不包含开头的所有字符串
 * 
 * 前缀：               后缀：
 *   a,                  f,
 *   aa,                 af,
 *   aab,                aaf,  
 *   aaba,               baaf,
 *   aabaa,              abaaf,
 *   aabaaf, ❌          aabaaf, ❌           这一行不是前缀也不是后缀
 * 
 * 最长相等的前后缀：
 *   a          0  只有一个，0
 *   aa         1  前缀：a。后缀：a
 *   aab        0  前缀：a、aa。后缀：b、ab。
 *   aaba       1  前缀：a、aa、aab。后缀：a、ba、aba。
 *   aabaa      2  前缀：a、aa、aab、aaba。后缀：a、aa、baa、abaa。
 *   aabaaf     0  ....
 *  
 *  next = 【 0,1,0,1,2,0 】，next就是needle的前缀表。
 * 
 *  1. next中的值代表着该子串的最长相等前后缀的长度，
 *  2. 因为数组是从0开始的，该值还表示子串最长相等前后缀的下一项的索引
 * 
 *  例如： next[4] = 2， 其对应的子串是aabaa，前缀和后缀相等的只有a、aa，长度为2。 
 *        needle[2] === b 恰好等于下一项的索引。
 * 
```

```js
var strStr = function(haystack, needle) {
    let n = haystack.length
    let m = needle.length
    if(m === 0) return 0

    let next = new Array(m).fill(0)
    for(let i = 1, j = 0; i < m; i++){
      // i：当前子串的后缀末尾
      // j：上一项子串最长相等前后缀的下一项 或者 0 ，并且也是 上一项子串最长相等前后缀的长度
        while(j > 0 && needle[i] !== needle[j]){
          // 如果不同，我们要从未匹配好的地方开始继续匹配。
          // 未匹配好的位置是那里呢？ 👇
          // 我们知道 next 数组的值就代表每一次子串匹配好的长度，
          // 因为数组是从0开始的，所以j - 1就指向了上一个子串未匹配好的位置。
          // 当j === 0时，说明要从头开始重新匹配了
            j = next[j - 1]
        }
        if(needle[i] === needle[j]){
            j++
        }
        next[i] = j
    }

    // 搞懂上面的，下面的也就懂了
    for(let i = 0, j = 0; i < n; i++){
        // 如果当前i 和 j不一致，就回退到上一个相等的位置的下一个看看是否匹配
        // 会不断回退，0为回退到边界，当回退到0意味着要重新从头开始匹配
        while(j > 0 && haystack[i] !== needle[j]){
            j = next[j - 1]
        }
        if( haystack[i] === needle[j]){
            j++
        }
        // 当j 和 m 的长度相等时，就说明存在
        if(j === m){
            return i - m + 1
        }
    }
    return -1
};
```

> 思路二

也可以用截取字符串的长度来解

```js
var strStr = function (haystack, needle) {
  if (needle === "") return 0
  for (var i = 0; i < haystack.length; i++) {
      if (haystack[i] === needle[0]) {
          if (haystack.substring(i, i + needle.length) === needle) return i;
      }
  }
  return -1
};
```

# 双指针

## lc125. 验证回文串

:::tip 题目描述

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

 :::

**示例 1:**

```
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

**示例 2:**

```
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
```

> 思路

正则去掉除了英文以外其他字符，然后双指针前后开始匹配

```js
var isPalindrome = function(s) {
  s = s.replace(/[^\w]|_/g, '').toLowerCase()
  let left = 0, right = s.length - 1
  while(left <= right) {
    if(s[left] === s[right]) {
      left++
      right--
    } else {
      return false
    }
  }
  return true
};
```

## lc344. 反转字符串

:::tip 题目描述

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 `O(1)` 的额外空间解决这一问题。

::: 

**示例 1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

```js
var reverseString = function(s) {
  let left = 0, right = s.length - 1
  while(left <= right) {
    [s[left], s[right]] = [s[right], s[left]]
    left++
    right--
  }
};
```

# 进制转换

## lc171. Excel 表列序号

:::tip 题目描述

给你一个字符串 `columnTitle` ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。

 :::

例如，

```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

 

**示例 1:**

```
输入: columnTitle = "A"
输出: 1
```

**示例 2:**

```
输入: columnTitle = "AB"
输出: 28
```

**示例 3:**

```
输入: columnTitle = "ZY"
输出: 701
```

**示例 4:**

```
输入: columnTitle = "FXSHRXW"
输出: 2147483647
```

> 思路

没什么好说的，参考二进制转十进制

```js
var titleToNumber = function(columnTitle) {
  let res = 0
  for(let i = columnTitle.length - 1; i >=0; i--) {
    res += 26 ** (columnTitle.length - i - 1) * (columnTitle[i].charCodeAt() - 'A'.charCodeAt() + 1)
  }
  return res 
};
```

## lc168. Excel表列名称

:::tip 题目描述

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

 :::

**示例 1：**

```
输入：columnNumber = 1
输出："A"
```

**示例 2：**

```
输入：columnNumber = 28
输出："AB"
```

**示例 3：**

```
输入：columnNumber = 701
输出："ZY"
```

**示例 4：**

```
输入：columnNumber = 2147483647
输出："FXSHRXW"
```

```js
var convertToTitle = function(n) {
  //10进制转26进制,取余法
  let res = "";
  while(n > 0){
      let temp = n % 26;
      n = Math.floor(n / 26);
      if(temp == 0){
          temp = 26;
          n--;
      }
      res = String.fromCharCode(temp + 64) + res;
  }
  return res; 
};
```

# 其他

## lc172. 阶乘后的零

:::tip 题目描述

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

::: 

**示例 1：**

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

**示例 2：**

```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

**示例 3：**

```
输入：n = 0
输出：0
```

> 思路

这道题很简单，有多少个`5`就有多少个`0`，我们发现只有`5`的倍数的阶乘，才会产生`5`, 所以我们需要看看阶层数有多少个`5`

```js
var trailingZeroes = function (n) {
  let r = 0;
  while (n > 1) {
    n = Math.floor(n / 5);
    r += n;
  }
  return r;
};
```

## lc202. 快乐数

:::tip 题目描述

编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

 :::

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```

> 思路一

采用哈希表

```js
var isHappy = function(n) {
  const getNext = (n) => {
    return n.toString().split("").map( i => i**2).reduce((a,b) => a+b)
  }
  const map = new Map()
  while(n !== 1) {
    map.set(n, 1)
    n = getNext(n)
    if(map.has(n)) return false
  }
  return true
};
```
时间复杂度:`O(n)`
空间复杂度:`O(n)`

> 思路二

采用快慢指针

```js
var isHappy = function(n) {
  const getNext = (n) => {
    return n.toString().split("").map( i => i**2).reduce((a,b) => a+b)
  }
  let slow = n, fast = getNext(n)
    while(fast !== slow && fast !== 1){
        fast = getNext(getNext(fast));
        slow = getNext(slow);
    }
    return fast == 1

};
```

时间复杂度:`O(n)`
空间复杂度:`O(1)`
