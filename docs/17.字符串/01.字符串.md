---
title: 字符串
date: 2022-01-15 10:33:36
permalink: /pages/8ac126/
---

# 字符串

## lc13. 罗马数字转整数

:::tip 题目描述

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```


例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 `1` 。`12` 写做 `XII` ，即为 `X + II` 。 `27` 写做  `XXVII`, 即为 `XX + V + II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 `4` 不写做 `IIII`，而是 `IV`。数字 `1` 在数字 `5` 的左边，所表示的数等于大数 `5` 减小数 `1` 得到的数值 `4` 。同样地，数字 `9` 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

```
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
```


给定一个罗马数字，将其转换成整数。

:::

示例 1:

```
输入: s = "III"
输出: 3
```


示例 2:

```
输入: s = "IV"
输出: 4
```


示例 3:

```
输入: s = "IX"
输出: 9
```


示例 4:

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```


示例 5:

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

```js
var romanToInt = function(s) {
  const map = new Map()
  map.set('I', 1)
  map.set('V', 5)
  map.set('X', 10)
  map.set('L', 50)
  map.set('C', 100)
  map.set('D', 500)
  map.set('M', 1000)
  let sum = 0
  for(let i = 0; i < s.length; i++) {
    if(s[i] === 'I' && s[i + 1] && (s[i + 1] === 'V' || s[i + 1] === 'X')) {
      sum += (-1 + map.get(s[i + 1]))
      i++
    } else if(s[i] === 'X' && s[i + 1] && (s[i + 1] === 'L' || s[i + 1] === 'C')) {
      sum += (-10 + map.get(s[i + 1]))
      i++
    } else if(s[i] === 'C' && s[i + 1] && (s[i + 1] === 'D' || s[i + 1] === 'M')) {
      sum += (-100 + map.get(s[i + 1]))
      i++
    } else {
      sum += map.get(s[i])
    }
  }
  return sum
};
```

时间复杂度`O(n)`

空间复杂度`O(1)`

## lc14. 求最长公共前缀

:::tip 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

:::

示例：

```
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

> 思路：

1. 要是空数组就返回 ""
2. 要是数组长度为`1`， 就返回数组的第一位
3. 先按长度排序，然后只用对比第一位和最后一位的字符串，比较一下哪一个字符短，循环判断每一位是不是一样， 一样的话继续下一位判断，时间复杂度为`On`

```js
var longestCommonPrefix = function(strs) {
   strs.sort()
  let short = strs[0]
  let long = strs[strs.length - 1]
  let res = ''
  for(let i = 0; i < short.length; i++) {
    if(short[i] === long[i]) res += short[i]
    else return res
  }
  return res
};
```

## lc22. 括号生成

:::tip 题目描述

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

:::

示例 1：

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```


示例 2：

```
输入：n = 1
输出：["()"]
```

> 思路

可以看成🌲的`dfs`

![截屏2022-01-16 下午4.56.04](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201161656681.png)

然后对🌲进行剪枝

剪枝标准

- 右括号数量大于左括号(其中就包括了开头是右括号的情况)
- 左括号数量大于`n`的值

终止条件，字符串长度等于`2 * n`

```js
var generateParenthesis = function(n) {
  const dfs = (path, open, close) => {
    if(close > open || open > n) return false

    if(path.length === 2 * n) {
      res.push(path)
      return res
    }
    dfs(path + '(', open + 1, close)
    dfs(path + ')', open, close + 1)
  }
  const res = []
  dfs('', 0, 0)
  return res 
};
```



# `KMP`算法

## lc28. 实现`strStr()`

:::tip 题目描述

实现 `strStr()` 函数。

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 `0` 开始）。如果不存在，则返回  `-1` 。

 

说明：

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 `0` 。这与 `C 语言`的 `strstr()` 以及 `Java` 的 `indexOf()` 定义相符。

::: 

示例 1：

```
输入：haystack = "hello", needle = "ll"
输出：2
```


示例 2：

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```


示例 3：

```
输入：haystack = "", needle = ""
输出：0
```

> 思路：`KMP`算法

正常的暴力解法是`O(m * n)`,而`KMP`算法是`O(m + n)` 

```
直接举例：
 * haystack：   aabaabaafa
 * needle：     aabaaf

 * 
 * needle：
 *  前缀：不包含末尾的所有字符串
 *  后缀：不包含开头的所有字符串
 * 
 * 前缀：               后缀：
 *   a,                  f,
 *   aa,                 af,
 *   aab,                aaf,  
 *   aaba,               baaf,
 *   aabaa,              abaaf,
 *   aabaaf, ❌          aabaaf, ❌           这一行不是前缀也不是后缀
 * 
 * 最长相等的前后缀：
 *   a          0  只有一个，0
 *   aa         1  前缀：a。后缀：a
 *   aab        0  前缀：a、aa。后缀：b、ab。
 *   aaba       1  前缀：a、aa、aab。后缀：a、ba、aba。
 *   aabaa      2  前缀：a、aa、aab、aaba。后缀：a、aa、baa、abaa。
 *   aabaaf     0  ....
 *  
 *  next = 【 0,1,0,1,2,0 】，next就是needle的前缀表。
 * 
 *  1. next中的值代表着该子串的最长相等前后缀的长度，
 *  2. 因为数组是从0开始的，该值还表示子串最长相等前后缀的下一项的索引
 * 
 *  例如： next[4] = 2， 其对应的子串是aabaa，前缀和后缀相等的只有a、aa，长度为2。 
 *        needle[2] === b 恰好等于下一项的索引。
 * 
```

```js
var strStr = function(haystack, needle) {
    let n = haystack.length
    let m = needle.length
    if(m === 0) return 0

    let next = new Array(m).fill(0)
    for(let i = 1, j = 0; i < m; i++){
      // i：当前子串的后缀末尾
      // j：上一项子串最长相等前后缀的下一项 或者 0 ，并且也是 上一项子串最长相等前后缀的长度
        while(j > 0 && needle[i] !== needle[j]){
          // 如果不同，我们要从未匹配好的地方开始继续匹配。
          // 未匹配好的位置是那里呢？ 👇
          // 我们知道 next 数组的值就代表每一次子串匹配好的长度，
          // 因为数组是从0开始的，所以j - 1就指向了上一个子串未匹配好的位置。
          // 当j === 0时，说明要从头开始重新匹配了
            j = next[j - 1]
        }
        if(needle[i] === needle[j]){
            j++
        }
        next[i] = j
    }

    // 搞懂上面的，下面的也就懂了
    for(let i = 0, j = 0; i < n; i++){
        // 如果当前i 和 j不一致，就回退到上一个相等的位置的下一个看看是否匹配
        // 会不断回退，0为回退到边界，当回退到0意味着要重新从头开始匹配
        while(j > 0 && haystack[i] !== needle[j]){
            j = next[j - 1]
        }
        if( haystack[i] === needle[j]){
            j++
        }
        // 当j 和 m 的长度相等时，就说明存在
        if(j === m){
            return i - m + 1
        }
    }
    return -1
};
```

> 思路二

也可以用截取字符串的长度来解

```js
var strStr = function (haystack, needle) {
  if (needle === "") return 0
  for (var i = 0; i < haystack.length; i++) {
      if (haystack[i] === needle[0]) {
          if (haystack.substring(i, i + needle.length) === needle) return i;
      }
  }
  return -1
};
```

# 双指针

## lc125. 验证回文串

:::tip 题目描述

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

 :::

**示例 1:**

```
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

**示例 2:**

```
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
```

> 思路

正则去掉除了英文以外其他字符，然后双指针前后开始匹配

```js
var isPalindrome = function(s) {
  s = s.replace(/[^\w]|_/g, '').toLowerCase()
  let left = 0, right = s.length - 1
  while(left <= right) {
    if(s[left] === s[right]) {
      left++
      right--
    } else {
      return false
    }
  }
  return true
};
```

## lc344. 反转字符串

:::tip 题目描述

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 `O(1)` 的额外空间解决这一问题。

::: 

**示例 1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

```js
var reverseString = function(s) {
  let left = 0, right = s.length - 1
  while(left <= right) {
    [s[left], s[right]] = [s[right], s[left]]
    left++
    right--
  }
};
```

## lc647. 回文子串

:::tip 题目描述

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

::: 

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

> 思路：双指针

双指针顺序相加和逆序相加判断是否相等

```js
var countSubstrings = function(s) {
  let count = ''
  for(let i = 0; i < s.length; i++) {
    let s1 = '', s2 = ''
    for(let j = i; j < s.length; j++) {
      s1 = s1 + s[j]
      s2 = s[j] + s2
      if(s1 === s2) count++
    }
  }
  return count
};
```

时间复杂度:`O(n^2)`

空间复杂度:`O(n)`

> 思路二：中心扩展

枚举所有可能的回文中心 `s[i]` 或 `s[i]、s[i + 1]`

若回文子串长度为奇数则其中心为 `s[i]`

回文子串长度为偶数则其中心为 `s[i]、s[i + 1]`；

以中心向左右两边扩展，即左边界 `l` 减一右边界 `r` 加`1`，如果 `s[l]` 与 `s[r]` 相等则回文数加`1`

```js
var countSubstrings = function(s) {
  let count = 0;
    for (let i = 0; i < s.length; i++) {
        for (let l = i, r = i; l >= 0 && s[l] === s[r]; l--, r++) count++;
        for (let l = i, r = i + 1; l >= 0 && s[l] === s[r]; l--, r++) count++;
    }
    return count;
};
```

时间复杂度:`O(n^2)`

空间复杂度:`O(1)`

# 进制转换

## lc171. Excel 表列序号

:::tip 题目描述

给你一个字符串 `columnTitle` ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。

 :::

例如，

```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

 

**示例 1:**

```
输入: columnTitle = "A"
输出: 1
```

**示例 2:**

```
输入: columnTitle = "AB"
输出: 28
```

**示例 3:**

```
输入: columnTitle = "ZY"
输出: 701
```

**示例 4:**

```
输入: columnTitle = "FXSHRXW"
输出: 2147483647
```

> 思路

没什么好说的，参考二进制转十进制

```js
var titleToNumber = function(columnTitle) {
  let res = 0
  for(let i = columnTitle.length - 1; i >=0; i--) {
    res += 26 ** (columnTitle.length - i - 1) * (columnTitle[i].charCodeAt() - 'A'.charCodeAt() + 1)
  }
  return res 
};
```

## lc168. Excel表列名称

:::tip 题目描述

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

 :::

**示例 1：**

```
输入：columnNumber = 1
输出："A"
```

**示例 2：**

```
输入：columnNumber = 28
输出："AB"
```

**示例 3：**

```
输入：columnNumber = 701
输出："ZY"
```

**示例 4：**

```
输入：columnNumber = 2147483647
输出："FXSHRXW"
```

```js
var convertToTitle = function(n) {
  //10进制转26进制,取余法
  let res = "";
  while(n > 0){
      let temp = n % 26;
      n = Math.floor(n / 26);
      if(temp == 0){
          temp = 26;
          n--;
      }
      res = String.fromCharCode(temp + 64) + res;
  }
  return res; 
};
```

# 动态规划

## lc91. 解码方法

:::tip 题目描述

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 :::

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```

**示例 4：**

```
输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```

> 思路：动态规划

设`dp[i]`为`[0, i)`区间的解码方法总数；

那么，对于`s[i]`:

- 可以自己单独作为一个字符进行解码，此时需保证`s[i] !== '0'`，结果数为`a = dp[i]`（为什么单独作为字符进行解码时等于`dp[i]`是因为要和前面的情况组合，不能只是等于`1`）     （条件不满足则为`0`）
- 可以与前一个字符一同进行解码，此时需保证`+(s[i-1] + s[i]) >= 10 && +(s[i-1] + s[i]) <= 26`，结果数为`b = dp[i-1]`；（条件不满足则为`0`）
- `dp[i+1] = a + b`;
- 因为只用到了`i-1`和i两个`dp`位置，因此可以对空间进行压缩为一个长度为`2`的数组

```js
var numDecodings = function(s) {
  const dp = new Array(2).fill(0)
  dp[1] = 1
  for(let i = 0; i < s.length; i++) {
    let a = (+s[i] !== 0) ? dp[1] : 0
    let b
    if(i === 0) b = 0
    else {
      let temp = +(s[i - 1] + s[i])
      if(temp >= 10 && temp <= 26) b = dp[0]
      else b = 0
    } 
    dp[0] = dp[1]
    dp[1] = a + b
  }
  return dp[1]
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

#### lc131. 分割回文串

:::tip 题目描述

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

 :::

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

> 思路

标准动态规划

```js
var partition = function(s) {
  var res = [], path = []
  var backTrack = (start) => {
      if (start > s.length) return false
      if (start === s.length) {
          res.push(path.slice())
          return false
      }
      for (let i = start; i < s.length; i ++) {
          if(isValid(s, start, i)) {
              var str = s.substr(start, i - start + 1);
              path.push(str)
              backTrack(i + 1)
              path.pop()
          }
      }
  }
  backTrack(0)
  return res
};
// 双指针判断回文串
var isValid = (str, start, end) => {
  for(let i = start, j = end; i < j; i ++, j--) {
      if (str[i] !== str[j]) return false
  }
  return true
}
```



# 其他

## lc172. 阶乘后的零

:::tip 题目描述

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

::: 

**示例 1：**

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

**示例 2：**

```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

**示例 3：**

```
输入：n = 0
输出：0
```

> 思路

这道题很简单，有多少个`5`就有多少个`0`，我们发现只有`5`的倍数的阶乘，才会产生`5`, 所以我们需要看看阶层数有多少个`5`

```js
var trailingZeroes = function (n) {
  let r = 0;
  while (n > 1) {
    n = Math.floor(n / 5);
    r += n;
  }
  return r;
};
```

## lc202. 快乐数

:::tip 题目描述

编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

 :::

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```

> 思路一

采用哈希表

```js
var isHappy = function(n) {
  const getNext = (n) => {
    return n.toString().split("").map( i => i**2).reduce((a,b) => a+b)
  }
  const map = new Map()
  while(n !== 1) {
    map.set(n, 1)
    n = getNext(n)
    if(map.has(n)) return false
  }
  return true
};
```
时间复杂度:`O(n)`
空间复杂度:`O(n)`

> 思路二

采用快慢指针

```js
var isHappy = function(n) {
  const getNext = (n) => {
    return n.toString().split("").map( i => i**2).reduce((a,b) => a+b)
  }
  let slow = n, fast = getNext(n)
    while(fast !== slow && fast !== 1){
        fast = getNext(getNext(fast));
        slow = getNext(slow);
    }
    return fast == 1

};
```

时间复杂度:`O(n)`
空间复杂度:`O(1)`

## lc49. 字母异位词分组

:::tip 题目描述

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

 :::

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

> 思路

异位词的单词组成都一样的

```js
var groupAnagrams = function(strs) {
  const map = new Map()
  const res = []
  for(let i = 0; i < strs.length; i++) {
    const s = strs[i].split('').sort().join('')
    if(!map.has(s)) map.set(s, [strs[i]])
    else map.get(s).push(strs[i])
  }
  for(let [key, val] of map) {
    res.push(val)
  }
  return res
};
```

