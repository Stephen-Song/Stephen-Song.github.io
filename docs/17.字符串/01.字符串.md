---
title: 字符串
date: 2022-01-15 10:33:36
permalink: /pages/8ac126/
---

# 字符串

## lc13:罗马数字转整数

:::tip 题目描述

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```


例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 `1` 。`12` 写做 `XII` ，即为 `X + II` 。 `27` 写做  `XXVII`, 即为 `XX + V + II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 `4` 不写做 `IIII`，而是 `IV`。数字 `1` 在数字 `5` 的左边，所表示的数等于大数 `5` 减小数 `1` 得到的数值 `4` 。同样地，数字 `9` 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

```
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
```


给定一个罗马数字，将其转换成整数。

:::

示例 1:

```
输入: s = "III"
输出: 3
```


示例 2:

```
输入: s = "IV"
输出: 4
```


示例 3:

```
输入: s = "IX"
输出: 9
```


示例 4:

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```


示例 5:

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

```js
var romanToInt = function(s) {
  const map = new Map()
  map.set('I', 1)
  map.set('V', 5)
  map.set('X', 10)
  map.set('L', 50)
  map.set('C', 100)
  map.set('D', 500)
  map.set('M', 1000)
  let sum = 0
  for(let i = 0; i < s.length; i++) {
    if(s[i] === 'I' && s[i + 1] && (s[i + 1] === 'V' || s[i + 1] === 'X')) {
      sum += (-1 + map.get(s[i + 1]))
      i++
    } else if(s[i] === 'X' && s[i + 1] && (s[i + 1] === 'L' || s[i + 1] === 'C')) {
      sum += (-10 + map.get(s[i + 1]))
      i++
    } else if(s[i] === 'C' && s[i + 1] && (s[i + 1] === 'D' || s[i + 1] === 'M')) {
      sum += (-100 + map.get(s[i + 1]))
      i++
    } else {
      sum += map.get(s[i])
    }
  }
  return sum
};
```

时间复杂度`O(n)`

空间复杂度`O(1)`

## lc14:求最长公共前缀

:::tip 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

:::

示例：

```
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

> 思路：

1. 要是空数组就返回 ""
2. 要是数组长度为`1`， 就返回数组的第一位
3. 先按长度排序，然后只用对比第一位和最后一位的字符串，比较一下哪一个字符短，循环判断每一位是不是一样， 一样的话继续下一位判断，时间复杂度为`On`

```js
var longestCommonPrefix = function(strs) {
   strs.sort()
  let short = strs[0]
  let long = strs[strs.length - 1]
  let res = ''
  for(let i = 0; i < short.length; i++) {
    if(short[i] === long[i]) res += short[i]
    else return res
  }
  return res
};
```

## lc22:括号生成

:::tip 题目描述

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

:::

示例 1：

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```


示例 2：

```
输入：n = 1
输出：["()"]
```

> 思路

可以看成🌲的`dfs`

![截屏2022-01-16 下午4.56.04](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201161656681.png)

然后对🌲进行剪枝

剪枝标准

- 右括号数量大于左括号(其中就包括了开头是右括号的情况)
- 左括号数量大于`n`的值

终止条件，字符串长度等于`2 * n`

```js
var generateParenthesis = function(n) {
  const dfs = (path, open, close) => {
    if(close > open || open > n) return false

    if(path.length === 2 * n) {
      res.push(path)
      return res
    }
    dfs(path + '(', open + 1, close)
    dfs(path + ')', open, close + 1)
  }
  const res = []
  dfs('', 0, 0)
  return res 
};
```



# `KMP`算法

## lc28:实现`strStr()`

:::tip 题目描述

实现 `strStr()` 函数。

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 `0` 开始）。如果不存在，则返回  `-1` 。

 

说明：

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 `0` 。这与 `C 语言`的 `strstr()` 以及 `Java` 的 `indexOf()` 定义相符。

::: 

示例 1：

```
输入：haystack = "hello", needle = "ll"
输出：2
```


示例 2：

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```


示例 3：

```
输入：haystack = "", needle = ""
输出：0
```

> 思路：`KMP`算法

正常的暴力解法是`O(m * n)`,而`KMP`算法是`O(m + n)` 

```
直接举例：
 * haystack：   aabaabaafa
 * needle：     aabaaf

 * 
 * needle：
 *  前缀：不包含末尾的所有字符串
 *  后缀：不包含开头的所有字符串
 * 
 * 前缀：               后缀：
 *   a,                  f,
 *   aa,                 af,
 *   aab,                aaf,  
 *   aaba,               baaf,
 *   aabaa,              abaaf,
 *   aabaaf, ❌          aabaaf, ❌           这一行不是前缀也不是后缀
 * 
 * 最长相等的前后缀：
 *   a          0  只有一个，0
 *   aa         1  前缀：a。后缀：a
 *   aab        0  前缀：a、aa。后缀：b、ab。
 *   aaba       1  前缀：a、aa、aab。后缀：a、ba、aba。
 *   aabaa      2  前缀：a、aa、aab、aaba。后缀：a、aa、baa、abaa。
 *   aabaaf     0  ....
 *  
 *  next = 【 0,1,0,1,2,0 】，next就是needle的前缀表。
 * 
 *  1. next中的值代表着该子串的最长相等前后缀的长度，
 *  2. 因为数组是从0开始的，该值还表示子串最长相等前后缀的下一项的索引
 * 
 *  例如： next[4] = 2， 其对应的子串是aabaa，前缀和后缀相等的只有a、aa，长度为2。 
 *        needle[2] === b 恰好等于下一项的索引。
 * 
```

```js
var strStr = function(haystack, needle) {
    let n = haystack.length
    let m = needle.length
    if(m === 0) return 0

    let next = new Array(m).fill(0)
    for(let i = 1, j = 0; i < m; i++){
      // i：当前子串的后缀末尾
      // j：上一项子串最长相等前后缀的下一项 或者 0 ，并且也是 上一项子串最长相等前后缀的长度
        while(j > 0 && needle[i] !== needle[j]){
          // 如果不同，我们要从未匹配好的地方开始继续匹配。
          // 未匹配好的位置是那里呢？ 👇
          // 我们知道 next 数组的值就代表每一次子串匹配好的长度，
          // 因为数组是从0开始的，所以j - 1就指向了上一个子串未匹配好的位置。
          // 当j === 0时，说明要从头开始重新匹配了
            j = next[j - 1]
        }
        if(needle[i] === needle[j]){
            j++
        }
        next[i] = j
    }

    // 搞懂上面的，下面的也就懂了
    for(let i = 0, j = 0; i < n; i++){
        // 如果当前i 和 j不一致，就回退到上一个相等的位置的下一个看看是否匹配
        // 会不断回退，0为回退到边界，当回退到0意味着要重新从头开始匹配
        while(j > 0 && haystack[i] !== needle[j]){
            j = next[j - 1]
        }
        if( haystack[i] === needle[j]){
            j++
        }
        // 当j 和 m 的长度相等时，就说明存在
        if(j === m){
            return i - m + 1
        }
    }
    return -1
};
```

