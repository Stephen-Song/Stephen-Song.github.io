---
title: Promise
date: 2022-01-12 10:06:54
permalink: /pages/40bd18/
---

## 实现一个详细版`Promise`

```js
const micTrigger = cb => Promise.resolve().then(cb)
class MyPromise {
  state = 'pendding'; // 'pendding' | 'fulfilled' | 'rejected'
  value = undefined; // 用于保存 executor 执行成功的返回值
  reason = undefined; // 用于保存 executor 执行措辞的信息
  onResolvedCallbacks = [];
  onRejectedCallbacks = [];
  constructor(executor) {
    try {
      executor(this.resolve.bind(this), this.reject.bind(this))
    } catch (e) {
      this.reject(e)
    }
  }
  resolve(value) {
    if (this.state === 'pendding') {
      this.state = 'fulfilled'
      this.value = value
      for (const onFulfilled of this.onResolvedCallbacks) micTrigger(() => onFulfilled(value))
    }
  }
  reject(reason) {
    if (this.state === 'pendding') {
      this.state = 'rejected'
      this.reason = reason
      for (const onRejected of this.onRejectedCallbacks) micTrigger(() => onRejected(reason))
    }
  }
  handleCallback(callback, resolve, reject, param) {
    try {
      const result = callback(param)
      if (result instanceof MyPromise) result.then(resolve, reject)
      else resolve(result)
    } catch (e) {
      reject(e)
    }
  }
  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') onFulfilled = value => value
    if (typeof onRejected !== 'function')
      onRejected = reason => {
        throw reason
      }
    const promise = new MyPromise((resolve, reject) => {
      if (this.state === 'pendding') {
        this.onResolvedCallbacks.push(this.handleCallback.bind(this, onFulfilled, resolve, reject))
        this.onRejectedCallbacks.push(this.handleCallback.bind(this, onRejected, resolve, reject))
      } else if (this.state === 'fulfilled') {
        micTrigger(() => this.handleCallback(onFulfilled, resolve, reject, this.value))
      } else {
        micTrigger(() => this.handleCallback(onRejected, resolve, reject, this.reason))
      }
    })
    return promise
  }
  catch(onRejected) {
    return this.then(null, onRejected)
  }
  static resolve(value) {
    return new MyPromise(r => r(value))
  }
  static reject(reason) {
    return new MyPromise((_, r) => r(reason))
  }
}
```

## 实现`Promise.resolve`

> 实现 `resolve` 静态方法有三个要点:

- 传参为一个 `Promise`, 则直接返回它。
- 传参为一个 `thenable` 对象，返回的 `Promise` 会跟随这个对象，采用它的最终状态作为自己的状态。
- 其他情况，直接返回以该值为成功状态的`promise`对象。

```js
Promise.resolve = (param) => {
  if(param instanceof Promise) return param;
  return new Promise((resolve, reject) => {
    if(param && param.then && typeof param.then === 'function') {
      // param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然
      param.then(resolve, reject);
    }else {
      resolve(param);
    }
  })
}
```

## 实现`Promise.reject`

> `Promise.reject` 中传入的参数会作为一个 `reason` 原封不动地往下传, 实现如下:

```js
Promise.reject = function (reason) {
    return new Promise((resolve, reject) => {
        reject(reason);
    });
}
```

## 实现 `Promise.prototype.finally`

> 无论当前 `Promise` 是成功还是失败，调用`finally`之后都会执行 `finally` 中传入的函数，并且将值原封不动的往下传。

```js
// 借用 Promise.resolve方法，使得 callback执行完返回后才会继续向下，
// 将 promise对象的原数据继续向下传递，
// 失败数据则需要抛出供后续catch 使用
Promise.prototype.finally = function(callback) {
  this.then(value => {
    return Promise.resolve(callback()).then(() => {
      return value;
    })
  }, error => {
    return Promise.resolve(callback()).then(() => {
      throw error;
    })
  })
}
```

## 实现 `Promise.all`

> 对于 `all` 方法而言，需要完成下面的核心功能:

- 传入参数为一个空的可迭代对象，则直接进行`resolve`。
- 如果参数中有一个`promise`失败，那么`Promise.all`返回的`promise`对象失败。
- 在任何情况下，`Promise.all` 返回的 `promise` 的完成状态的结果都是一个数组

```js
Promise.all = function(promises) {
  return new Promise((resolve, reject) => {
    let result = [];
    let index = 0;
    let len = promises.length;
    if(len === 0) {
      resolve(result);
      return;
    }
   
    for(let i = 0; i < len; i++) {
      // 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise
      Promise.resolve(promise[i]).then(data => {
        result[i] = data;
        index++;
        if(index === len) resolve(result);
      }).catch(err => {
        reject(err);
      })
    }
  })
}
```

###  实现`promise.allsettle()`

> 接受的结果与入参时的`promise`实例一一对应，且结果的每一项都是一个对象，告诉你结果和值，对象内都有一个属性叫“`status`”，用来明确知道对应的这个`promise`实例的状态（`fulfilled`或`rejected`），`fulfilled`时，对象有`value`属性，`rejected`时有`reason`属性，对应两种状态的返回值。

```js
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
```

> 重要的一点是，他不论接受入参的`promise`本身的状态，会返回所有`promise`的结果，但这一点`Promise.all`做不到，如果你需要知道所有入参的异步操作的所有结果，或者需要知道这些异步操作是否全部结束，应该使用`promise.allSettled()`

**实现**

```js
function allSettled(iterable) {
  return new Promise((resolve, reject) => {
    function addElementToResult(i, elem) {
      result[i] = elem;
      elementCount++;
      if (elementCount === result.length) {
        resolve(result);
      }
    }

    let index = 0;
    for (const promise of iterable) {
      // Capture the current value of `index`
      const currentIndex = index;
      promise.then(
        (value) => addElementToResult(
          currentIndex, {
            status: 'fulfilled',
            value
          }),
        (reason) => addElementToResult(
          currentIndex, {
            status: 'rejected',
            reason
          }));
      index++;
    }
    if (index === 0) {
      resolve([]);
      return;
    }
    let elementCount = 0;
    const result = new Array(index);
  });
}
```

### 实现 `Promise.race`

> `race` 的实现相比之下就简单一些，只要有一个 `promise` 执行完，直接 `resolve` 并停止执行

```js
Promise.race = function(promises) {
  return new Promise((resolve, reject) => {
    let len = promises.length;
    if(len === 0) return;
    for(let i = 0; i < len; i++) {
      Promise.resolve(promise[i]).then(data => {
        resolve(data);
        return;
      }).catch(err => {
        reject(err);
        return;
      })
    }
  })
}
```

## 使用`Promise`实现每隔1秒输出1,2,3

```js
const arr = [1, 2, 3];
arr.reduce(
  (p, x) =>
    p.then(() => new Promise((r) => setTimeout(() => r(console.log(x)), 1000))),
  Promise.resolve()
);
```

**改造一下改成一秒后按顺序输出1，2，3**

```js
const arr = [1, 2, 3];
arr.reduce(
  (p, x) =>
    p.then(new Promise((r) => setTimeout(() => r(console.log(x)), 1000))),
  Promise.resolve()
);
// 等价于
Promise.resolve()
  .then(() => {
    return new Promise(r => {
      setTimeout(() => {
        r(console.log(1))
      }, 1000)
    })
  })
  .then(r => {
    return new Promise(r => {
      setTimeout(() => {
        r(console.log(2))
      }, 1000)
    })
  })
  .then(r => {
    return new Promise(r => {
      setTimeout(() => {
        r(console.log(3))
      }, 1000)
    })
  })

```

`p .then`里面的`() => new Promise`改成 `new Promise`

## 循环打印红黄绿

>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？

三个亮灯函数：

```javascript
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
const taskRunner =  async () => {
    await task(3000, 'red')
    await task(2000, 'green')
    await task(2100, 'yellow')
    taskRunner()
}
taskRunner()
```

## 实现mergePromise函数

实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。

```js
const time = (timer) => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve()
    }, timer)
  })
}
const ajax1 = () => time(2000).then(() => {
  console.log(1);
  return 1
})
const ajax2 = () => time(1000).then(() => {
  console.log(2);
  return 2
})
const ajax3 = () => time(1000).then(() => {
  console.log(3);
  return 3
})

function mergePromise () {
  // 在这里写代码
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log("done");
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]

```

这道题有点类似于`Promise.all()`，不过`.all()`不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。

**答案**

```js
function mergePromise (ajaxArray) {
  // 存放每个ajax的结果
  const data = [];
  let promise = Promise.resolve();
  ajaxArray.forEach(ajax => {
  	// 第一次的then为了用来调用ajax
  	// 第二次的then是为了获取ajax的结果
    promise = promise.then(ajax).then(res => {
      data.push(res);
      return data; // 把每次的结果返回
    })
  })
  // 最后得到的promise它的值就是data
  return promise;
}

// async版
const mergePromise = (ajaxArray) => {
  // 在这里实现你的代码
  return new Promise(async function (resolve) {
    let data = [];
    for (let item of ajaxArray) {
      let tmp = await item();
      data.push(tmp);
    }
    resolve(data);
  });
};
```



## 用`promise`实现图片异步加载

```javascript
let imageAsync = (url) => {
  return new Promise((resolve, reject) => {
    let image = new Image();
    image.onload = function () {
      img.src = url;
      resolve(image);
    };
    image.onerror = function (err) {
      reject(err);
    };
  });
};

imageAsync("url")
  .then((img) => {
    console.log("image加载成功");
  })
  .catch((err) => {
    console.log(err);
  });
```

## 封装异步的`fetch`使用`async` `await`方式来使用

```javascript
(async () => {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url);
            const data = await res.json();
            return data;
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
    }
    const httpRequestUtil = new HttpRequestUtil();
    const res = await httpRequestUtil.get('http://golderbrother.cn/');
    console.log(res);
})();
```

