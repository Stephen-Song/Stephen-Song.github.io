---
title: 场景应用
date: 2021-11-28 10:22:49
permalink: /pages/54fba0/
---
# 场景应用

## 实现`add(1)(2)(3)`

```javascript
// 不定参数个数
function add(...args) {
  //求和
  return args.reduce((a, b) => a + b);
}
function curry(fn) {
  let args = [];
  return function temp(...newArgs) {
    if (newArgs.length) {
      args = [...args, ...newArgs];
      return temp;
    } else {
      let val = fn.apply(this, args);
      args = []; //保证再次调用时清空
      return val;
    }
  };
}
let addCurry = curry(add);
console.log(addCurry(1)(2)(3)(4, 5)()); //15
console.log(addCurry(1)(2)(3, 4, 5)()); //15
console.log(addCurry(1)(2, 3, 4, 5)()); //15
// 这个必须要加一个调用的()
// 定参数个数
function add(x, y, z) {
  //求和
  return x + y + z;
}
function curry(fn, args) {
  var length = fn.length;
  var args = args || [];
  return function () {
    newArgs = args.concat(Array.prototype.slice.call(arguments));
    if (newArgs.length < length) {
      return curry.call(this, fn, newArgs);
    } else {
      return fn.apply(this, newArgs);
    }
  };
}

// es6写法
function curry(fn, ...args) {
  // 继续接受参数然后柯里化
  return args.length < fn.length
    ? (...params) => {
        return curry(fn, ...args, ...params);
      }
    : fn(...args);
}

let addCurry = curry(add);
console.log(addCurry(1, 2, 3)); //15
console.log(addCurry(1)(2, 3)); //15
console.log(addCurry(1)(2)(3)); //15
// toString写法
function add(...args) {
	function fn(...fn_args) {
		return add.apply(null, [...args, ...fn_args])
	}
	fn.toString = function() {
		return args.reduce((total, num) => total + num)
	}
	return fn
}
console.log(add(1)) //1
console.log(add(1)(2,3)) //6
console.log(add(1)(2,3)(4,5,6)) //21
```

## 解析`URLparams`为对象

```javascript
function getParams(u) {
  const s = new URLSearchParams(u.search)
  const obj = {}
  s.forEach((v, k) => (obj[k] = v))
  return obj
}

const url = 'http://sample.com/?a=1&b=2&c=xx&d=2#hash';
getParams(new URL(url))
// {a: "1", b: "2", c: "xx", d: "2"}
const dismantle = (url) => {
     const aimUrl = url.split('?').pop().split('#').shift().split('&');
     const res = {};
     aimUrl.forEach(item => {
          const [key, val] = item.split('=');
          res[key] = val;
     });
     return res;
}
dismantle('http://sample.com/?a=1&b=2&c=xx&d=2#hash')
// {a: "1", b: "2", c: "xx", d: "2"}
```

## 循环打印红黄绿

>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？

三个亮灯函数：

```javascript
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
const taskRunner =  async () => {
    await task(3000, 'red')
    await task(2000, 'green')
    await task(2100, 'yellow')
    taskRunner()
}
taskRunner()
```

## 约瑟夫环问题

[约瑟夫环](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```javascript
var lastRemaining = function(n, m) {
    let result = 0;
    for(let i = 2; i <= n; i++) {
        result = (m + result) % i;
    }
    return result
};
```

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/1636036693(1).png)

## 用`promise`实现图片异步加载

```javascript
let imageAsync = (url) => {
  return new Promise((resolve, reject) => {
    let image = new Image();
    image.onload = function () {
      img.src = url;
      resolve(image);
    };
    image.onerror = function (err) {
      reject(err);
    };
  });
};

imageAsync("url")
  .then((img) => {
    console.log("image加载成功");
  })
  .catch((err) => {
    console.log(err);
  });
```

## 实现发布-订阅模式

```javascript
class EventEmitter {
  constructor() {
    this.event = {};
  }
  on(type, callback) {
    if (!this.event[type]) {
      this.event[type] = [callback];
    } else {
      this.event[type].push(callback);
    }
  }
  emit(type) {
    this.event[type].forEach((cb) => cb());
  }
}

function say() {
  console.log("say hello");
}

function sing() {
  console.log("sing hello");
}

function write() {
  console.log("write hello");
}

let emit = new EventEmitter();

emit.on("do", say);
emit.on("write", write);
emit.on("do", sing);

emit.emit("do");
emit.emit("write");
```

- **发布/订阅模式**由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在

## 实现观察者模式

```javascript
class Subject {
  constructor(name = "xiaoSong") {
    this.state = name;
    this.observer = [];
  }
  attach(o) {
    this.observer.push(o);
  }
  setState(newVal) {
    this.state = newVal;
    this.observer.forEach((o) => o.update(this));
  }
}

class Observer {
  constructor(sex = "male") {
    this.sex = sex;
  }
  update(student) {
    console.log(`${this.sex}, ${student.state}`);
  }
}

const student = new Subject();

const parent = new Observer();
const teacher = new Observer("female");

student.attach(parent);
student.attach(teacher);

student.setState("xiaoming");
```

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201092155678.png)

## 根据字符出现频率排序

输入`tree` 输出`eert`或`eetr`

```javascript
var frequencySort = function(s) {
  let map = new Map()
  const res = []
  for(let i of s) {
    if(map.has(i)) {
      map.set(i, map.get(i) + 1)
    } else {
      map.set(i, 1)
    }
  }
  const arr = Array.from(map)
  arr.sort((a, b) => a[1] === b[1] ? b[0] - a[0] : b[1] - a[1])

  for(let i in arr) {
    for(let j = 0; j < arr[i][1]; j++) {
      res.push(arr[i][0])
    }
  }
  // return res
  return res.join('')
};
```

- **观察者模式**是由具体目标调度，比如当事件触发，`Dep` 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的

## 封装异步的`fetch`使用`async` `await`方式来使用

```javascript
(async () => {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url);
            const data = await res.json();
            return data;
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
    }
    const httpRequestUtil = new HttpRequestUtil();
    const res = await httpRequestUtil.get('http://golderbrother.cn/');
    console.log(res);
})();
```

## 实现`prototype`的继承

```javascript
function Sup() {
  this.name = "xiaosong";
}

function Sub() {
  this.sex = "mal";
}

let father = new Sup();
Sub.prototype = father;

let son = new Sub();

console.log(son.name);
console.log(son.sex);
```

## 实现数据的双向绑定

```javascript
let obj = {};
let input = document.querySelector("input");
let span = document.querySelector("span");

Object.defineProperty(obj, "text", {
  enumerable: true,
  writeable: true,
  configurable: true,
  set(newVal) {
    console.log(newVal);
    input.value = newVal;
    span.innerHTML = newVal;
  },
  get() {
    console.log("get");
  },
});

input.addEventListener("keyup", function (e) {
  obj.text = e.target.value;
});
```

## 实现简单路由

```javascript
class Route {
  constructor() {
    // 路由列表
    this.routes = {};
    // 路由hash
    this.currentHash = "";
    this.freshHash = this.freshHash.bind(this);
    window.addEventListener("load", this.freshHash, false);
    window.addEventListener("hashchange", this.freshHash, false);
  }
  storeRoute(path, cb) {
    this.routes[path] = cb || function () {};
  }
  freshHash() {
    this.currentHash = location.hash.slice(1) || "/";
    this.routes[this.currentHash]();
  }
}
```

## 实现无重复字符的最长子串

```javascript
var lengthOfLongestSubstring = function(s) {
  let len = s.length
  let set = new Set()
  let left = 0
  let right = 0
  let sum = 0
  while(left < len) {
    while(right < len && !set.has(s[right])) {
      set.add(s[right])
      right++
    }
    // 处理重复的
    sum = Math.max(sum, right - left)
    set.delete(s[left])
    left++
  }
  return sum
};
```

## 使用`setTimeout`模拟`setInterval`

```javascript
function mySetInterval(fn, timeout) {
  // 控制器，控制定时器是否继续执行
  var timer = {
    flag: true
  };
  // 设置递归函数，模拟定时器执行。
  function interval() {
    if (timer.flag) {
      fn();
      setTimeout(interval, timeout);
    }
  }
  // 启动定时器
  setTimeout(interval, timeout);
  // 返回控制器
  return timer;
}
// 完整版
function setInterval1 (handler,timeout,...args) {
  let isBrowser = typeof window !== 'undefined'
  if(isBrowser && this !== window){
    throw 'TypeError: Illegal invocation'
  }
  let timer = {}
  if(isBrowser){
    // 浏览器上处理
    timer = {
      value:-1,
      valueOf: function (){
        return this.value
      }
    }
    let callback = ()=>{
      handler.apply(this,args)
      timer.value = setTimeout(callback,timeout)
    }
    timer.value = setTimeout(callback,timeout)
  } else {
    // nodejs的处理
    let callback = ()=>{
      handler.apply(this,args)
      Object.assign(timer,setTimeout(callback,timeout))
    }
    Object.assign(timer,setTimeout(callback,timeout))
  }
  return timer
}
```

## 判断对象是否存在循环引用

```javascript
const isCycleObject = (obj,parent) => {
    const parentArr = parent || [obj];
    for(let i in obj) {
        if(typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if(pObj === obj[i]){
                    flag = true;
                }
            })
            if(flag) return true;
            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);
            if(flag) return true;
        }
    }
    return false;
}


const a = 1;
const b = {a};
const c = {b};
const o = {d:{a:3},c}
o.c.b.aa = a;

console.log(isCycleObject(o)
```

