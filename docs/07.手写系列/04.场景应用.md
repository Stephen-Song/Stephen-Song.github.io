---
title: 场景应用
date: 2021-11-28 10:22:49
permalink: /pages/54fba0/
---
# 场景应用

## 实现`add(1)(2)(3)`

```javascript
// 不定参数个数
function add(...args) {
  //求和
  return args.reduce((a, b) => a + b);
}
function curry(fn) {
  let args = [];
  return function temp(...newArgs) {
    if (newArgs.length) {
      args = [...args, ...newArgs];
      return temp;
    } else {
      let val = fn.apply(this, args);
      args = []; //保证再次调用时清空
      return val;
    }
  };
}
let addCurry = curry(add);
console.log(addCurry(1)(2)(3)(4, 5)()); //15
console.log(addCurry(1)(2)(3, 4, 5)()); //15
console.log(addCurry(1)(2, 3, 4, 5)()); //15
// 这个必须要加一个调用的()
// 定参数个数
function add(x, y, z) {
  //求和
  return x + y + z;
}
function curry(fn, args) {
  var length = fn.length;
  var args = args || [];
  return function () {
    newArgs = args.concat(Array.prototype.slice.call(arguments));
    if (newArgs.length < length) {
      return curry.call(this, fn, newArgs);
    } else {
      return fn.apply(this, newArgs);
    }
  };
}

// es6写法
function curry(fn, ...args) {
  // 继续接受参数然后柯里化
  return args.length < fn.length
    ? (...params) => {
        return curry(fn, ...args, ...params);
      }
    : fn(...args);
}

let addCurry = curry(add);
console.log(addCurry(1, 2, 3)); //15
console.log(addCurry(1)(2, 3)); //15
console.log(addCurry(1)(2)(3)); //15
// toString写法
function add(...args) {
	function fn(...fn_args) {
		return add.apply(null, [...args, ...fn_args])
	}
	fn.toString = function() {
		return args.reduce((total, num) => total + num)
	}
	return fn
}
console.log(add(1)) //1
console.log(add(1)(2,3)) //6
console.log(add(1)(2,3)(4,5,6)) //21
```

## 实现十进制转为`36`进制

```js
function getNums36() {
  var nums36 = [];
  for(var i = 0; i < 36 ; i++) {
    if(i >= 0 && i <= 9) {
      nums36.push(i)
    } else {
      nums36.push(String.fromCharCode(i + 55));
    }
  }
  return nums36;
}
function scale36(n) {
  // 单独的功能函数
  // 16进制数： 0-9  A-F    36进制数： 0-9  A-Z 
  const arr = [];
  var nums36 = getNums36();
  // 36 10
  if(!Number.isInteger(n)){//浮点数判断，目前不支持小鼠
    console.warn('不支持小数转换');
    return n;
  } 
  var neg = '';
  if(n < 0){//对负数的处理
      neg = '-';
      n = Math.abs(n)
  }
  while(n) {
    var res = n % 36;
    console.log(res,'+++++++');
    arr.unshift(nums36[res]);
    // 进位
    n = parseInt(n/36);
    console.log(n,'---------');
  }
  arr.unshift(neg)
  return arr.join("");

}

console.log(scale36(20)); // 10
```

## 实现十进制转七进制

```js

function getNums7() {
  var nums7 = [];
  for(var i = 0; i < 7 ; i++) {
      nums7.push(i)
  }
  return nums7;
}
var convertToBase7 = function(num) {
  // 单独的功能函数
  const arr = [];
  var nums7 = getNums7();
  var neg = '';
  if(num < 0){//对负数的处理
      neg = '-';
      num = Math.abs(num)
  }
  if(num == 0) {
      return  num + "";
  }
  
  while(num) {
    var res = num % 7;  // 对高位数据进行截取
    arr.unshift(nums7[res]);  
    // 进位
    num = parseInt(num/7); 
  }
  arr.unshift(neg);
  return arr.join("");
}
```

## 解析`URLparams`为对象

```javascript
function getParams(u) {
  const s = new URLSearchParams(u.search)
  const obj = {}
  s.forEach((v, k) => (obj[k] = v))
  return obj
}

const url = 'http://sample.com/?a=1&b=2&c=xx&d=2#hash';
getParams(new URL(url))
// {a: "1", b: "2", c: "xx", d: "2"}
const dismantle = (url) => {
     const aimUrl = url.split('?').pop().split('#').shift().split('&');
     const res = {};
     aimUrl.forEach(item => {
          const [key, val] = item.split('=');
          res[key] = val;
     });
     return res;
}
dismantle('http://sample.com/?a=1&b=2&c=xx&d=2#hash')
// {a: "1", b: "2", c: "xx", d: "2"}
```

## 约瑟夫环问题

[约瑟夫环](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```javascript
var lastRemaining = function(n, m) {
    let result = 0;
    for(let i = 2; i <= n; i++) {
        result = (m + result) % i;
    }
    return result
};
```

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/1636036693(1).png)

## 实现发布-订阅模式

```javascript
class EventEmitter {
  constructor() {
    this.event = {};
  }
  on(type, callback) {
    if (!this.event[type]) {
      this.event[type] = [callback];
    } else {
      this.event[type].push(callback);
    }
  }
  emit(type) {
    this.event[type].forEach((cb) => cb());
  }
}

function say() {
  console.log("say hello");
}

function sing() {
  console.log("sing hello");
}

function write() {
  console.log("write hello");
}

let emit = new EventEmitter();

emit.on("do", say);
emit.on("write", write);
emit.on("do", sing);

emit.emit("do");
emit.emit("write");
```

- **发布/订阅模式**由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在

## 实现观察者模式

```javascript
class Subject {
  constructor(name = "xiaoSong") {
    this.state = name;
    this.observer = [];
  }
  attach(o) {
    this.observer.push(o);
  }
  setState(newVal) {
    this.state = newVal;
    this.observer.forEach((o) => o.update(this));
  }
}

class Observer {
  constructor(sex = "male") {
    this.sex = sex;
  }
  update(student) {
    console.log(`${this.sex}, ${student.state}`);
  }
}

const student = new Subject();

const parent = new Observer();
const teacher = new Observer("female");

student.attach(parent);
student.attach(teacher);

student.setState("xiaoming");
```

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201092155678.png)

## 根据字符出现频率排序

输入`tree` 输出`eert`或`eetr`

```javascript
var frequencySort = function(s) {
  let map = new Map()
  const res = []
  for(let i of s) {
    if(map.has(i)) {
      map.set(i, map.get(i) + 1)
    } else {
      map.set(i, 1)
    }
  }
  const arr = Array.from(map)
  arr.sort((a, b) => a[1] === b[1] ? b[0] - a[0] : b[1] - a[1])

  for(let i in arr) {
    for(let j = 0; j < arr[i][1]; j++) {
      res.push(arr[i][0])
    }
  }
  // return res
  return res.join('')
};
```

- **观察者模式**是由具体目标调度，比如当事件触发，`Dep` 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的

## 实现`prototype`的继承

```javascript
function Sup() {
  this.name = "xiaosong";
}

function Sub() {
  this.sex = "mal";
}

let father = new Sup();
Sub.prototype = father;

let son = new Sub();

console.log(son.name);
console.log(son.sex);
```

## 实现数据的双向绑定

```javascript
let obj = {};
let input = document.querySelector("input");
let span = document.querySelector("span");

Object.defineProperty(obj, "text", {
  enumerable: true,
  writeable: true,
  configurable: true,
  set(newVal) {
    console.log(newVal);
    input.value = newVal;
    span.innerHTML = newVal;
  },
  get() {
    console.log("get");
  },
});

input.addEventListener("keyup", function (e) {
  obj.text = e.target.value;
});
```

## 实现简单路由

```javascript
class Route {
  constructor() {
    // 路由列表
    this.routes = {};
    // 路由hash
    this.currentHash = "";
    this.freshHash = this.freshHash.bind(this);
    window.addEventListener("load", this.freshHash, false);
    window.addEventListener("hashchange", this.freshHash, false);
  }
  storeRoute(path, cb) {
    this.routes[path] = cb || function () {};
  }
  freshHash() {
    this.currentHash = location.hash.slice(1) || "/";
    this.routes[this.currentHash]();
  }
}
```

## 实现无重复字符的最长子串

```javascript
var lengthOfLongestSubstring = function(s) {
  let len = s.length
  let set = new Set()
  let left = 0
  let right = 0
  let sum = 0
  while(left < len) {
    while(right < len && !set.has(s[right])) {
      set.add(s[right])
      right++
    }
    // 处理重复的
    sum = Math.max(sum, right - left)
    set.delete(s[left])
    left++
  }
  return sum
};
```

## 使用`setTimeout`模拟`setInterval`

```javascript
function mySetInterval(fn, timeout) {
  // 控制器，控制定时器是否继续执行
  var timer = {
    flag: true
  };
  // 设置递归函数，模拟定时器执行。
  function interval() {
    if (timer.flag) {
      fn();
      setTimeout(interval, timeout);
    }
  }
  // 启动定时器
  setTimeout(interval, timeout);
  // 返回控制器
  return timer;
}
// 完整版
function setInterval1 (handler,timeout,...args) {
  let isBrowser = typeof window !== 'undefined'
  if(isBrowser && this !== window){
    throw 'TypeError: Illegal invocation'
  }
  let timer = {}
  if(isBrowser){
    // 浏览器上处理
    timer = {
      value:-1,
      valueOf: function (){
        return this.value
      }
    }
    let callback = ()=>{
      handler.apply(this,args)
      timer.value = setTimeout(callback,timeout)
    }
    timer.value = setTimeout(callback,timeout)
  } else {
    // nodejs的处理
    let callback = ()=>{
      handler.apply(this,args)
      Object.assign(timer,setTimeout(callback,timeout))
    }
    Object.assign(timer,setTimeout(callback,timeout))
  }
  return timer
}
```

## 判断对象是否存在循环引用

```javascript
const isCycleObject = (obj,parent) => {
    const parentArr = parent || [obj];
    for(let i in obj) {
        if(typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if(pObj === obj[i]){
                    flag = true;
                }
            })
            if(flag) return true;
            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);
            if(flag) return true;
        }
    }
    return false;
}


const a = 1;
const b = {a};
const c = {b};
const o = {d:{a:3},c}
o.c.b.aa = a;

console.log(isCycleObject(o)
```

## 如何渲染几万条数据并不卡住界面

> 这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 `DOM`，那么就可以通过 `requestAnimationFrame` 来每 `16 ms` 刷新一次

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <ul>控件</ul>
  <script>
    setTimeout(() => {
      // 插入十万条数据
      const total = 100000
      // 一次插入 20 条，如果觉得性能不好就减少
      const once = 20
      // 渲染数据总共需要几次
      const loopCount = total / once
      let countOfRender = 0
      let ul = document.querySelector("ul");
      function add() {
        // 优化性能，插入不会造成回流
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < once; i++) {
          const li = document.createElement("li");
          li.innerText = Math.floor(Math.random() * total);
          fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        countOfRender += 1;
        loop();
      }
      function loop() {
        if (countOfRender < loopCount) {
          window.requestAnimationFrame(add);
        }
      }
      loop();
    }, 0);
  </script>
</body>
</html>
```

## 希望获取到页面中所有的`checkbox`怎么做？

> 不使用第三方框架

```js
 var domList = document.getElementsByTagName(‘input’)
 var checkBoxList = [];
 var len = domList.length;　　//缓存到局部变量
 while (len--) {　　//使用while的效率会比for循环更高
 　　if (domList[len].type == ‘checkbox’) {
     　　checkBoxList.push(domList[len]);
 　　}
 }
```

## `Javascript`中`callee`和`caller`的作用？

- `caller`是返回一个对函数的引用，该函数调用了当前`函数；
- `callee`是返回正在被执行的`function`函数，也就是所指定的`function`对象的正文

> 那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用`callee`完成）

```js
function fn(n) {
  //典型的斐波那契数列
  if (n == 1) {
    return 1;
  } else if (n == 2) {
    return 1;
  } else {
    //argument.callee()表示fn()
    return arguments.callee(n - 1) + arguments.callee(n - 2);
  }
}
```

## （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生`JS`）

- 给需要拖拽的节点绑定`mousedown`, `mousemove`, `mouseup`事件
- `mousedown`事件触发后，开始拖拽
- `mousemove`时，需要通过`event.clientX`和`clientY`获取拖拽位置，并实时更新位置
- `mouseup`时，拖拽结束
- 需要注意浏览器边界的情况

## 使用`js`实现一个持续的动画效果

**定时器思路**

```js
var e = document.getElementById('e')
var flag = true;
var left = 0;
setInterval(() => {
    left == 0 ? flag = true : left == 100 ? flag = false : ''
    flag ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`
}, 1000 / 60)
```

**`requestAnimationFrame`**

```js
//兼容性处理
window.requestAnimFrame = (function(){
    return window.requestAnimationFrame       ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame    ||
           function(callback){
                window.setTimeout(callback, 1000 / 60);
           };
})();

var e = document.getElementById("e");
var flag = true;
var left = 0;

function render() {
    left == 0 ? flag = true : left == 100 ? flag = false : '';
    flag ? e.style.left = ` ${left++}px` :
        e.style.left = ` ${left--}px`;
}

(function animloop() {
    render();
    requestAnimFrame(animloop);
})();
```

**使用`css`实现一个持续的动画效果**

```css
animation:mymove 5s infinite;

@keyframes mymove {
    from {top:0px;}
    to {top:200px;}
}
```

- `animation-name` 规定需要绑定到选择器的 `keyframe`名称。
- `animation-duration` 规定完成动画所花费的时间，以秒或毫秒计。
- `animation-timing-function` 规定动画的速度曲线。
- `animation-delay` 规定在动画开始之前的延迟。
- `animation-iteration-count` 规定动画应该播放的次数。
- `animation-direction` 规定是否应该轮流反向播放动画

## 封装一个函数，参数是定时器的时间，`.then`执行回调函数

```js
function sleep (time) {
    return new Promise((resolve) => setTimeout(resolve, time));
}
```

## 怎么判断两个对象相等？

```js
obj={
    a:1,
    b:2
}
obj2={
    a:1,
    b:2
}
obj3={
    a:1,
    b:'2'
}
```

> 可以转换为字符串来判断

```js
JSON.stringify(obj)==JSON.stringify(obj2);//true
JSON.stringify(obj)==JSON.stringify(obj3);//false
```

## 实现效果，点击容器内的图标，图标边框变成`border 1px solid red`，点击空白处重置

```js
const box = document.getElementById('box');
function isIcon(target) {
  return target.className.includes('icon');
}

box.onClick = function(e) {
  e.stopPropagation();
  const target = e.target;
  if (isIcon(target)) {
    target.style.border = '1px solid red';
  }
}
const doc = document;
doc.onclick = function(e) {
  const children = box.children;
  for(let i; i < children.length; i++) {
    if (isIcon(children[i])) {
      children[i].style.border = 'none';
    }
  }
}
```

## 请简单实现双向数据绑定`mvvm`

```html
<input id="input"/>
<script>
const data = {};
const input = document.getElementById('input');
Object.defineProperty(data, 'text', {
  set(value) {
    input.value = value;
    this.value = value;
  }
});
input.onChange = function(e) {
  data.text = e.target.value;
}
</script>
```

## 实现`Storage`，使得该对象为单例，并对`localStorage`进行封装设置值`setItem(key,value)`和`getItem(key)`

```js
var instance = null;
class Storage {
  static getInstance() {
    if (!instance) {
      instance = new Storage();
    }
    return instance;
  }
  setItem = (key, value) => localStorage.setItem(key, value),
  getItem = key => localStorage.getItem(key)
}
// 调用
// Storage.getInstance()
// instance.setItem('xx', 'xxx')
// instance.getItem('xx')
```

## 现在要你完成一个`Dialog`组件，说说你设计的思路？它应该有什么功能？

- 该组件需要提供`hook`指定渲染位置，默认渲染在`body`下面。
- 然后改组件可以指定外层样式，如宽度等
- 组件外层还需要一层`mask`来遮住底层内容，点击`mask`可以执行传进来的`onCancel`函数关闭`Dialog`。
- 另外组件是可控的，需要外层传入`visible`表示是否可见。
- 然后`Dialog`可能需要自定义头head和底部`footer`，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的`onOk`事件，然后取消按钮会执行外部传进来的`onCancel`事件。
- 当组件的`visible`为`true`时候，设置`body`的`overflow`为`hidden`，隐藏`body`的滚动条，反之显示滚动条。
- 组件高度可能大于页面高度，组件内部需要滚动条。
- 只有组件的`visible`有变化且为`ture`时候，才重渲染组件内的所有内容
