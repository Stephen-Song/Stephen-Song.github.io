---
title: 单调栈
date: 2021-12-22 15:21:36
permalink: /pages/8b4533/
---
# 单调栈

## lc739. 每日温度<Badge text="中等" /><Badge text="hot" type="error" />

:::tip 题目描述

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指在第 `i` 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 :::

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

> 思路

- 维护一个单调递增栈，栈内存储气温数组 `T` 的 `index`

- 查看当前元素是否大于栈顶元素所对应的 `T` 的值，也就是 `T[stack[stack.length - 1]]`
- 如果大于，那说明找到需要等待的天数。如果不大于那说明还没到找到比这天高的温度。同时继续维护这个单调栈
- 如果大于，需要等待的天数就是当前数组 `T` 的下标减去单调栈顶对应的下标
- 循环完毕，还没有找到需要等待的天数，为`0`

```js
var dailyTemperatures = function(temperatures) {
  const len = temperatures.length
  const res = new Array(len).fill(0)
  const stack = []
  for(let i = 0; i < len; i++) {
    while(stack.length && temperatures[stack[stack.length - 1]] < temperatures[i]) {
      let index = stack.pop()
      res[index] = i - index
    }
    stack.push(i)
  }
  return res
};
```

时间复杂度：`O(n)`，其中 `n` 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。

空间复杂度：`O(n)`，其中 `n` 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。



## lc402. 移除掉`k`位数字<Badge text="中等" />

::: tip 题目描述



给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的`k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

:::

```
示例 1 ：

输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

```
示例 2 ：

输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

```
示例 3 ：

输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。
```

> 思路: 利用单调栈



![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112221523377.png)



```javascript
/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function(num, k) {
    const stack = []
    for(let i = 0; i < num.length; i++) {
        while(k && num[i] < stack[stack.length - 1] && stack.length) {
            stack.pop()
            k--
        }
        stack.push(num[i])
    }

    // 一直进栈导致 k 还没变成 0 栈需要把最后几位出栈，凑齐删除k位  
    while(k--) {
        stack.pop()
    }

    // 去除先导零 
    while(stack.length && stack[0] === '0') {
        stack.shift()
    }
    
    const fi = stack.join('')
    return fi ? fi : '0'
};
```

## lc316. 去除重复字母<Badge text="中等" />

:::tip 题目描述



给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

:::

```
示例 1：

输入：s = "bcabc"
输出："abc"

示例 2：

输入：s = "cbacdcbc"
输出："acdb"
```

> 思路

这道题的关键在于他要求的字典序最小



让我们以 `bcabc`为栗子



-  首先遍历到`b` `c`都是无重复的 入栈 
-  然后开始遍历`a`， 首先`a`是比`b` `c`都小的 

-  其次 如果要以`a`开头的话就得看看`a`后面还有没有`c` 
   -  如果有的话 那么可以放心大胆让栈顶的元素 先出栈(之后有`c`)
   -  如果没有的话栈顶元素不出栈




```javascript
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicateLetters = function(s) {
    const stack = []
    for(let i = 0; i < s.length; i++) {
        if(stack.indexOf(s[i]) > -1) continue

        while(stack.length && stack[stack.length - 1] > s[i] && s.indexOf(stack[stack.length - 1], i) > i) {
            stack.pop()
        }
        stack.push(s[i])
    }
    return stack.join('')
};
```



