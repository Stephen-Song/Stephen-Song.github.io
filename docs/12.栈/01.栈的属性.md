---
title: 栈的属性
date: 2021-12-22 11:49:11
permalink: /pages/5dee6b/
---
## lc20. 求有效的括号 <Badge text="简单" vertical="top"/>

::: tip 题目描述

给定一个只包括` '('，')'，'{'，'}'，'['，']' `的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

:::

示例：

```plain
输入：s = "()"
输出：true

输入：s = "()[]{}"
输出：true

输入：s = "([)]"
输出：false

输入：s = "{[]}"
输出：true
```



思路：

借助了`map`数据结构，同时用了栈的思想，新增一个`stackArr`的数组，通过循环遍历输入字符串判断：



如果输入字符串在`Map`中存在（正括号存在即合理），继续循环



- 如果不存在，再获取缓存中最后一项的值进行配对～配对成功即合理、移除当前缓存
- 继续循环直到遍历完成

- 遍历完成后如果缓存中仍有数据、说明有正括号未匹配结果，则`return false`，反之`return true`



时间复杂度: `O(n)`

空间复杂度: `O(n)`

```javascript
var isValid = function(s) {
    const stackArr = []
    const map = new Map()
    map.set('(', ')')
    map.set('{', '}')
    map.set('[', ']')
    for(let i = 0; i < s.length; i++) {
        if(map.has(s[i])) stackArr.push(s[i])
        else {
            if(stackArr.length === 0) return false
            if (map.get(stackArr[stackArr.length - 1]) === s[i]) stackArr.pop()
            else return false
        }
    }
    if(stackArr.length) return false
    return true
};
```



## lc. 1047删除字符串中的相邻重复项<Badge text="简单" vertical="top"/>





:::tip 题目描述



给出由小写字母组成的字符串`S`，重复项删除操作会选择两个相邻且相同的字母，并删除它们。



在 `S` 上反复执行重复项删除操作，直到无法继续删除。



在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

:::

示例：



```plain
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同
这是此时唯一可以执行删除操作的重复项。
之后我们得到字符串 "aaca"
其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```



思路：

我们都刷了这么多题了，第一反应肯定是用栈弹出的形式来匹配是否相同的

- 那么我们可以维护一个栈数组
- 如果栈顶元素与将要入栈的元素相同的话

- 那么栈顶元素出栈



**<mark>很简单是不是</mark>**



时间复杂度O(n)

空间复杂度O(n)



```javascript
var removeDuplicates = function(s) {
    const stack = []
    // 发现新大陆 ！字符串也可以用for .. of..
    for(c of s) {
        let temp = stack.pop()
        if(c !== temp) {
            stack.push(temp)
            stack.push(c)
        }
    }
    return stack.join('')
};
```

这里奇奇怪怪的，时间复杂度为`O(n)` 但是跑了几次都只击败了`10%`左右的用户，**莫非还有`O(1)`的空间复杂度，暂时没找到，先`mark`一下**



## lc1209. 删除字符串中的相邻重复项<Badge text="中等" vertical="top"/>

::: tip 题目描述：



给你一个字符串 `s`，「`k`倍重复项删除操作」将会从 `s` 中选择 `k` 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。



你需要对 `s` 重复进行无限次这样的删除操作，直到无法继续为止。



在执行完所有删除操作后，返回最终得到的字符串。



本题答案保证唯一。

:::

示例 1：



```plain
输入：s = "abcd", k = 2
输出："abcd"
解释：没有要删除的内容。
```



示例 2：



```plain
输入：s = "deeedbbcccbdaa", k = 3
输出："aa"
解释： 
先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"
再删除 "bbb"，得到 "dddaa"
最后删除 "ddd"，得到 "aa"
```



示例 3：



```plain
输入：s = "pbbcggttciiippooaais", k = 2
输出："ps"
```



> 法一：把进栈的字母相同 改为 合并为同一个元素

- 每次入栈元素和栈顶元素匹配
- 注意栈顶元素可能不只是一个字母 
  - 如果栈顶元素的第一位和入栈元素不相同 
    - 准备入栈的元素执行入栈操作

  - 如果栈顶元素的第一位和入栈元素相同 
    - 判断一下栈顶元素长度是不是等于`k - 1`(因为等于`k - 1`的话加上这个入栈元素就是`k`位，那么就可以出栈了) 
    - 等于栈顶元素就出栈
    - 不等于就把栈顶元素和入栈元素拼接起来 然后重新替换原来的栈顶元素 执行入栈


**时间复杂度`O(n)`**

**空间复杂度`O(n)`**



```javascript
var removeDuplicates = function(s, k) {
    const stack = []
    for(let c of s) {
        const prev = stack.pop()
        if(!prev || c !== prev[0]) {
            stack.push(prev)
            stack.push(c)
        } else if(prev.length < k - 1) {
            stack.push(prev + c)
        }
    }
    return stack.join('')
};
```

> 法二 维护一个计算次数的栈和储存元素的栈



-  执行一遍循环 
-  如果入栈元素和栈顶元素相同 
   -  数字栈的栈顶元素加一
   -  如果累积到`k`了 储存元素的栈执行`k`次出栈

-  如果入栈元素和栈顶元素不同 
   -  那么入栈元素入储存元素的栈 数字栈推入一个为`1`的元素




**时间复杂度`O(n)`**

**空间复杂度`O(n)`**

```javascript
var removeDuplicates = function (s, k) {
    let stack = [] //字母栈
    let countStack = [] //数字栈
    let i = 0
    while(i < s.length){
        if(stack[stack.length - 1] == s[i]){
            stack.push(s[i])
            countStack[countStack.length-1] +=   1
            if(countStack[countStack.length-1] == k){
                for(let j = 0; j < k; j++){ 
                    //字母栈出栈
                    stack.pop()
                }
                countStack.pop() //数字栈出栈
            }
        }else{
            stack.push(s[i])
            countStack.push(1)
        }
        i++
    }
    return stack.join('')
};
```

这里很奇怪的是两种方法都是**时间复杂度`O(n)` 空间复杂度`O(n)`** 但是执行用时却有很大的差别，**有待考究**

## lc150. 逆波兰表达式求值<Badge text="中等" vertical="top"/>

:::tip 题目描述

根据[ 逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437)，求表达式的值。

有效的算符包括 `+`、`-`、`*`、`/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**注意** 两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

::: 

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

```js
var evalRPN = function(tokens) {
  let methods = ['+', '-', '*', '/']
  const stack = []
  for(let item of tokens) {
    if(!methods.includes(item)) stack.push(+item)
    else {
      let num2 = stack.pop()
      let num1 = stack.pop()
      switch(item) {
        case '+':
          stack.push(num1 + num2)
          break
        case '-':
          stack.push(num1 - num2)
          break
        case '*':
          stack.push(num1 * num2)
          break
        case '/':
          stack.push(Math.trunc(num1 / num2))
          break
      }
    }
  }
  return stack[0]
};
```

## lc155. 最小栈<Badge text="简单" vertical="top"/>

:::tip 题目描述

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

 :::

**示例:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

```js
var MinStack = function() {
  this.stack = []
  this.min = +Infinity
  // 辅助栈
  // this.min_stack = [Infinity]
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
  this.stack.push(val)
  this.min = Math.min(this.min, val)
  // 辅助栈
  // this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], val));
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  this.stack.pop()
  this.min = Math.min(...this.stack)
  // 辅助栈
  // this.min_stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1]
}

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.min
  // 辅助栈
  // return this.min_stack[this.min_stack.length - 1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

