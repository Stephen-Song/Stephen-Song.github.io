<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP协议与请求方法 | 小宋爱睡觉</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="🚀一个前端程序员小白的博客🌹">
    <meta name="keywords" content="blog,crucials,frontend,前端,小宋爱睡觉,博客,duochizhacai">
    <meta name="theme-color" content="#60ad81">
    
    <link rel="preload" href="/assets/css/0.styles.65787d8c.css" as="style"><link rel="preload" href="/assets/js/app.95fc12d6.js" as="script"><link rel="preload" href="/assets/js/2.abf57e2f.js" as="script"><link rel="preload" href="/assets/js/22.d9f25771.js" as="script"><link rel="preload" href="/assets/js/3.e687237e.js" as="script"><link rel="prefetch" href="/assets/js/10.9d6bb65c.js"><link rel="prefetch" href="/assets/js/11.bea1ca2d.js"><link rel="prefetch" href="/assets/js/12.a5ced6a2.js"><link rel="prefetch" href="/assets/js/13.ec1bcac6.js"><link rel="prefetch" href="/assets/js/14.4e5bcc62.js"><link rel="prefetch" href="/assets/js/15.753bb2dc.js"><link rel="prefetch" href="/assets/js/16.a6e51bcc.js"><link rel="prefetch" href="/assets/js/17.25227dca.js"><link rel="prefetch" href="/assets/js/18.19267273.js"><link rel="prefetch" href="/assets/js/19.a9403a12.js"><link rel="prefetch" href="/assets/js/20.c007e659.js"><link rel="prefetch" href="/assets/js/21.dca7af69.js"><link rel="prefetch" href="/assets/js/23.2668c7ed.js"><link rel="prefetch" href="/assets/js/24.30c858a4.js"><link rel="prefetch" href="/assets/js/25.bd21abb1.js"><link rel="prefetch" href="/assets/js/26.28d250cb.js"><link rel="prefetch" href="/assets/js/27.a60d212f.js"><link rel="prefetch" href="/assets/js/28.8a5c2c34.js"><link rel="prefetch" href="/assets/js/29.4688a5d6.js"><link rel="prefetch" href="/assets/js/30.5985f3b4.js"><link rel="prefetch" href="/assets/js/31.7ee5d916.js"><link rel="prefetch" href="/assets/js/32.2f711dea.js"><link rel="prefetch" href="/assets/js/33.45a4e58a.js"><link rel="prefetch" href="/assets/js/34.6a46cad8.js"><link rel="prefetch" href="/assets/js/35.79084a19.js"><link rel="prefetch" href="/assets/js/36.9a5cf509.js"><link rel="prefetch" href="/assets/js/37.ea6b36a3.js"><link rel="prefetch" href="/assets/js/38.1ebed809.js"><link rel="prefetch" href="/assets/js/39.16200e67.js"><link rel="prefetch" href="/assets/js/4.4a0efd85.js"><link rel="prefetch" href="/assets/js/40.db1f5064.js"><link rel="prefetch" href="/assets/js/41.5c8205b4.js"><link rel="prefetch" href="/assets/js/42.d8e671a9.js"><link rel="prefetch" href="/assets/js/43.80c6d459.js"><link rel="prefetch" href="/assets/js/44.0dc33dbe.js"><link rel="prefetch" href="/assets/js/45.e623e04e.js"><link rel="prefetch" href="/assets/js/46.b9a46fc2.js"><link rel="prefetch" href="/assets/js/47.2d5eb349.js"><link rel="prefetch" href="/assets/js/48.8d4e8a09.js"><link rel="prefetch" href="/assets/js/49.f7f58461.js"><link rel="prefetch" href="/assets/js/5.84799806.js"><link rel="prefetch" href="/assets/js/50.b482896d.js"><link rel="prefetch" href="/assets/js/51.9ad2b264.js"><link rel="prefetch" href="/assets/js/52.7862671c.js"><link rel="prefetch" href="/assets/js/53.d8153804.js"><link rel="prefetch" href="/assets/js/54.0af2674d.js"><link rel="prefetch" href="/assets/js/55.597b91b8.js"><link rel="prefetch" href="/assets/js/56.46804158.js"><link rel="prefetch" href="/assets/js/57.006f6db0.js"><link rel="prefetch" href="/assets/js/58.751e40d0.js"><link rel="prefetch" href="/assets/js/59.b0ebe0e6.js"><link rel="prefetch" href="/assets/js/6.f7ec0152.js"><link rel="prefetch" href="/assets/js/60.8d675b12.js"><link rel="prefetch" href="/assets/js/61.55190a7f.js"><link rel="prefetch" href="/assets/js/62.117f5f66.js"><link rel="prefetch" href="/assets/js/63.b848bfe2.js"><link rel="prefetch" href="/assets/js/64.000227a3.js"><link rel="prefetch" href="/assets/js/65.9ec404e1.js"><link rel="prefetch" href="/assets/js/66.1834b2b1.js"><link rel="prefetch" href="/assets/js/67.bf716de8.js"><link rel="prefetch" href="/assets/js/68.6e03054c.js"><link rel="prefetch" href="/assets/js/69.c6605c56.js"><link rel="prefetch" href="/assets/js/7.40c08f02.js"><link rel="prefetch" href="/assets/js/70.30051d78.js"><link rel="prefetch" href="/assets/js/71.1fdc7d36.js"><link rel="prefetch" href="/assets/js/72.4b0ad4ad.js"><link rel="prefetch" href="/assets/js/73.e989ab6d.js"><link rel="prefetch" href="/assets/js/74.02429c23.js"><link rel="prefetch" href="/assets/js/75.8f044cef.js"><link rel="prefetch" href="/assets/js/76.7acc2de5.js"><link rel="prefetch" href="/assets/js/77.ce127400.js"><link rel="prefetch" href="/assets/js/78.deb1ae24.js"><link rel="prefetch" href="/assets/js/79.75a4c78b.js"><link rel="prefetch" href="/assets/js/8.303c64d8.js"><link rel="prefetch" href="/assets/js/80.6c258060.js"><link rel="prefetch" href="/assets/js/81.563a0c28.js"><link rel="prefetch" href="/assets/js/82.143b4caf.js"><link rel="prefetch" href="/assets/js/83.32431b7f.js"><link rel="prefetch" href="/assets/js/84.2320a5a5.js"><link rel="prefetch" href="/assets/js/85.d9a1625a.js"><link rel="prefetch" href="/assets/js/86.dc0f47f2.js"><link rel="prefetch" href="/assets/js/87.8335157f.js"><link rel="prefetch" href="/assets/js/88.2cfc7001.js"><link rel="prefetch" href="/assets/js/89.6bc590c2.js"><link rel="prefetch" href="/assets/js/9.7ba1b2de.js"><link rel="prefetch" href="/assets/js/90.c20801a7.js"><link rel="prefetch" href="/assets/js/91.1a32fafc.js"><link rel="prefetch" href="/assets/js/92.4a802465.js">
    <link rel="stylesheet" href="/assets/css/0.styles.65787d8c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/logo.png" alt="小宋爱睡觉" class="logo"> <span class="site-name can-hide">小宋爱睡觉</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><a href="/pages/56881f/" class="link-title">知识库</a> <span class="title" style="display:none;">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/56881f/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/c0e7f0/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/pages/787250/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/f0a671/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/b7238f/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/pages/2448f7/" aria-current="page" class="nav-link router-link-exact-active router-link-active">计算机网络</a></li><li class="dropdown-item"><!----> <a href="/pages/b8bd46/" class="nav-link">浏览器原理</a></li><li class="dropdown-item"><!----> <a href="/pages/f15087/" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/pages/e3cba5/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/pages/ba01c4/" class="nav-link">手写系列</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/pages/ad5191/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8ac126/" class="nav-link">字符串</a></li><li class="dropdown-item"><!----> <a href="/pages/251490/" class="nav-link">数组</a></li><li class="dropdown-item"><!----> <a href="/pages/fc9745/" class="nav-link">链表</a></li><li class="dropdown-item"><!----> <a href="/pages/ad5191/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/pages/6aee18/" class="nav-link">动态规划</a></li><li class="dropdown-item"><!----> <a href="/pages/78e948/" class="nav-link">排序算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><a href="/pages/2448f7/https://github.com/duochizhacai" class="link-title">GitHub</a> <span class="title" style="display:none;">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duochizhacai" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/1249486902410744" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JueJin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><a href="/pages/56881f/" class="link-title">知识库</a> <span class="title" style="display:none;">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/56881f/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/c0e7f0/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/pages/787250/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/f0a671/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/b7238f/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/pages/2448f7/" aria-current="page" class="nav-link router-link-exact-active router-link-active">计算机网络</a></li><li class="dropdown-item"><!----> <a href="/pages/b8bd46/" class="nav-link">浏览器原理</a></li><li class="dropdown-item"><!----> <a href="/pages/f15087/" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/pages/e3cba5/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/pages/ba01c4/" class="nav-link">手写系列</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/pages/ad5191/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8ac126/" class="nav-link">字符串</a></li><li class="dropdown-item"><!----> <a href="/pages/251490/" class="nav-link">数组</a></li><li class="dropdown-item"><!----> <a href="/pages/fc9745/" class="nav-link">链表</a></li><li class="dropdown-item"><!----> <a href="/pages/ad5191/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/pages/6aee18/" class="nav-link">动态规划</a></li><li class="dropdown-item"><!----> <a href="/pages/78e948/" class="nav-link">排序算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><a href="/pages/2448f7/https://github.com/duochizhacai" class="link-title">GitHub</a> <span class="title" style="display:none;">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duochizhacai" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/1249486902410744" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JueJin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/2448f7/" aria-current="page" class="active sidebar-link">HTTP协议与请求方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/2448f7/#常见的http请求方法" class="sidebar-link">常见的HTTP请求方法</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#get和post的区别" class="sidebar-link">get和post的区别</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#post和put的区别" class="sidebar-link">post和put的区别</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#对-accept-系列字段了解多少" class="sidebar-link">对 Accept 系列字段了解多少？</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#常见的content-type有哪些" class="sidebar-link">常见的content-type有哪些</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#对于定长和不定长的数据-http-是怎么传输的" class="sidebar-link">对于定长和不定长的数据，HTTP 是怎么传输的？</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http-如何处理大文件的传输" class="sidebar-link">HTTP 如何处理大文件的传输？</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#介绍一下options请求" class="sidebar-link">介绍一下options请求</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http1-0和http1-1之间有哪些区别" class="sidebar-link">http1.0和http1.1之间有哪些区别</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http1-1和2-0的区别" class="sidebar-link">http1.1和2.0的区别</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#tcp长连接和短连接的区别" class="sidebar-link">TCP长连接和短连接的区别</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http-中的-keep-alive-有了解吗-它和多路复用的区别" class="sidebar-link">HTTP 中的 keep-alive 有了解吗？它和多路复用的区别</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http2的缺点" class="sidebar-link">HTTP2的缺点</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#https与http的区别" class="sidebar-link">https与http的区别</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#get方法对url长度限制的原因" class="sidebar-link">GET方法对URL长度限制的原因</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#对keep-alive的理解" class="sidebar-link">对keep-alive的理解</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#页面有多张图片-http怎么加载" class="sidebar-link">页面有多张图片，http怎么加载</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#如何理解-http-代理" class="sidebar-link">如何理解 HTTP 代理？</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http2头部压缩算法如何实现" class="sidebar-link">http2头部压缩算法如何实现</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#其他相关头部字段" class="sidebar-link">其他相关头部字段</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http的请求报文是什么样的" class="sidebar-link">HTTP的请求报文是什么样的</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http响应报文是什么样的" class="sidebar-link">HTTP响应报文是什么样的</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http的优缺点" class="sidebar-link">http的优缺点</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#rtt-往返时间是什么" class="sidebar-link">RTT 往返时间是什么</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http通信时间总和是多少" class="sidebar-link">http通信时间总和是多少</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#https通信时间总和是多少" class="sidebar-link">HTTPS通信时间总和是多少</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http性能怎么样" class="sidebar-link">http性能怎么样</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#为什么http3不使用tcp而是使用udp" class="sidebar-link">为什么HTTP3不使用TCP而是使用UDP</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#说一下http3-0" class="sidebar-link">说一下http3.0</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#http3怎么解决队头拥塞问题、0rtt有了解过吗" class="sidebar-link">HTTP3怎么解决队头拥塞问题、0RTT有了解过吗</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#这么厉害-那你还知道http3的向前纠错机制吗" class="sidebar-link">这么厉害，那你还知道HTTP3的向前纠错机制吗</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#那你还知道加密认证的报文吗" class="sidebar-link">那你还知道加密认证的报文吗</a></li><li class="sidebar-sub-header"><a href="/pages/2448f7/#quic是如何进行包确认和重传的" class="sidebar-link">QUIC是如何进行包确认和重传的</a></li></ul></li><li><a href="/pages/00c945/" class="sidebar-link">HTTPS协议</a></li><li><a href="/pages/0d5c02/" class="sidebar-link">状态码</a></li><li><a href="/pages/f051f8/" class="sidebar-link">DNS和网络模型</a></li><li><a href="/pages/bb295d/" class="sidebar-link">TCP和UDP</a></li><li><a href="/pages/4d4107/" class="sidebar-link">WebSocket</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><span data-v-1cd794fe>计算机网络</span></li> <!----> <!----></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/duochizhacai" target="_blank" title="作者" class="beLink" data-v-1cd794fe>Crucials</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-11-24</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          HTTP协议与请求方法
        </h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="常见的http请求方法"><a href="#常见的http请求方法" class="header-anchor">#</a> 常见的<code>HTTP</code>请求方法<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <ul><li><p><code>get</code> 向服务器获取数据</p></li> <li><p><code>post</code> 将实体提交给指定的资源，通常造成服务器资源修改</p></li> <li><p><code>put</code>上传文件，更新数据</p></li> <li><p><code>delete</code> 删除服务器上面的对象</p></li> <li><p><code>head</code> 获取报文首部，与<code>get</code>相比不返回报文主体部分</p></li> <li><p><code>options</code>：询问支持的请求方法，用来跨域请求</p></li> <li><p><code>connect</code> 要求在与代理服务器通信时建立隧道，使用隧道进行<code>tcp</code>通信</p></li> <li><p><code>trace</code> 回显服务器收到的请求，主要用于测试或诊断</p></li></ul> <h2 id="get和post的区别"><a href="#get和post的区别" class="header-anchor">#</a> <code>get</code>和<code>post</code>的区别<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <ul><li><p><strong>应用场景不同：</strong> 一般<code>get</code>请求用于服务器资源不会产生影响，比如请求一个网页的资源，但是<code>post</code>会对服务器产生影响，比如注册用户之类的</p></li> <li><p><strong>缓存不同：</strong> 浏览器一般会对<code>get</code>请求缓存，一般不会对<code>post</code>请求缓存</p> <ul><li>可以在<code>url</code>后面拼接时间戳</li></ul></li> <li><p><strong>发送的报文格式不同：</strong> <code>get</code>请求的报文实体为空，<code>post</code>请求的报文实体一般为向服务器发送的数据</p></li> <li><p><strong>幂等：</strong><code>get</code>是幂等的，<code>post</code>不是(<code>幂等</code>表示执行相同的操作，结果也是相同的)</p></li> <li><p><strong>安全性不同</strong>： <code>get</code>将参数放在<code>url</code>的后面，<code>post</code>传递的参数不在<code>query</code>上面</p></li> <li><p><strong>请求长度：</strong> 浏览器对<code>url</code>的长度有限制，会影响<code>get</code>请求发送数据的长度</p></li> <li><p><code>post</code>支持更多的数据类型的数据</p></li> <li><p><strong><code>POST</code>会产生两个<code>TCP</code>数据包</strong>：对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应<code>200</code>（返回数据）；而对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）。也就是<code>post</code>请求，第一次将<code>header</code>发送过去，确认服务器和网络没问题可以服务，才会将真正的<code>data</code>数据提交。 因为<code>POST</code>需要两步，时间上消耗的要多一点</p></li></ul> <h2 id="post和put的区别"><a href="#post和put的区别" class="header-anchor">#</a> <code>post</code>和<code>put</code>的区别</h2> <ul><li><p><code>put</code>向服务端发送数据，但不会增加数据的种类，无论进行多少次<code>put</code>，结果并没有什么不同(理解为更新数据)</p></li> <li><p><code>post</code>向服务端发送请求，会改变数据的种类，可以理解为创建数据</p></li></ul> <h2 id="对-accept-系列字段了解多少"><a href="#对-accept-系列字段了解多少" class="header-anchor">#</a> 对 <code>Accept</code> 系列字段了解多少？</h2> <p>四个部分: <strong>数据格式</strong>、<strong>压缩方式</strong>、<strong>支持语言</strong>和<strong>字符集</strong></p> <p><strong>数据格式</strong></p> <p>客户端支持格式： <strong><code>MIME</code></strong> (<code>Multipurpose Internet Mail Extensions</code>, <strong>多用途互联网邮件扩展</strong>)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 <code>HTTP</code> 来说也是通用的。</p> <p>因此，<code>HTTP</code> 从 <strong><code>MIME type</code></strong> 取了一部分来标记报文 <code>body</code> 部分的数据类型，这些类型体现在<code>Content-Type</code>这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用<code>Accept</code>字段。</p> <p>具体而言，这两个字段的取值可以分为下面几类:</p> <ul><li><code>text： text/html, text/plain, text/css</code> 等</li> <li><code>image: image/gif, image/jpeg, image/png</code> 等</li> <li><code>audio/video: audio/mpeg, video/mp4</code> 等</li> <li><code>application: application/json, application/javascript</code>, <code>application/pdf, application/octet-stream</code></li></ul> <p><strong>压缩方式</strong></p> <p>压缩方式体现在发送方的<code>Content-Encoding</code>字段上， 同样的，接收什么样的压缩方式体现在了接受方的<code>Accept-Encoding</code>字段上。这个字段的取值有下面几种：</p> <ul><li><p><code>gzip</code>: 当今最流行的压缩格式</p></li> <li><p><code>deflate</code>: 另外一种著名的压缩格式</p></li> <li><p><code>br</code>: 一种专门为 <code>HTTP</code> 发明的压缩算法</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 发送端
Content-Encoding: gzip
// 接收端
Accept-Encoding: gzip
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>支持语言</strong></p> <p>对于发送方而言，还有一个<code>Content-Language</code>字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为<code>Accept-Language</code>。如:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 发送端
Content-Language: zh-CN, zh, en
// 接收端
Accept-Language: zh-CN, zh, en
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>字符集</strong></p> <p>最后是一个比较特殊的字段, 在接收端对应为<code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的<code>Content-Charset</code>, 而是直接放在了<code>Content-Type</code>中，以 <strong><code>charset</code></strong> 属性指定。如:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 发送端
Content-Type: text/html; charset=utf-8
// 接收端
Accept-Charset: charset=utf-8
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最后以一张图来总结一下吧:</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202203041123404.awebp" alt="img"></p> <h2 id="常见的content-type有哪些"><a href="#常见的content-type有哪些" class="header-anchor">#</a> 常见的<code>content-type</code>有哪些<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <ol><li><p><code>application/x-www-form-urlencoded</code>按照<code>key=value&amp;key=value</code>进行编码</p></li> <li><p><code>multipart/form-data</code> 通常用表单上传文件</p></li> <li><p><code>application/json</code> 服务器消息主体是序列化的<code>JSON</code>字符串</p></li> <li><p><code>text/xml</code> 主要提交<code>xml</code>格式数据</p></li></ol> <h2 id="对于定长和不定长的数据-http-是怎么传输的"><a href="#对于定长和不定长的数据-http-是怎么传输的" class="header-anchor">#</a> 对于定长和不定长的数据，<code>HTTP</code> 是怎么传输的？</h2> <p><strong>定长包体</strong></p> <p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p> <p>如果设置长度小了，在<code>http</code>响应体中直接被截去，如果设置长度大了，<code>http</code>会导致传输失败，显示意外终止连接</p> <p><strong>不定长包体</strong></p> <p>上述是针对于<code>定长包体</code>，那么对于<code>不定长包体</code>而言是如何传输的呢？</p> <p>这里就必须介绍另外一个 <code>http</code> 头部字段了:</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Transfer-Encoding:</span> chunked
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p> <ul><li><code>Content-Length</code> 字段会被忽略</li> <li>基于长连接持续推送动态内容</li></ul> <p>响应体的结构如下所示:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>chunk长度(16进制的数)
第一个chunk的内容
chunk长度(16进制的数)
第二个chunk的内容
......
0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>最后是留有有一个<code>空行</code>的</p> <h2 id="http-如何处理大文件的传输"><a href="#http-如何处理大文件的传输" class="header-anchor">#</a> <code>HTTP</code> 如何处理大文件的传输？</h2> <p><code>HTTP</code>采取了<code>范围请求</code>的解决方案，允许客户端仅仅请求一个资源的一部分。</p> <p>当然，前提是服务器要支持<strong>范围请求</strong>，要支持这个功能，就必须加上这样一个响应头:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Accept-Ranges: none
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>用来告知客户端这边是支持范围请求的。</p> <p><strong><code>Range</code> 字段拆解</strong></p> <p>而对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 <code>Range</code> 的书写格式:</p> <ul><li><strong><code>0-499</code></strong> 表示从开始到第 <code>499</code> 个字节。</li> <li><strong><code>500-</code></strong>  表示从第 <code>500</code> 字节到文件终点。</li> <li><strong><code>-100</code></strong> 表示文件的最后<code>100</code>个字节。</li></ul> <p>服务器收到请求之后，首先验证范围<strong>是否合法</strong>，如果越界了那么返回<code>416</code>错误码，否则读取相应片段，返回 <strong><code>206</code>状态码。</strong></p> <p>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中<code>Range</code>字段的不同而有所差异。</p> <p>具体来说，请求<code>单段数据</code>和请求<code>多段数据</code>，响应头是不一样的。</p> <p>举个例子:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 单段数据
Range: bytes=0-9
// 多段数据
Range: bytes=0-9, 30-39

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>接下来我们就分别来讨论着两种情况。</p> <p><strong>单段数据</strong></p> <p>对于<code>单段数据</code>的请求，返回的响应如下:</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">206</span> <span class="token reason-phrase string">Partial Content</span></span>
<span class="token header-name keyword">Content-Length:</span> 10
<span class="token header-name keyword">Accept-Ranges:</span> bytes
<span class="token header-name keyword">Content-Range:</span> bytes 0-9/100

i am xxxxx
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>值得注意的是<code>Content-Range</code>字段，<code>0-9</code>表示请求的返回，<code>100</code>表示资源的总大小，很好理解。</p> <p><strong>多段数据</strong></p> <p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">206</span> <span class="token reason-phrase string">Partial Content</span></span>
<span class="token header-name keyword">Content-Type:</span> multipart/byteranges; boundary=00000010101
<span class="token header-name keyword">Content-Length:</span> 189
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">Accept-Ranges:</span> bytes


--00000010101
<span class="token header-name keyword">Content-Type:</span> text/plain
<span class="token header-name keyword">Content-Range:</span> bytes 0-9/96

i am xxxxx
--00000010101
<span class="token header-name keyword">Content-Type:</span> text/plain
<span class="token header-name keyword">Content-Range:</span> bytes 20-29/96

eex jspy e
--00000010101--
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p> <ul><li>请求一定是多段数据请求</li> <li>响应体中的分隔符是 <code>00000010101</code></li></ul> <p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</p> <h2 id="介绍一下options请求"><a href="#介绍一下options请求" class="header-anchor">#</a> 介绍一下<code>options</code>请求<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <p><code>options</code>的用途主要有两个</p> <ul><li>获取服务器支持的所有<code>http</code>请求方法</li> <li>用于检查访问权限，比如在进行<code>cors</code>跨域资源共享的时候，对于复杂请求，就是使用<code>options</code>方法发送嗅探请求，判断是否有权限访问指定的资源</li></ul> <h2 id="http1-0和http1-1之间有哪些区别"><a href="#http1-0和http1-1之间有哪些区别" class="header-anchor">#</a> <code>http1.0</code>和<code>http1.1</code>之间有哪些区别<span class="badge error" style="vertical-align:top;" data-v-d5affa18>非常重要</span></h2> <ul><li><p><strong>连接方面</strong>：<code>http1.0</code>默认支持非持久连接，而<code>http1.1</code>默认支持持久连接，<code>http1.1</code>通过使用持久连接来使多个<code>http</code>请求复用同一个<code>tcp</code>连接，避免使用非持久连接每次需要建立的时延</p></li> <li><p><strong>资源请求方面</strong>：<code>http1.0</code>方面存在浪费带宽(客户端只是需要某个对象的一部分，但是服务器却将整个对象送来了，并且不支持断点续传功能)，<code>http1.1</code>在请求头引入<code>range</code>头域，它允许之请求资源的某个部分，即返回码是<code>206(partial content)</code>，便于开发者自由选择充分利用带宽</p></li> <li><p><strong>缓存方面</strong>：在<code>http1.0</code>主要使用<code>header</code>里的<code>cache-control</code>、<code>expire</code>作为缓存标准判断，<code>http1.1</code>加入了<code>Etag、If-none-match</code> <code>Last-Modified、If-Modified-Since</code>等更多可供选择的缓存头来控制缓存策略</p></li> <li><p><code>http1.1</code>新增 <strong><code>host</code>字段</strong>,用来指定服务器的域名，<code>http1.0</code>认为每台服务器都绑定一个唯一的<code>ip</code>，所以请求<code>url</code>没有传递主机名，但是随着技术发展，在一台物理机器可以存在多台虚拟主机，共享同一个<code>ip</code>地址，这样可以将请求发往同一台服务器的不同网站</p></li> <li><p><strong>1.1新增<code>put、head、options</code>等方法</strong></p></li></ul> <h2 id="http1-1和2-0的区别"><a href="#http1-1和2-0的区别" class="header-anchor">#</a> <code>http1.1</code>和<code>2.0</code>的区别<span class="badge error" style="vertical-align:top;" data-v-d5affa18>非常重要</span></h2> <ul><li><p><strong>二进制编码</strong>：<code>2.0</code>是一个二进制协议，在<code>1.1</code>版本中，报文头信息必须是文本(<code>ASCII编码</code>)，数据可以是文本，也可以是二进制，<code>2.0</code>的头信息和数据体都是<strong>二进制</strong>，统称为<strong>帧</strong>，分为<strong>头信息帧</strong>(存放头部字段)和<strong>数据帧</strong>(存放请求体数据)，都是乱序的二进制帧，不存在先后关系不需要排队。</p> <ul><li>乱序的二进制帧如何组装成对应报文：
<ul><li>所谓的乱序，指的是不同<code>ID</code>的<code>Stream</code>是乱序的，对于同一个<code>Stream ID</code>的帧是按顺序传输的。</li> <li>接收方收到二进制帧后，将相同的<code>Stream ID</code>组装成完整的请求报文和响应报文。</li> <li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。</li></ul></li></ul></li> <li><p><strong>多路复用</strong>：<code>2.0</code>实现多路复用，复用<code>tcp</code>连接，但在一个连接里面客户端和服务端可以同时发送多个请求或响应，而且不用按照顺序一一发送，避免了<strong>队头堵塞</strong>的问题</p></li> <li><p><strong>数据流</strong>：<code>2.0</code>采用了数据流的概念，因为前面的多路复用讲了，不用按顺序，所以同一个连接里面的数据包，可能属于不同的请求，所以要对数据包做标记，指出他属于哪一个请求。<code>2.0</code>将每个请求或回应的所有数据包称为一个数据流，都有一个 <strong>独特的编号<code>Stream ID</code></strong> ，数据包发送时候，都必须标记数据流<code>id</code>，来区分属于哪个数据流</p></li> <li><p><strong>头信息压缩</strong>：因为<code>1.1</code>协议不带状态，每次请求都得附上所有信息，请求很多字段都是重复的，比如<code>cookies</code>和<code>user agent</code>，一模一样的内容每次请求都得带上，浪费带宽和速度，<code>2.0</code>使用<code>gzip</code>或<code>compress</code>压缩再发出，而客户端和服务端同时维护一张头信息表，所有字段都会存入这张表中，生成一个索引号，以后不发送相同字段 只发索引号，可以提速</p></li> <li><p><strong>服务器推送</strong>:<code>2.0</code>允许服务器未经请求主动向客户端发送资源，交服务器推送，提前给客户端推送必要的资源，减少延迟时间，需要注意的是<code>2.0</code>主动推送的是静态资源，跟<code>ws</code>以及使用的<code>sse</code>向客户端发送即时数据的推送是不同的</p></li></ul> <div class="custom-block tip"><p class="custom-block-title">队头堵塞</p> <p>有<code>HTTP</code>基本的“请求 - 应答”模型导致的，<code>http</code>规定报文必须是一发一收，形成了先进先出的串行队列，队列请求没有优先级，只有入队的顺序，最前面的请求最先被处理，如果队首的请求因为处理的太慢了耽误了时间，那么后面的所有请求也得跟着等待，造成了队头阻塞</p></div> <h2 id="tcp长连接和短连接的区别"><a href="#tcp长连接和短连接的区别" class="header-anchor">#</a> <code>TCP</code>长连接和短连接的区别</h2> <p>长连接:在一个<code>TCP</code>连接上可以连续发送多个数据包，在<code>TCP</code>连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。</p> <p>短连接:指通信双方有数据交互时，就建立一个<code>TCP</code>连接，数据发送完成后，则断开此<code>TCP</code>连接，一般银行都使用短连接。</p> <h2 id="http-中的-keep-alive-有了解吗-它和多路复用的区别"><a href="#http-中的-keep-alive-有了解吗-它和多路复用的区别" class="header-anchor">#</a> <code>HTTP</code> 中的 <code>keep-alive</code> 有了解吗？它和多路复用的区别<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <p><code>HTTP/1.x</code> 是基于文本的，只能整体去传；<code>HTTP/2</code> 是基于二进制流的，可以分解为独立的帧，交错发送</p> <p><code>HTTP/1.x keep-alive</code> 必须按照请求发送的顺序返回响应；<code>HTTP/2</code> 多路复用不按序响应</p> <p><code>HTTP/1.x keep-alive</code> 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 <code>TCP</code> 连接；<code>HTTP/2</code> 同域名下所有通信都在单个连接上完成</p> <p><code>HTTP/1.x keep-alive</code> 单个 <code>TCP</code> 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；<code>HTTP/2</code> 单个 <code>TCP</code> 同一时刻可以发送多个请求和响应</p> <h2 id="http2的缺点"><a href="#http2的缺点" class="header-anchor">#</a> <code>HTTP2</code>的缺点<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <ul><li><p><code>TCP</code> 以及 <code>TCP+TLS</code> 建立连接的延时,<code>HTTP/2</code>使用<code>TCP</code>协议来传输的，而如果使用<code>HTTPS</code>的话，还需要使用<code>TLS</code>协议进行安全传输，而使用<code>TLS</code>也需要一个握手过程,在传输数据之前，导致我们需要花掉 <code>3～4</code> 个 <code>RTT</code>。</p></li> <li><p><code>TCP</code>的队头阻塞并没有彻底解决。在<code>HTTP/2</code>中，多个请求是跑在一个<code>TCP</code>管道中的。但当<code>HTTP/2</code>出现丢包时，整个 <code>TCP</code> 都要开始等待重传，那么就会阻塞该<code>TCP</code>连接中的所有请求。</p></li></ul> <h2 id="https与http的区别"><a href="#https与http的区别" class="header-anchor">#</a> <code>https</code>与<code>http</code>的区别<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <ul><li><p><code>https</code>需要<code>ca</code>证书，<code>http</code>不用</p></li> <li><p><code>http</code>是<strong>超文本传输协议</strong>，是明文传输，<code>https</code>是具有安全性的<code>ssl</code>加密传输</p></li> <li><p><code>http</code>端口是<code>80</code> <code>https</code>是<code>443</code></p></li> <li><p><code>http</code>是无状态的协议，<code>https</code>是具有<code>ssl</code>和<code>http</code>协议构建的可加密、身份认证的网络协议，比<code>http</code>安全</p></li></ul> <h2 id="get方法对url长度限制的原因"><a href="#get方法对url长度限制的原因" class="header-anchor">#</a> <code>GET</code>方法对<code>URL</code>长度限制的原因</h2> <p><code>http</code>不对<code>get</code>方法长度进行限制，其实这个限制是浏览器和服务器对<code>url</code>的限制，<code>ie</code>对<code>url</code>长度限制是<code>2083</code>字节<code>(2k+35)</code>，<code>ie</code>限制地最小，所以只要不超过<code>2083</code>就不会有问题</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token constant">GET</span>的长度值 <span class="token operator">=</span> <span class="token constant">URL</span>（<span class="token number">2083</span>）<span class="token operator">-</span> （你的Domain<span class="token operator">+</span>Path）<span class="token operator">-</span><span class="token number">2</span>（<span class="token number">2</span>是<span class="token keyword">get</span>请求中<span class="token operator">?</span><span class="token operator">=</span>两个字符的长度）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="对keep-alive的理解"><a href="#对keep-alive的理解" class="header-anchor">#</a> 对<code>keep-alive</code>的理解</h2> <p><code>http1.0</code>默认每次请求/应答，客户端和服务端都会新建一个连接，完成之后断开连接，这是短连接</p> <p>使用<code>keep-alive</code>使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，可以避免建立或重新连接，这是长连接</p> <p>使用方法：</p> <ul><li><p><code>1.0</code>默认没有<code>keep-alive</code>，需要的话配置发送<code>Connection: keep-alive</code></p></li> <li><p>断开的话发送<code>Connection: close</code></p></li> <li><p><code>1.1</code>版本默认保持长连接，数据传输完成的时候<code>tcp</code>连接不断开，等待同域名下继续使用这个通道传输数据，需要关闭就发送<code>Connection: close</code></p></li></ul> <p><code>Keep-Alive</code>的<strong>建立过程</strong>：</p> <ul><li><p>客户端向服务器在发送请求报文同时在首部添加发送<code>Connection</code>字段</p></li> <li><p>服务器收到请求并处理 <code>Connection</code>字段</p></li> <li><p>服务器回送<code>Connection:Keep-Alive</code>字段给客户端</p></li> <li><p>客户端接收到<code>Connection</code>字段</p></li> <li><p><code>Keep-Alive</code>连接建立成功</p></li></ul> <p><strong>服务端自动断开过程（也就是没有<code>keep-alive</code>）</strong>：</p> <ul><li><p>客户端向服务器只是发送内容报文（不包含<code>Connection</code>字段）</p></li> <li><p>服务器收到请求并处理</p></li> <li><p>服务器返回客户端请求的资源并关闭连接</p></li> <li><p>客户端接收资源，发现没有<code>Connection</code>字段，断开连接</p></li></ul> <p><strong>客户端请求断开连接过程</strong>：</p> <ul><li><p>客户端向服务器发送<code>Connection:close</code>字段</p></li> <li><p>服务器收到请求并处理<code>connection</code>字段</p></li> <li><p>服务器回送响应资源并断开连接</p></li> <li><p>客户端接收资源并断开连接</p></li></ul> <p>开启<code>Keep-Alive</code>的<strong>优点：</strong></p> <ul><li><p>较少的<code>CPU</code>和内存的使⽤（由于同时打开的连接的减少了）；</p></li> <li><p>允许请求和应答的<code>HTTP</code>管线化；</p></li> <li><p>降低拥塞控制 （<code>TCP</code>连接减少了）；</p></li> <li><p>减少了后续请求的延迟（⽆需再进⾏握⼿）；</p></li> <li><p>报告错误⽆需关闭<code>TCP</code>连接</p></li></ul> <p>开启<code>Keep-Alive</code>的<strong>缺点</strong>：</p> <ul><li>长时间的<code>TCP</code>连接容易导致系统资源无效占用，浪费系统资源。</li></ul> <h2 id="页面有多张图片-http怎么加载"><a href="#页面有多张图片-http怎么加载" class="header-anchor">#</a> 页面有多张图片，<code>http</code>怎么加载</h2> <p>在<code>http1</code>，浏览器对一个域名下最大<code>tcp</code>连接数为<code>6</code>，所以会请求多次，可以用多域名部署解决，可以提高同时请求的数目，加快页面图片的获取速度</p> <p>在<code>http2</code>中，支持多路复用，可以在一个<code>tcp</code>连接中发送多个<code>http</code>请求</p> <h2 id="如何理解-http-代理"><a href="#如何理解-http-代理" class="header-anchor">#</a> 如何理解 <code>HTTP</code> 代理？</h2> <p>我们知道在 <code>HTTP</code> 是基于<code>请求-响应</code>模型的协议，一般由客户端发请求，服务器来进行响应。</p> <p>当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有<strong>双重身份</strong>。</p> <p>那代理服务器到底是用来做什么的呢？</p> <p><strong>功能</strong></p> <ol><li><strong>负载均衡</strong>。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，<code>IP</code> 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性<code>hash</code></strong>、<strong><code>LRU</code></strong><code>(最近最少使用)</code>等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li> <li><strong>保障安全</strong>。利用<strong>心跳</strong>机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 <code>IP</code> 限流，这些都是代理服务器的工作。</li> <li><strong>缓存代理</strong>。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。</li></ol> <h2 id="http2头部压缩算法如何实现"><a href="#http2头部压缩算法如何实现" class="header-anchor">#</a> <code>http2</code>头部压缩算法如何实现<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <p><code>http2</code>头部压缩是<code>HPACK</code>算法，在客户端和服务端两端建立“字典”，用索引号表示重复的字符串，采用<strong>哈夫曼编码压缩整数和字符串</strong></p> <ul><li><p>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</p></li> <li><p>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</p></li> <li><p>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</p></li></ul> <p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041547556.webp" alt="img"></p> <h2 id="其他相关头部字段"><a href="#其他相关头部字段" class="header-anchor">#</a> 其他相关头部字段<span class="badge tip" style="vertical-align:top;" data-v-d5affa18>了解</span></h2> <p><strong><code>Via</code></strong></p> <p>代理服务器需要标明自己的身份，在 <code>HTTP</code> 传输中留下自己的痕迹，怎么办呢？</p> <p>通过<code>Via</code>字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在源服务器收到请求后，会在<code>请求头</code>拿到这个字段:</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Via:</span> proxy_server1, proxy_server2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>而源服务器响应时，最终在客户端会拿到这样的<code>响应头</code>:</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Via:</span> proxy_server2, proxy_server1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以看到，<code>Via</code>中代理的顺序即为在 <code>HTTP</code> 传输中报文传达的顺序。</p> <p><strong><code>X-Forwarded-For</code></strong></p> <p>字面意思就是<code>为谁转发</code>, 它记录的是<strong>请求方</strong>的<code>IP</code>地址(注意，和<code>Via</code>区分开，<code>X-Forwarded-For</code>记录的是请求方这一个<code>IP</code>)。</p> <p><strong><code>X-Real-IP</code></strong></p> <p>是一种获取用户真实 <code>IP</code> 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的<code>IP</code>。</p> <p>相应的，还有<code>X-Forwarded-Host</code>和<code>X-Forwarded-Proto</code>，分别记录<strong>客户端</strong>(注意哦，不包括代理)的<code>域名</code>和<code>协议名</code>。</p> <p><strong><code>X-Forwarded-For</code>产生的问题</strong></p> <p>前面可以看到，<code>X-Forwarded-For</code>这个字段记录的是请求方的 <code>IP</code>，这意味着每经过一个不同的代理，这个字段的名字都要变，从<code>客户端</code>到<code>代理1</code>，这个字段是客户端的<code>IP</code>，从<code>代理1</code>到<code>代理2</code>，这个字段就变为了<code>代理1</code>的 <code>IP</code>。</p> <p>但是这会产生两个问题:</p> <ol><li>意味着代理必须解析 <code>HTTP</code> 请求头，然后修改，比直接转发数据性能下降。</li> <li>在 <code>HTTPS</code> 通信加密的过程中，原始报文是不允许修改的。</li></ol> <p>由此产生了<code>代理协议</code>，一般使用明文版本，只需要在 <code>HTTP</code> 请求行上面加上这样格式的文本即可:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
...
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这样就可以解决<code>X-Forwarded-For</code>带来的问题了</p> <h2 id="http的请求报文是什么样的"><a href="#http的请求报文是什么样的" class="header-anchor">#</a> <code>HTTP</code>的请求报文是什么样的</h2> <p>由请求行 请求头部 空行 请求体组成</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041548272.webp" alt="img"></p> <p>请求⾏包括：请求⽅法字段、<code>URL</code>字段、<code>HTTP</code>协议版本字段</p> <p>请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号<code>“:”</code>分隔</p> <ul><li><p><code>User-Agent</code>：产⽣请求的浏览器类型。</p></li> <li><p><code>Accept</code>：客户端可识别的内容类型列表。</p></li> <li><p><code>Host</code>：请求的主机名，允许多个域名同处⼀个<code>IP</code>地址，即虚拟主机。</p></li></ul> <p>请求体:<code>post</code> <code>put</code>等请求携带的数据</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic@main/img/edsfndsjfbwaternark.1uyexsgxywn4.webp" alt="img"></p> <h2 id="http响应报文是什么样的"><a href="#http响应报文是什么样的" class="header-anchor">#</a> <code>HTTP</code>响应报文是什么样的</h2> <p>由响应行 响应头 空行 响应体</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112122147127.webp" alt="img"></p> <h2 id="http的优缺点"><a href="#http的优缺点" class="header-anchor">#</a> <code>http</code>的优缺点<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <p><code>http</code>是超文本传输协议，定义了客户端和服务端交换报文的格式和方式，默认使用<code>80</code>端口，使用<code>tcp</code>协议作为<strong>传输层</strong>协议，保证了数据传输的可靠</p> <p><mark>优点</mark>：</p> <ul><li><p><strong>支持客户端/服务端</strong></p></li> <li><p><strong>简单快捷</strong> 客户向服务器请求时 只需传送请求方法和路径 由于<code>http</code>协议简单 使得<code>http</code>服务器规模小，通信速度快</p></li> <li><p><strong>无连接</strong> 限制每次连接只处理一个请求，服务端处理完客户请求，客户收到应答就断开连接，可以节省传输时间</p></li> <li><p><strong>无状态</strong> 状态指的是通信上下文信息，缺少状态意味着如果后续处理需要前面的信息，就必须重传，导致每次连接传送的数据量增大，另一方面在服务器不需要之前的信息他的应答就比较快</p></li> <li><p><strong>灵活</strong> <code>http</code>允许传输任意类型的数据对象，由<code>content-type</code>标记</p></li></ul> <p><mark>缺点:</mark></p> <ul><li><p><strong>无状态</strong> 服务器不会保存关于客户的任何消息</p></li> <li><p><strong>明文传输</strong> 报文采用文本形式 不安全</p></li> <li><p><strong>不安全</strong> 使用明文 内容易被窃听；不验证通信方身份，可能伪装；无法验证报文完整性，可能被篡改</p></li></ul> <h2 id="rtt-往返时间是什么"><a href="#rtt-往返时间是什么" class="header-anchor">#</a> <code>RTT</code> 往返时间是什么</h2> <p><code>RTT（Round-Trip Time）</code>，往返时间，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间，即通信一来一回的时间</p> <h2 id="http通信时间总和是多少"><a href="#http通信时间总和是多少" class="header-anchor">#</a> <code>http</code>通信时间总和是多少</h2> <p>上一题我们知道了<code>RTT</code>的概念，那么<code>TCP</code>的三次握手🤝理论上来说花的时间应该是<code>1.5RTT</code>，但是客户端第三次握手的时候不需要服务器的响应，所以节省了<code>0.5RTT</code>，所以<code>TCP</code>连接的时间为<code>1RTT</code></p> <p><code>HTTP</code>的交易时间为</p> <ul><li>一去（<code>HTTP Request</code>）</li> <li>二回 （<code>HTTP Responses</code>）</li></ul> <p>故 <code>HTTP</code> 交易时间 = <code>1 RTT</code></p> <p><strong><code>HTTP</code> 通信时间总和</strong> <strong>= <code>TCP</code> 建立连接时间 + <code>HTTP</code> 交易时间 = <code>1 RTT</code>+ <code>1 RTT</code> = <code>2 RTT</code></strong></p> <h2 id="https通信时间总和是多少"><a href="#https通信时间总和是多少" class="header-anchor">#</a> <code>HTTPS</code>通信时间总和是多少</h2> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202111527604.png" alt=""></p> <ul><li><strong>一去：</strong> 客户端发送一个随机数 <code>C</code>，客户端的 <code>TLS</code> 版本号以及支持的密码套件列表给服务器端</li> <li><strong>二回：</strong> 服务端收到客户端的随机值，自己也产生一个随机值 <code>S</code> ，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）</li> <li><strong>三去：</strong> 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值 <code>pre-master</code>，通过服务端证书的公钥去加密这个随机值并发送给服务端。如果服务端需要验证客户端证书的话会附带证书（双向认证，比如网上银行用 <code>U</code> 盾）</li> <li><strong>四回：</strong>  服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值（<code>C/S</code> 加 <code>pre-master</code> 算出主密钥）按照之前约定的加密方式生成密钥，接下来的通信就可以通过该会话密钥来加密解密</li></ul> <p><code>HTTPS</code> 基于<code>TLS1.2</code>通信时间总和 = <code>TCP</code> 建立连接时间 + <code>TLS</code> 连接时间 + <code>HTTP</code>交易时间 = <code>1 RTT</code> + <code>2 RTT</code> + <code>1 RTT</code> = <code>4 RTT</code></p> <p><strong><code>HTTPS</code> 通信时间总和（基于<code>TLS1.3</code>） = <code>TCP</code> 建立连接时间 + <code>TLS1.3</code> 连接时间 + <code>HTTP</code>交易时间 = <code>1 RTT</code> + <code>1 RTT</code> + <code>1 RTT</code> = <code>3 RTT</code></strong></p> <h2 id="http性能怎么样"><a href="#http性能怎么样" class="header-anchor">#</a> <code>http</code>性能怎么样</h2> <p>基于<code>tcp/ip</code>，使用<strong>请求</strong>和<strong>应答</strong>通信模式，所以性能来说这俩是关键</p> <ul><li><p>长连接 可以避免每次<code>tcp</code>连接三次握手花费</p></li> <li><p><code>http1.1</code> 管道网络传输，就是一个<code>tcp</code>连接里面客户端可以发送多个请求</p></li> <li><p>队头拥塞 <code>http</code>传输是一发一收 ，里面的任务放在一个任务队列中串行执行 一旦队首请求的太慢会阻塞后面请求的处理</p> <p>解决方法：</p> <ul><li><strong>并发连接</strong> 对于一个域名允许分配多个长连接，相当于增加了任务队列</li> <li><strong>域名分片</strong> 将域名分出很多个二级域名，全都指向同样的一台服务器 能够并发的长连接数变多</li></ul></li></ul> <h2 id="为什么http3不使用tcp而是使用udp"><a href="#为什么http3不使用tcp而是使用udp" class="header-anchor">#</a> 为什么<code>HTTP3</code>不使用<code>TCP</code>而是使用<code>UDP</code></h2> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202111540417.png" alt=""></p> <h2 id="说一下http3-0"><a href="#说一下http3-0" class="header-anchor">#</a> 说一下<code>http3.0</code></h2> <p>基于<code>UDP</code>协议实现的类似于<code>tcp</code>多路复用的数据流，传输可靠性，称为<code>QUIC</code>协议</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041614890.webp" alt="img"></p> <ol><li><p><strong>流量控制、传输可靠性</strong>：<code>QUIC</code>在<code>udp</code>基础上增加一层保证数据传输可靠性，提供了数据包重传 拥塞控制等</p></li> <li><p><strong>集成TLS加密功能</strong>，减少花费的<code>RTT</code>数</p></li> <li><p><strong>多路复用</strong> 同一个物理连接上可以有多个独立的逻辑数据流，实现数据流单独传输，解决<code>tcp</code>队头阻塞问题</p></li> <li><p><strong>快速握手</strong> 基于<code>udp</code>，可以实现<code>0-1</code>个<code>rtt</code>来建立连接</p></li></ol> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041614234.webp" alt="img"></p> <h2 id="http3怎么解决队头拥塞问题、0rtt有了解过吗"><a href="#http3怎么解决队头拥塞问题、0rtt有了解过吗" class="header-anchor">#</a> <code>HTTP3</code>怎么解决队头拥塞问题、<code>0RTT</code>有了解过吗</h2> <p><code>QUIC</code> 协议是基于 <code>UDP</code> 协议实现的，在传输层层面并没有固定的连接，可以根据需要开辟任意逻辑链路, <code>QUIC</code>一次建立一个<code>Connection</code>，一个<code>Connection</code>下包含多个<code>Stream</code>流(每个<code>stream</code>独自维护一个逻辑连接，因为<code>UDP</code>层面上是无连接的),每个流对应一个文件传输，并将不同的<code>Stream</code>中的数据交付给不同的上层应用。<code>QUIC</code>的一个<code>Connection</code>对应多个<code>Stream</code>，<code>Stream</code>之间相互独立，因此任意一条链路断开都不会导致其他数据阻塞。</p> <p>例如下图，<code>stream2</code> 丢了一个 <code>UDP</code> 包，不会影响后面跟着 <code>Stream3</code> 和 <code>Stream4</code>。这样的技术就解决了之前 <code>TCP</code> 存在的队头阻塞问题。</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202111541825" alt="图片"></p> <p>并且 <code>QUIC</code> 在移动端的表现也会比 <code>TCP</code> 好。因为 <code>TCP</code> 是基于 <code>IP</code> 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。</p> <p>但是 <code>QUIC</code> 是通过 <code>ID</code> 的方式去识别一个连接，不管你网络环境如何变化，只要 <code>ID</code> 不变，就能迅速重连上。</p> <p><strong><code>0RTT</code></strong></p> <p>通过使用类似 <code>TCP</code> 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p> <p><strong><code>0RTT</code> 建连可以说是 <code>QUIC</code> 相比 <code>HTTP2</code> 最大的性能优势</strong>。那什么是 <code>0RTT</code> 建连呢？</p> <p>这里面有两层含义:</p> <ul><li>传输层 <code>0RTT</code> 就能建立连接。</li> <li>加密层 <code>0RTT</code> 就能建立加密连接。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202111545863.gif" alt="图片"></p> <p>上图左边是 <code>HTTPS</code> 的一次完全握手的建连过程，需要 <code>2-3</code> 个 <code>RTT</code>才开始传输数据，右边 <code>QUIC</code> 协议在第一个包就可以包含有效的应用数据</p> <p>当然，<code>QUIC</code> 协议可以实现 <code>0RTT</code> ，但这也是有条件的，实际上是首次连接 <code>1RTT</code>，非首次连接 <code>0RTT</code>，首次连接过程：</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202111545543" alt="图片"></p> <p>可以看到，首次连接的时候，在第 <code>4</code> 步时，就已经开始发送实际的业务数据了，而第 <code>1 - 3</code> 步正好一去一回花费了 <code>1RTT</code> 时间，所以，首次连接的成本是 <code>1RTT</code></p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202111547664" alt="图片"></p> <p>非首次连接：</p> <ul><li>前面提到客户端和服务端首次连接时服务端传递了<code>config</code>包，里面包含了服务端公钥和两个随机数，客户端会将<code>config</code>存储下来，后续再连接时可以直接使用，从而跳过这个<code>1RTT</code>，实现<code>0RTT</code>的业务数据交互。</li> <li>客户端保存<code>config</code>是有时间期限的，在<code>config</code>失效之后仍然需要进行首次连接时的密钥交换。</li></ul> <h2 id="这么厉害-那你还知道http3的向前纠错机制吗"><a href="#这么厉害-那你还知道http3的向前纠错机制吗" class="header-anchor">#</a> 这么厉害，那你还知道<code>HTTP3</code>的向前纠错机制吗</h2> <p><code>QUIC</code> 协议有一个非常独特的特性，称为向前纠错 (<code>Forward Error Correction</code>，<code>FEC</code>)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包<strong>可以通过其他包的冗余数据直接组装</strong>而无需重传。</p> <p>向前纠错<strong>牺牲了每个数据包可以发送数据的上限</strong>，但是<strong>减少了因为丢包导致的数据重传</strong>，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。</p> <p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</p> <p>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</p> <p>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p> <h2 id="那你还知道加密认证的报文吗"><a href="#那你还知道加密认证的报文吗" class="header-anchor">#</a> 那你还知道加密认证的报文吗</h2> <p><code>TCP</code> 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p> <p>但是 <code>QUIC</code> 的 <code>packet</code> 可以说是武装到了牙齿。除了个别报文比如 <code>PUBLIC_RESET</code> 和 <code>CHLO</code>，所有报文头部都是经过认证的，报文 <code>Body</code> 都是经过加密的。</p> <p>这样只要对 <code>QUIC</code> 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202111552256" alt="图片"></p> <p>如上图所示，红色部分是 <code>Stream Frame</code> 的报文头部，有认证。绿色部分是报文内容，全部经过加密</p> <h2 id="quic是如何进行包确认和重传的"><a href="#quic是如何进行包确认和重传的" class="header-anchor">#</a> <code>QUIC</code>是如何进行包确认和重传的</h2> <ul><li><code>QUIC</code> 的<code>Stream</code>流基于<code>Stream ID+Offset</code>进行包确认，流量控制需要保证所发送的所有包<code>offset</code>小于<strong>最大绝对字节偏移量</strong>（<strong><code>maximum absolute byte offset</code></strong>）, 该值是基于当前已经<strong>提交的字节偏移量</strong>（<code>offset of data consumed</code>） 而进行确定的，<code>QUIC</code>会把连续的已确认的<code>offset</code>数据向上层应用提交。<code>QUIC</code>支持乱序确认，但本身也是按序（<code>offset</code>顺序）发送数据包。</li> <li><code>QUIC</code>利用<code>ack frame</code>来进行数据包的确认，来保证可靠传输。一个<code>ack frame</code>只<strong>包含多个确认信息</strong>，没有正文。</li> <li>如果数据包<code>N</code>超时，发送端将超时数据包<code>N</code>重新设置编号<code>M</code>（即下一个顺序的数据包编号） 后发送给接收端。</li> <li>在一个数据包发生超时后，其余的已经发送的数据包依旧可以基于<code>Offset</code>得到确认，避免了<code>TCP</code>利用<code>SACK</code>才能解决的重传问题。</li></ul> <blockquote><p>其实<code>QUIC</code>的乱序确认设计思想并不新鲜，大量网络视频流就是通过类似的基于<code>UDP</code>的<code>RUDP</code>、<code>RTP</code>、<code>UDT</code>等协议来实现快速可靠传输的。他们同样支持乱序确认，所以就会导致这样的观看体验：明明进度条显示还有一段缓存，但是画面就是卡着不动了，如果跳过的话视频又能够播放了。</p></blockquote> <ol><li>如图所示，当前缓冲区大小为<code>8</code>，<code>QUIC</code>按序（<code>offset</code>顺序）发送<code>29-36</code>的数据包：</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202212148196.jpg" alt="img"></p> <ol><li><code>31</code>、<code>32</code>、<code>34</code>数据包先到达，基于<code>offset</code>被优先乱序确认，但<code>30</code>数据包没有确认，所以当前已提交的字节偏移量不变，缓存区不变。</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202212148853.jpg" alt="img"></p> <ol start="2"><li><code>30</code>到达并确认，缓存区收缩到阈值，接收方发送<code>MAX_STREAM_DATA frame</code>（协商缓存大小的特定帧）给发送方，请求增长最大绝对字节偏移量。</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202212148337.jpg" alt="img"></p> <ol start="3"><li>协商完毕后最大绝对字节偏移量右移，缓存区变大，同时发送方发现数据包<code>33</code>超时</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202212149171.jpg" alt="img"></p> <ol start="4"><li>发送方将超时数据包重新编号为<code>42</code>继续发送</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202212149800.jpg" alt="img"></p> <p>以上就是最基本的数据包发送-接收过程，控制数据发送的唯一限制就是最大绝对字节偏移量，该值是接收方基于当前已经提交的偏移量（连续已确认并向上层应用提交的数据包<code>offset</code>）和发送方协商得出。</p></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/04/03, 23:38:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/00c945/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">HTTPS协议</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/00c945/">HTTPS协议</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://github.com/duochizhacai" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://juejin.cn/user/1249486902410744" title="JueJin" target="_blank" class="iconfont icon-juejin"></a></div> 
    Copyright © 2021-2022
    <span><a href='https://beian.miit.gov.cn'>粤ICP备2021165371号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.95fc12d6.js" defer></script><script src="/assets/js/2.abf57e2f.js" defer></script><script src="/assets/js/22.d9f25771.js" defer></script><script src="/assets/js/3.e687237e.js" defer></script>
  </body>
</html>
