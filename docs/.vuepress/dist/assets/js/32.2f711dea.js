(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{473:function(v,_,e){"use strict";e.r(_);var c=e(26),o=Object(c.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器的渲染原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染原理"}},[v._v("#")]),v._v(" 浏览器的渲染原理")]),v._v(" "),e("h2",{attrs:{id:"简述一下浏览器的渲染过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简述一下浏览器的渲染过程"}},[v._v("#")]),v._v(" 简述一下浏览器的渲染过程"),e("badge",{attrs:{text:"重要",type:"warning"}})],1),v._v(" "),e("ul",[e("li",[e("p",[v._v("首先解析收到的文档，根据文档的定义构建一棵"),e("code",[v._v("DOM")]),v._v("树，"),e("code",[v._v("DOM")]),v._v("树是由"),e("code",[v._v("DOM")]),v._v("元素及属性节点组成的")])]),v._v(" "),e("li",[e("p",[v._v("然后对"),e("code",[v._v("css")]),v._v("进行解析，生成"),e("code",[v._v("CSSOM")]),v._v("树")])]),v._v(" "),e("li",[e("p",[v._v("根据"),e("code",[v._v("DOM")]),v._v("树和"),e("code",[v._v("CSSOM")]),v._v("树构建"),e("code",[v._v("render")]),v._v("树，渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和"),e("code",[v._v("DOM")]),v._v("元素相对应，但是不可见的"),e("code",[v._v("DOM")]),v._v("元素不会被插入"),e("code",[v._v("render")]),v._v("树上，还有一个"),e("code",[v._v("dom")]),v._v("元素对应几个可见对象，是一些具有复杂结构的元素，无法用矩形来描述")])]),v._v(" "),e("li",[e("p",[v._v("当渲染对象被创建并添加到树中，他们没有位置和大小，所以当浏览器生成"),e("code",[v._v("render")]),v._v("树之后，会根据"),e("code",[v._v("render")]),v._v("树进行"),e("strong",[v._v("布局")]),v._v("(也可以叫回流)，此时浏览器要弄清楚各个节点在页面的确切位置和大小，也被称为自动重排")])]),v._v(" "),e("li",[e("p",[v._v("布局结束后是"),e("strong",[v._v("绘制阶段")]),v._v("，遍历渲染树并调用渲染对象的"),e("code",[v._v("paint")]),v._v("方法将内容显示在屏幕上，绘制使用"),e("code",[v._v("UI")]),v._v("基础组件")])])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112161516986.png",alt:"img"}})]),v._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的"),e("code",[v._v("html")]),v._v(" 都解析完成之后再去构建和布局 "),e("code",[v._v("render")]),v._v(" 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容")])]),v._v(" "),e("h2",{attrs:{id:"介绍一下浏览器的渲染优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下浏览器的渲染优化"}},[v._v("#")]),v._v(" 介绍一下浏览器的渲染优化")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("针对"),e("code",[v._v("JS")]),v._v("："),e("code",[v._v("js")]),v._v("会阻塞"),e("code",[v._v("html")]),v._v("解析，也会阻塞"),e("code",[v._v("css")]),v._v("解析")]),v._v(" "),e("ul",[e("li",[v._v("尽量将"),e("code",[v._v("js")]),v._v("文件放在"),e("code",[v._v("body")]),v._v("最后")]),v._v(" "),e("li",[e("code",[v._v("body")]),v._v("中间尽量不要写"),e("code",[v._v("script")]),v._v("标签")]),v._v(" "),e("li",[e("code",[v._v("script")]),v._v("的三种引入方式\n"),e("ul",[e("li",[e("strong",[e("code",[v._v("<script>")])]),v._v(" 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行"),e("code",[v._v("js")]),v._v("代码，"),e("code",[v._v("js")]),v._v("代码执行完毕后继续渲染页面；")]),v._v(" "),e("li",[e("strong",[e("code",[v._v("async")])]),v._v(" 是在下载完成之后，立即异步加载，加载好后立即执行，多个带"),e("code",[v._v("async")]),v._v("属性的标签，不能保证加载的顺序；")]),v._v(" "),e("li",[e("strong",[e("code",[v._v("defer")])]),v._v(" 是在下载完成之后，立即异步加载。加载好后，如果 "),e("code",[v._v("DOM")]),v._v(" 树还没构建好，则先等 "),e("code",[v._v("DOM")]),v._v(" 树解析好再执行；如果"),e("code",[v._v("DOM")]),v._v("树已经准备好，则立即执行。多个带"),e("code",[v._v("defer")]),v._v("属性的标签，按照顺序执行。")])])])])]),v._v(" "),e("li",[e("p",[v._v("针对"),e("code",[v._v("CSS")]),v._v("：使用"),e("code",[v._v("css")]),v._v("的方法："),e("code",[v._v("link")]),v._v(" "),e("code",[v._v("@import")]),v._v(" 内联样式")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("link")]),v._v("：浏览器会派发一个线程（"),e("code",[v._v("http")]),v._v("线程）去加载资源文件，同时"),e("code",[v._v("GUI")]),v._v("渲染线程会继续向下渲染代码")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("@import")]),v._v("："),e("code",[v._v("GUI")]),v._v("渲染线程会暂停渲染，去服务器加载资源文件，资源文件没返回之前不会继续渲染(阻碍浏览器渲染)")])]),v._v(" "),e("li",[e("p",[v._v("内联样式："),e("code",[v._v("GUI")]),v._v("线程直接渲染")]),v._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[v._v("注意⚠️")]),v._v(" "),e("p",[v._v("外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以"),e("code",[v._v("CSS")]),v._v("一般写在"),e("code",[v._v("header")]),v._v("中，让浏览器尽快发送请求去获取"),e("code",[v._v("css")]),v._v("样式。所以，在开发过程中，导入外部样式使用"),e("code",[v._v("link")]),v._v("，而不用"),e("code",[v._v("@import")]),v._v("。如果"),e("code",[v._v("css")]),v._v("少，尽可能采用内嵌样式，直接写在"),e("code",[v._v("style")]),v._v("标签中")])])])])]),v._v(" "),e("li",[e("p",[v._v("针对"),e("code",[v._v("DOM")]),v._v("树 "),e("code",[v._v("CSSOM")]),v._v("树")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("html")]),v._v("文件代码层级尽量不要太深")]),v._v(" "),e("li",[v._v("使用语义化标签，避免不标准语义化的特殊处理")]),v._v(" "),e("li",[v._v("减少"),e("code",[v._v("css")]),v._v("代码的层级，因为选择器是从右向左进行解析的")])])]),v._v(" "),e("li",[e("p",[v._v("减少回流和重绘")]),v._v(" "),e("ul",[e("li",[v._v("操作"),e("code",[v._v("dom")]),v._v("时，尽量在底层级的"),e("code",[v._v("dom")]),v._v("节点进行操作")]),v._v(" "),e("li",[v._v("不要使用"),e("code",[v._v("table")]),v._v("，一个小的改动会使整个"),e("code",[v._v("table")]),v._v("进行重新布局")]),v._v(" "),e("li",[v._v("不能频繁操作元素的样式，对于静态页面，尽量修改类名，而不是样式")]),v._v(" "),e("li",[v._v("使用"),e("code",[v._v("css")]),v._v("表达式")]),v._v(" "),e("li",[v._v("使用"),e("code",[v._v("absolute")]),v._v("或者"),e("code",[v._v("fixed")]),v._v("，使元素脱离文档流，这样发生变化不会影响其他元素")]),v._v(" "),e("li",[v._v("避免频繁操作"),e("code",[v._v("dom")]),v._v("，可以"),e("mark",[v._v("创建一个文档片段，"),e("code",[v._v("documentFragment")]),v._v(",在他上面应用所有"),e("code",[v._v("dom")]),v._v("操作，然后把他添加到文档中")])]),v._v(" "),e("li",[v._v("将元素先"),e("code",[v._v("display：none")]),v._v("，操作结束后再把他显示出来，因为"),e("code",[v._v("display")]),v._v("为"),e("code",[v._v("none")]),v._v("中进行"),e("code",[v._v("dom")]),v._v("操作不会引发回流和重绘")]),v._v(" "),e("li",[v._v("将"),e("code",[v._v("dom")]),v._v("的多个读写操作放在一个，而不是读写操作穿插，得益于浏览器的渲染队列机制")])]),v._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[v._v("值得注意的是⚠️")]),v._v(" "),e("p",[e("strong",[v._v("浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。")]),v._v(" 将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。")])])])]),v._v(" "),e("h2",{attrs:{id:"渲染过程中遇到的js文件如何处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程中遇到的js文件如何处理"}},[v._v("#")]),v._v(" 渲染过程中遇到的"),e("code",[v._v("js")]),v._v("文件如何处理")]),v._v(" "),e("p",[e("code",[v._v("js")]),v._v("的加载、解析和执行会阻塞文档的解析，也就是说在构建"),e("code",[v._v("dom")]),v._v("是，"),e("code",[v._v("html")]),v._v("解析器遇到"),e("code",[v._v("js")]),v._v("的话会暂停文档的解析，然后将控制权移交给"),e("code",[v._v("JS")]),v._v("引擎，等他完成之后浏览器再从中断等地方恢复继续解析文档，也就是说，如果想要首屏渲染地越快，就越不应该再首屏加载"),e("code",[v._v("JS")]),v._v("文件，还是建议把"),e("code",[v._v("script")]),v._v("放到"),e("code",[v._v("body")]),v._v("的底部，或者加上"),e("code",[v._v("defer")]),v._v("或"),e("code",[v._v("async")])]),v._v(" "),e("h2",{attrs:{id:"什么是文档的预解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是文档的预解析"}},[v._v("#")]),v._v(" 什么是文档的预解析")]),v._v(" "),e("p",[e("code",[v._v("webkit")]),v._v("和"),e("code",[v._v("firefox")]),v._v("都做了优化，当执行"),e("code",[v._v("JS")]),v._v("脚本的时候，另一个线程解析剩下的文档并加载后面需要用到的网络资源，这种方式可以使资源并行加载从而使整体速度更快，值得注意的是预解析并不改变"),e("code",[v._v("dom")]),v._v("树，他将整个工作留给了主解析过程，自己只"),e("strong",[v._v("解析外部资源的引用，比如外部"),e("code",[v._v("script")]),v._v("、"),e("code",[v._v("css")]),v._v("、"),e("code",[v._v("image")])])]),v._v(" "),e("h2",{attrs:{id:"css如何阻塞文档解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css如何阻塞文档解析"}},[v._v("#")]),v._v(" "),e("code",[v._v("CSS")]),v._v("如何阻塞文档解析")]),v._v(" "),e("p",[v._v("理论上即使"),e("code",[v._v("css")]),v._v("不改变"),e("code",[v._v("dom")]),v._v("树，也就没有必要停下文档的解析等待他们，然而当"),e("code",[v._v("JS")]),v._v("执行时可能在文档解析过程中请求样式信息，"),e("strong",[v._v("如果样式还没有加载和解析，脚本将得到错误的值")]),v._v("，显然会导致很多问题，所以如果浏览器尚未完成 "),e("code",[v._v("CSSOM")]),v._v(" 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 "),e("code",[v._v("JavaScript")]),v._v(" 脚本执行和文档的解析，直至其完成 "),e("code",[v._v("CSSOM")]),v._v(" 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 "),e("code",[v._v("CSSOM")]),v._v("，然后再执行 "),e("code",[v._v("JavaScript")]),v._v("，最后再继续文档的解析")]),v._v(" "),e("h2",{attrs:{id:"js脚本放在头部一定会造成阻塞吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js脚本放在头部一定会造成阻塞吗"}},[v._v("#")]),v._v(" "),e("code",[v._v("js")]),v._v("脚本放在头部一定会造成阻塞吗")]),v._v(" "),e("p",[v._v("不一定会")]),v._v(" "),e("p",[v._v("如果"),e("code",[v._v("js")]),v._v("并没有引用"),e("code",[v._v("dom")]),v._v("的话就不会造成阻塞，当然也不排除其他情况阻塞，但是并不会一定造成阻塞")]),v._v(" "),e("h2",{attrs:{id:"如何优化关键渲染路径"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何优化关键渲染路径"}},[v._v("#")]),v._v(" 如何优化关键渲染路径")]),v._v(" "),e("p",[v._v("为了尽快完成首次渲染，需要最大限度减小以下三种可变因素")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("关键资源的数量")])]),v._v(" "),e("li",[e("p",[v._v("关键路径长度")])]),v._v(" "),e("li",[e("p",[v._v("关键字节的数量")])])]),v._v(" "),e("blockquote",[e("p",[v._v("关键资源是可能阻止网页首次渲染的资源。")])]),v._v(" "),e("p",[v._v("这些资源越少，浏览器的工作量就越小，对 "),e("code",[v._v("CPU")]),v._v(" 以及其他资源的占用也就越少。同样，"),e("strong",[v._v("关键路径长度受所有关键资源与其字节大小之间")]),v._v("依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。")]),v._v(" "),e("p",[v._v("最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。")]),v._v(" "),e("p",[v._v("优化关键渲染路径的常规步骤如下：")]),v._v(" "),e("ol",[e("li",[v._v("对关键路径进行分析和特性描述：资源数、字节数、长度。")]),v._v(" "),e("li",[v._v("最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。")]),v._v(" "),e("li",[v._v("优化关键字节数以缩短下载时间（往返次数）。")]),v._v(" "),e("li",[v._v("优化其余关键资源的加载顺序：您需要尽早下载所有关键资源，以缩短关键路径长度")])]),v._v(" "),e("h2",{attrs:{id:"什么情况下会阻塞渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下会阻塞渲染"}},[v._v("#")]),v._v(" 什么情况下会阻塞渲染")]),v._v(" "),e("p",[v._v("首先渲染的前提是生成"),e("code",[v._v("render")]),v._v("树，所以"),e("code",[v._v("html")]),v._v("和"),e("code",[v._v("css")]),v._v("肯定会阻止渲染，如果想更快，那只能降低文件大小或者压缩，扁平层级，优化选择器。然后当浏览器解析到"),e("code",[v._v("script")]),v._v("标签时，会暂停构建"),e("code",[v._v("DOM")]),v._v("，完成之后才会从暂停的地方重新开始，所以想更快，就"),e("strong",[v._v("不应该在首屏加载"),e("code",[v._v("JS")]),v._v("文件，全是建议在"),e("code",[v._v("body")]),v._v("标签底部写入"),e("code",[v._v("script")]),v._v("标签的")])]),v._v(" "),e("p",[v._v("或者给"),e("code",[v._v("script")]),v._v("标签加上"),e("code",[v._v("defer")]),v._v("或者"),e("code",[v._v("async")]),v._v("属性，都会并行下载，同时不会阻塞渲染")])])}),[],!1,null,null,null);_.default=o.exports}}]);