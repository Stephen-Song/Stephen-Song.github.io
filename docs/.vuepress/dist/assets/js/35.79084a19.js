(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{476:function(s,t,a){"use strict";a.r(t);var n=a(26),_=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器的垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的垃圾回收机制"}},[s._v("#")]),s._v(" 浏览器的垃圾回收机制")]),s._v(" "),a("h2",{attrs:{id:"介绍一下v8的垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下v8的垃圾回收机制"}},[s._v("#")]),s._v(" 介绍一下"),a("code",[s._v("V8")]),s._v("的垃圾回收机制"),a("badge",{attrs:{text:"特别重要",type:"error"}})],1),s._v(" "),a("p",[s._v("执行时机："),a("strong",[s._v("利用浏览器渲染页面的空闲时间进行垃圾回收")])]),s._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[s._v("题外话:栈内存的回收")]),s._v(" "),a("p",[s._v("栈内存调用栈上下文切换后就被回收，比较简单。")])]),s._v(" "),a("p",[a("code",[s._v("V8")]),s._v(" 实现了准确式 "),a("code",[s._v("GC")]),s._v("，"),a("code",[s._v("GC")]),s._v(" 算法采用了"),a("strong",[s._v("分代式垃圾回收机制")]),s._v("。因此，"),a("code",[s._v("V8")]),s._v(" 将内存（堆）分为新生代和老生代两部分")]),s._v(" "),a("p",[a("strong",[s._v("1. 新生代算法")])]),s._v(" "),a("p",[s._v("新生代中的对象一般"),a("mark",[a("strong",[s._v("存活时间较短")])]),s._v("，使用 "),a("code",[s._v("Scavenge GC")]),s._v(" 算法。")]),s._v(" "),a("p",[s._v("在新生代空间中，内存空间分为两部分，分别为 "),a("code",[s._v("From")]),s._v(" 空间和 "),a("code",[s._v("To")]),s._v(" 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。")]),s._v(" "),a("p",[s._v("新分配的对象会被放入 "),a("code",[s._v("From")]),s._v(" 空间中，当 "),a("code",[s._v("From")]),s._v(" 空间被占满时，新生代 "),a("code",[s._v("GC")]),s._v(" 就会启动了。算法会检查 "),a("code",[s._v("From")]),s._v(" 空间中存活的对象并复制到 "),a("code",[s._v("To")]),s._v(" 空间中，如果有失活的对象就会销毁。")]),s._v(" "),a("p",[s._v("当复制完成后将 "),a("code",[s._v("From")]),s._v(" 空间和 "),a("code",[s._v("To")]),s._v(" 空间互换，这样 "),a("code",[s._v("GC")]),s._v(" 就结束了。")]),s._v(" "),a("p",[a("strong",[s._v("2. 老生代算法")])]),s._v(" "),a("p",[s._v("老生代中的对象一般"),a("mark",[a("strong",[s._v("存活时间较长且数量也多")])]),s._v("，使用了两个算法，分别是 "),a("strong",[a("mark",[s._v("标记清除算法")])]),s._v(" 和 "),a("strong",[a("mark",[s._v("标记压缩算法")])])]),s._v(" "),a("p",[s._v("先来说下什么情况下对象会出现在老生代空间中：")]),s._v(" "),a("ul",[a("li",[s._v("新生代中的对象是否已经经历过一次 "),a("code",[s._v("Scavenge")]),s._v(" 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。")]),s._v(" "),a("li",[a("code",[s._v("To")]),s._v(" 空间的对象占比大小超过 "),a("code",[s._v("25 %")]),s._v("。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。")])]),s._v(" "),a("p",[s._v("老生代中的空间很复杂，有如下几个空间")]),s._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("enum")]),s._v(" AllocationSpace "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// TODO(v8:7464): Actually map this space's memory as read-only.")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("RO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 不变的对象空间")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NEW_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 新生代用于 GC 复制算法的空间")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("OLD_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 老生代常驻对象空间")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("CODE_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 老生代代码对象空间")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("MAP_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 老生代 map 对象")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 老生代大空间对象")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NEW_LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 新生代大空间对象")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("FIRST_SPACE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("RO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("LAST_SPACE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NEW_LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("FIRST_GROWABLE_PAGED_SPACE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("OLD_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("LAST_GROWABLE_PAGED_SPACE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("MAP_SPACE")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("在老生代中，以下情况会先启动标记清除算法：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("某一个空间没有分块的时候")])]),s._v(" "),a("li",[a("p",[s._v("空间中被对象超过一定限制")])]),s._v(" "),a("li",[a("p",[s._v("空间不能保证新生代中的对象移动到老生代中")])])]),s._v(" "),a("p",[s._v("在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，"),a("code",[s._v("V8")]),s._v(" 从 "),a("code",[s._v("stop-the-world")]),s._v(" 标记切换到增量标志。在增量标记期间，"),a("code",[s._v("GC")]),s._v(" 将标记工作分解为更小的模块，可以让"),a("code",[s._v("JS")]),s._v(" 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，"),a("code",[s._v("GC")]),s._v(" 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 "),a("code",[s._v("GC")]),s._v(" 扫描和标记对象时，同时允许 "),a("code",[s._v("JS")]),s._v(" 运行。")]),s._v(" "),a("p",[s._v("清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动"),a("strong",[s._v("压缩算法")]),s._v("。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。")]),s._v(" "),a("p",[s._v("当然他也有缺点：就是清除之后会造成内存不连续")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202203031539073.png",alt:""}})]),s._v(" "),a("h2",{attrs:{id:"哪些操作会造成内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哪些操作会造成内存泄漏"}},[s._v("#")]),s._v(" 哪些操作会造成内存泄漏")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。")])]),s._v(" "),a("li",[a("p",[s._v("第二种情况是设置了 "),a("code",[s._v("setInterval")]),s._v(" 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。")])]),s._v(" "),a("li",[a("p",[s._v("第三种情况是获取一个 "),a("code",[s._v("DOM")]),s._v(" 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。")])]),s._v(" "),a("li",[a("p",[s._v("第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);