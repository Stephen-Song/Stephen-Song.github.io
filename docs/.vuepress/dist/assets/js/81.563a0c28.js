(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{521:function(e,v,_){"use strict";_.r(v);var s=_(26),t=Object(s.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"git-rebase-和-merge-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase-和-merge-的区别"}},[e._v("#")]),e._v(" "),_("code",[e._v("git rebase")]),e._v(" 和 "),_("code",[e._v("merge")]),e._v(" 的区别")]),e._v(" "),_("p",[_("code",[e._v("git merge")])]),e._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202203062325394.png",alt:""}})]),e._v(" "),_("p",[_("code",[e._v("master")]),e._v(" 分支合入到 "),_("code",[e._v("feature")]),e._v(" 分支")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("git checkout feature\ngit merge master\n\n// 或者\ngit merge master feature\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br")])]),_("p",[_("code",[e._v("git merge")]),e._v(" 的优势是它保留了分支的结构与历史提交目录，但同时这也导致了提交历史会被大量的 "),_("code",[e._v("merge")]),e._v(" 污染")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("git rebase")])])]),e._v(" "),_("p",[_("code",[e._v("rebase")]),e._v(" 命令是一个经常听到，但是大多数人掌握又不太好的一个命令。"),_("code",[e._v("rebase")]),e._v(" 合并往往又被称为 「变基」")]),e._v(" "),_("p",[e._v("它是将把所有的提交压缩成一个 "),_("code",[e._v("patch")]),e._v(" 。然后把 "),_("code",[e._v("patch")]),e._v(" 添加到目标分支里。"),_("code",[e._v("rebase")]),e._v(" 与 "),_("code",[e._v("merge")]),e._v(" 不同的是，"),_("code",[e._v("rebase")]),e._v(" 通过为原始分支中的每个提交创建全新的 "),_("code",[e._v("commits")]),e._v(" 来重写项目历史记录")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202203062327245.png",alt:""}}),e._v("以 "),_("code",[e._v("master")]),e._v(" 分支为基，对 "),_("code",[e._v("feautre")]),e._v(" 分支进行变基：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("git checout feature\ngit rebase master\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br")])]),_("p",[_("code",[e._v("git rebase")]),e._v(" 的优势是可以获得更清晰的项目历史。首先，它消除了 "),_("code",[e._v("git merge")]),e._v(" 所需的不必要的合并提交；其次，正如你在上图中所看到的，"),_("code",[e._v("rebase")]),e._v(" 会产生完美线性的项目历史记录，你可以在 "),_("code",[e._v("feature")]),e._v(" 分支上没有任何分叉的情况下一直追寻到项目的初始提交。")]),e._v(" "),_("p",[e._v("但是， "),_("code",[e._v("rebase")]),e._v(" 会丢失合并提交的上下文， 使我们无法看到真实的更改是何时合并到目标分支上的")]),e._v(" "),_("p",[_("strong",[e._v("交互式 "),_("code",[e._v("Rebase")])])]),e._v(" "),_("p",[e._v("这个命令比 "),_("code",[e._v("git rebase")]),e._v(" 更为强大，它将会在 "),_("code",[e._v("commits")]),e._v(" 移动到新分支时更改这些 "),_("code",[e._v("commits")]),e._v(" ，通常，这用于在合并 "),_("code",[e._v("feature")]),e._v(" 分支到 "),_("code",[e._v("master")]),e._v(" 之前清理其杂乱的历史记录。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202203062330559.png",alt:""}})]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("git checkout feature\ngit rebase -i master\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br")])]),_("p",[e._v("这将打开一个文本编辑器，列出即将移动的所有提交：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("pick 6633b5a Message for commit #1\npick 3a03f0d Message for commit #2\npick 657897b Message for commit #3\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("它清晰地展示了分支在 "),_("code",[e._v("rebase")]),e._v(" 后的样子。通过重新调整，提交历史可以变成任何你想要的样子。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202203062331920.png",alt:""}})]),e._v(" "),_("p",[e._v("消除这种无意义的提交使你的功能历史更容易理解。这是 "),_("code",[e._v("git merge")]),e._v(" 根本无法做到的事情。")]),e._v(" "),_("p",[e._v("至于 "),_("code",[e._v("commits")]),e._v(" 条目前的 "),_("code",[e._v("pick")]),e._v("、"),_("code",[e._v("fixup")]),e._v("、"),_("code",[e._v("squash")]),e._v(" 等命令，在 "),_("code",[e._v("git")]),e._v(" 目录执行 "),_("code",[e._v("git rebase -i")]),e._v(" 即可查看到，大家按需重排或合并提交即可，注释说明非常清晰，在此不做过多说明")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("git merge vs git rebase")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("git merge：")])])]),e._v(" "),_("ul",[_("li",[e._v("记录下合并动作，很多时候这种合并动作是垃圾信息")]),e._v(" "),_("li",[e._v("不会修改原 "),_("code",[e._v("commit ID")])]),e._v(" "),_("li",[e._v("冲突只解决一次")]),e._v(" "),_("li",[e._v("分支看着不大整洁，但是能看出合并的先后顺序")]),e._v(" "),_("li",[e._v("记录了真实的 "),_("code",[e._v("commit")]),e._v(" 情况，包括每个分支的详情")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("git rebase：")])])]),e._v(" "),_("ul",[_("li",[e._v("改变当前分支 "),_("code",[e._v("branch out")]),e._v(" 的位置")]),e._v(" "),_("li",[e._v("得到更简洁的项目历史")]),e._v(" "),_("li",[e._v("每个 "),_("code",[e._v("commit")]),e._v(" 都需要解决冲突")]),e._v(" "),_("li",[e._v("修改所有 "),_("code",[e._v("commit ID")])])]),e._v(" "),_("p",[e._v("建议")]),e._v(" "),_("p",[e._v("随着团队增长，通过 "),_("code",[e._v("merge")]),e._v(" 策略很难管理和追踪到每个提交。为了提交历史更清晰、更易于理解，使用 "),_("code",[e._v("rebase")]),e._v(" 是一个明智、高效的选择。")]),e._v(" "),_("p",[e._v("下面是针对不同环境的建议，可以最大限度地发挥 "),_("code",[e._v("rebase")]),e._v(" 的优势：")]),e._v(" "),_("p",[e._v("**本地开发：**如果你没有和别人协同工作，你应该使用 "),_("code",[e._v("rebasing")]),e._v(" 而不是 "),_("code",[e._v("merging")]),e._v(" ，这样历史记录会很清晰。如果你已经从仓库拉取了你的个人 "),_("code",[e._v("fork")]),e._v("，并且不准备和别的开发者一起工作，在分支 "),_("code",[e._v("push")]),e._v(" 前 "),_("code",[e._v("rebase")]),e._v(" 也是可以的。")]),e._v(" "),_("p",[e._v("你的代码准备好了被 "),_("code",[e._v("review")]),e._v(" ：你创建了 "),_("code",[e._v("pull request")]),e._v("。别人正在 "),_("code",[e._v("review")]),e._v(" 你的代码，可能把它拉到了本地 "),_("code",[e._v("review")]),e._v(" 。如果这样，你最好别 "),_("code",[e._v("rebase")]),e._v(" 你的代码。你应该创建一个 "),_("code",[e._v("“rework”")]),e._v(" 提交来更新你的 "),_("code",[e._v("feature")]),e._v(" 分支。它会让 "),_("code",[e._v("pull request")]),e._v(" 的可塑性更强，也能避免历史突然丢失。")]),e._v(" "),_("p",[_("code",[e._v("review")]),e._v(" 已经完成并且已经准备好了合并到目标分支。恭喜！你就要删除你的 "),_("code",[e._v("feature")]),e._v(" 分支了。由于别的开发者不需要拉取、合并这些更改，这是你清理记录的好机会。你可以改写记录，折叠原始提交、"),_("code",[e._v("“pr rework”")]),e._v(" 提交和 "),_("code",[e._v('"merge"')]),e._v(" 提交，使之成为一整个清晰的提交。作为可选，你还可以给这些提交创建一个明确的 "),_("code",[e._v("merge")]),e._v(" ，这样做实际上很有用。它会记录 "),_("code",[e._v("feature")]),e._v(" 并入 "),_("code",[e._v("master")]),e._v(" 的时间。")])])}),[],!1,null,null,null);v.default=t.exports}}]);