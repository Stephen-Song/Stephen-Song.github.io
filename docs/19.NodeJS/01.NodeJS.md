---
title: NodeJS
date: 2022-01-27 17:40:43
permalink: /pages/0c9847/
---

# NodeJS

## `readFile` 和 `createReadStream` 函数有什么区别

`readFile` 函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户。

`createReadStream` 使用一个可读的流，逐块读取文件，而不是全部存储在内存中。

与 `readFile` 相比，`createReadStream` 使用更少的内存和更快的速度来优化文件读取操作。如果文件相当大，用户不必等待很长时间直到读取整个内容，因为读取时会先向用户发送小块内容。

```js
const fs = require("fs");
fs.readFile("test.txt", (err, content) => {
  console.log(content);
});
```

## 如何处理 `Node.js` 中未捕获的异常

- 我们可以在进程级别捕获应用程序中未捕获的异常。为此将侦听器附加到 `process` 全局对象：

```js
process.on("uncaughtException", (err) => {
  //打印出错误
  console.log(err);
  //打印出错误的调用栈方便调试
  console.log(err.stack)；
});
```

- `Promise`封装异步处理，并用`catch`处理
- 使用`pm2`部署项目

## 反应堆设计模式是什么

反应堆设计模式是，`Node.js` 将回调函数（处理程序）附加到每个 `I/O` 操作，然后创建请求时将处理程序提交给解复用器。

解复用器收集应用程序中发出的每个 `I/O` 请求，并将它们作为队列中的事件进行排队。这个队列就是我们所说的事件队列。将事件排队后，解复用器返回应用程序线程的控制。

同时，事件循环遍历事件队列中的每个事件，并调用附加的回调来处理事件响应。

这就是 `Node.js` 中所使用的反应堆模式。

## 单线程与多线程网络后端相比有哪些好处

- 开发人员更容易实现应用程序。我们的应用程序在生产过程中不会突然遇到意外的竞争条件。
- 单线程应用程序易于扩展。
- 它们可以毫不延迟地在一个时刻收到的大量用户请求提供服务。相比之下，当流量较大时，多线程后端必须等待线程池中的线程释放，才能为用户请求提供服务。利用 `Node.js` 的非阻塞特性，用户请求不会在单个线程上挂起太长时间（只有在操作不是 `CPU` 密集型时）。

## `process.nextTick` 和 `setImmediate` 有什么区别

传递给 `setImmediate` 函数的回调将在事件队列上的下一次迭代中执行。

另一方面，回调传递给 `process.nextTick` 在下一次迭代之前以及程序中当前运行的操作完成之后执行。在应用程序启动时，开始遍历事件队列之前调用它的回调。

因此，回调 `process.nextTick` 总是在 `setImmediate` 之前调用。

下面代码段：

```js
setImmediate(() => {
  console.log("first");
})
process.nextTick(() => {
  console.log("second");
})
console.log("third");
```

将按顺序输出：

```
third
second
first
```

## `Master-Worker`架构

`NodeJS` 提供了 `Child_process` 和 `Cluster` 模块创建子进程,实现多进程和子进程的管理.

进程分为 `Master(主进程)`和 `Worker(子进程)`,`master`进程负责调度或管理`worker`进程，那么`worker`进程负责具体的业务处理。对于一个 `B/S` 架构的后端程序而言, `master` 就负责接受请求,然后分发给 `worker` 进程进行对应的业务处理. 多个 `worker` 就相当于多台服务器工作.也就是一个集群.同事 `master` 还负责监控 `worker` 的运行状态和管理操作

## `node`如何开启多线程

**`child_process API`**

`child_process` 提供了开启子进程执行代码或命令的能力,分别是:

- `child_process.exec(command[, options][, callback])` 子进程中执行的是非`node`程序，提供一串`shell`命令，执行的结果以回调的形式返回。
- `child_process.execFile(file[, args][, options][, callback])` 子进程中执行的是非`node`程序，提供 `shell` 脚本文件，执行的结果以回调的形式返回。
- `child_process.fork(modulePath[, args][, options])` 子进程执行 `node` 程序,执行的结果以流的形式返回。 该模块已建立了 `IPC` 通信通道，可以在父进程与子进程之间发送消息。
- `child_process.spawn(command[, args][, options])` 子进程中执行的是非`node`程序，提供一组参数后，执行的结果以流的形式返回。

`child_process.spawn()`、`child_process.fork()`、`child_process.exec()` 和 `child_process.execFile()` 方法都遵循其他 `Node.js API` 惯用的异步编程模式。

每个方法都返回一个 `ChildProcess` 实例。 这些对象实现了 `Node.js` 的 `EventEmitter API`，允许父进程注册监听器函数，在子进程的生命周期中当发生某些事件时会被调用。

`child_process.exec()` 和 `child_process.execFile()` 方法还允许指定可选的 `callback` 函数，当子进程终止时会被调用。
