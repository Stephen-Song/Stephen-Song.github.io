---
title: 动态规划
date: 2022-01-15 08:28:38
permalink: /pages/6aee18/
---

## lc322. 零钱兑换<Badge text="中等" vertical="top"/>

:::tip 题目描述

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 :::

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```
输入：coins = [1], amount = 2
输出：2
```

> 思路

```
- 假设给出的不同面额的硬币是[1, 2, 5]，目标是 120，问最少需要的硬币个数？

- 我们要分解子问题，分层级找最优子结构，看到这又要晕了哈，憋急~~ 下面马上举例。

- 这里我们使用「自顶向下」思想来考虑这个题目，然后用「自底向上」的方法来解题，
  体验算法的冰火两重天。

- dp[i]: 表示总金额为 i 的时候最优解法的硬币数

- 我们想一下：求总金额 120 有几种方法？下面这个思路关键了 !!!
  一共有 3 种方式，因为我们有 3 种不同面值的硬币。
  1.拿一枚面值为 1 的硬币 + 总金额为 119 的最优解法的硬币数量
    这里我们只需要假设总金额为 119 的最优解法的硬币数有人已经帮我们算好了，
    不需要纠结于此。(虽然一会也是我们自己算，哈哈)
    即：dp[119] + 1
  2.拿一枚面值为 2 的硬币 + 总金额为 118 的最优解法的硬币数
    这里我们只需要假设总金额为 118 的最优解法的硬币数有人已经帮我们算好了
    即：dp[118] + 1
  3.拿一枚面值为 5 的硬币 + 总金额为 115 的最优解法的硬币数
    这里我们只需要假设总金额为 115 的最优解法的硬币数有人已经帮我们算好了
    即：dp[115] + 1
    
  - 所以，总金额为 120 的最优解法就是上面这三种解法中最优的一种，也就是硬币数最少
    的一种，我们下面试着用代码来表示一下：
    
  - dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1);
    
  - 推导出「状态转移方程」：
    dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)
    其中 coin 有多少种可能，我们就需要比较多少次，那么我们到底需要比较多少次呢？
    当然是 coins 数组中有几种不同面值的硬币，就是多少次了~ 遍历 coins 数组，
    分别去对比即可
    
  - 上面方程中的 dp[119]，dp[118]，dp[115] 我们继续用这种思想去分解，
    这就是动态规划了，把这种思想，思考问题的方式理解了，这一类型的题目
    问题都不会太大。
```

```js
var coinChange = function(coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity)
  dp[0] = 0
  for(let i = 1; i <= amount; i++) {
    for(let coin of coins) {
      if(i - coin >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1)
      }
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]
};
```

时间复杂度:`O(m * n)`   `m` `n`分别为金额总数和硬币种数

空间复杂度:`O(m)`

## lc53. 最大子数组和<Badge text="简单" vertical="top"/>

:::tip 题目描述

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

 :::

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

> 思路

状态转移方程`f(i)=max{f(i−1)+nums[i],nums[i]}`

降低空间复杂度用`pre`保存上一个最大连续数组的和

```js
var maxSubArray = function(nums) {
  if(!nums.length) return 0
  let sum = nums[0]
  let pre = 0
  for(let i = 0; i < nums.length; i++) {
    pre = Math.max(pre + nums[i], nums[i])
    sum = Math.max(sum, pre)
  }
  return sum
};
```

## lc70. 爬楼梯<Badge text="简单" vertical="top"/>

:::tip 题目描述

假设你正在爬楼梯。需要  *`n`* 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *`n`* 是一个正整数。

:::

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

> 思路

状态转移方程：`dp[i] = dp[i - 1] + dp[i - 2]`

```js
var climbStairs = function(n) {
  const dp = []
  dp[1] = 1
  dp[2] = 2
  for(let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
};
```

时间复杂度:`O(n)`

空间复杂度:`O(n)`

## lc121. 买卖股票的最佳时机 I<Badge text="简单" vertical="top"/>

:::tip 题目描述

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

::: 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

> 思路一

设置一个变量存放最小的值，一个变量存放求和的值

```js
var maxProfit = function(prices) {
  if(!prices.length) return 0
  let min = prices[0]
  let sum = 0
  for(let i = 1; i < prices.length; i++) {
    if(prices[i] < min) min = prices[i]
    if(prices[i] - min > sum) sum = prices[i] - min
  }
  return sum
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

> 思路二：动态规划

对于这道题，我们可以使用**动态规划**来解决。这里我们只需要进行一次买入卖出。那到最后交易时，可能会有三种状态：

- `dp[0]`：一直没有买
- `dp[1]`：：到最后只买了一笔，未卖出
- `dp[2]`：：到最后只卖了一笔，并卖出

由于第一种状态未进行任何操作，所以可以不用记录。然后我们对后两种状态进行转移：

- `dp[1] = Math.min(dp[1], prices[i])`：前一天也是`b1`状态或者是没有任何操作，今天买入一笔变成b1状态；
- `dp[2] = Math.max(dp[2], prices[i] - dp[1])`：前一天也是`s1`状态或者是`b1`状态，今天卖出一笔变成`s1`状态；

```js
var maxProfit = function(prices) {
  if(!prices.length) return 0
  let dp = [0, prices[0], 0]
  for(let i = 1; i < prices.length; i++) {
    dp[1] = Math.min(dp[1], prices[i])
    dp[2] = Math.max(dp[2], prices[i] - dp[1])
  }
  return dp[2]
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

## lc122. 买卖股票的最佳时机 II<Badge text="中等" vertical="top"/>

:::tip 题目描述

给定一个数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 :::

**示例 1:**

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

> 思路一

跟上题的思路一相仿，这题显得更简单，只有当天比前一天的金额高利润就加上他们的差价

```js
var maxProfit = function(prices) {
  let res = 0
  for(let i = 1; i < prices.length; i++) {
    if(prices[i] > prices[i - 1]) {
      res += (prices[i] - prices[i - 1])
    }
  }
  return res
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

> 思路

对于这道题目，我们可以使用**动态规划**来解答。每个点的状态描述：手里有股票或者没股票。

1. `dp[i][0]`表示：第 `i` 天手里没股票，至今（第 `i` 天）的最大收益。第 `i` 天手里没股票，有两种可能：

- 昨天也没持有股票：`dp[i-1][0]`
- 昨天买了股票，今天卖了: `dp[i-1][1] + prices[i]`(注意⚠️`dp[i - 1][1]`是负数，所以这里是加)
- `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`

2. `dp[i][1]`表示：第 `i` 天手里有股票，至今（第 `i` 天）的最大收益。第 `i` 天手里有股票，有两种可能：

- 昨天也有股票：`dp[i-1][1]`
- 昨天卖了，今天买了: `dp[i-1][0] - prices[i]`
- `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`

最终目标是求出：`dp[prices.length-1][0]`和`dp[prices.length-1][1]`的较大者，前者肯定>=后者，求`dp[prices.length-1][0]`即可。

**对于开始：**

- `day 0` 没买:`dp[0][0] = 0`
- `day 0` 买了:`dp[0][1] = -prices[0]`

```js
function maxProfit(prices) {
  const len = prices.length;
  if (len < 2) {
    return 0;
  };
  const dp = new Array(len);
  dp[0] = [0, -prices[0]];
  for (let i = 1; i < len; i++) {
    dp[i] = new Array(2);
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); // 没有股票
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 有股票
  }
  return dp[len - 1][0];
}
```

- **时间复杂度：** `O(n)`，其中 `n` 为数组的长度。一共有 `2n` 个状态，每次状态转移的时间复杂度为 `O(1)`，因此时间复杂度为 `O(2n)=O(n)`。
- **空间复杂度**：`O(n)`，我们需要开辟`O(n)` 空间存储动态规划中的所有状态。

## lc198. 打家劫舍<Badge text="中等" vertical="top"/>

:::tip 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 :::

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

> 思路

首先来看最简单的两种情况，如果只有一间房屋，那这个屋子就是最高的金额，如果有两间房屋，那不能同时偷，只能偷其中其中金额高的那间，如果大于两间屋子，就要进行讨论了。

- 如果偷第`n`个房间，那么就不能偷第`n - 1`个房间，那么总金额就是前`n - 2`间屋子能偷到的最高的金额之和；
- 如果不偷第`k`间屋，那么能偷到的总金额就是前`k - 1`个房间的最高总金额。

这两者，我们只要取总金额的较大值即可。

我们可以用 `dp[i]` 表示前 `i` 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：

```javascript
dp[i]=max(dp[i−2]+nums[i],dp[i−1])
```

边界条件为：

- `dp[0] = 0` ：
- `dp[1] = nums[0]`：只有一间房屋，则偷窃该房屋

最终的答案即为 `dp[n]`，其中 `n` 是数组的长度。

```js
var rob = function(nums) {
  let len = nums.length
  if(!len) return 0

  let dp = new Array(len + 1)
  dp[0] = 0
  dp[1] = nums[0]
  for(let i = 2; i < len + 1; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1])
  }
  return dp[len]
};
```

