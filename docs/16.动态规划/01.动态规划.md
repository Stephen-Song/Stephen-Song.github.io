---
title: 动态规划
date: 2022-01-15 08:28:38
permalink: /pages/6aee18/
---

## lc322. 零钱兑换

:::tip 题目描述

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 :::

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```
输入：coins = [1], amount = 2
输出：2
```

> 思路

```
- 假设给出的不同面额的硬币是[1, 2, 5]，目标是 120，问最少需要的硬币个数？

- 我们要分解子问题，分层级找最优子结构，看到这又要晕了哈，憋急~~ 下面马上举例。

- 这里我们使用「自顶向下」思想来考虑这个题目，然后用「自底向上」的方法来解题，
  体验算法的冰火两重天。

- dp[i]: 表示总金额为 i 的时候最优解法的硬币数

- 我们想一下：求总金额 120 有几种方法？下面这个思路关键了 !!!
  一共有 3 种方式，因为我们有 3 种不同面值的硬币。
  1.拿一枚面值为 1 的硬币 + 总金额为 119 的最优解法的硬币数量
    这里我们只需要假设总金额为 119 的最优解法的硬币数有人已经帮我们算好了，
    不需要纠结于此。(虽然一会也是我们自己算，哈哈)
    即：dp[119] + 1
  2.拿一枚面值为 2 的硬币 + 总金额为 118 的最优解法的硬币数
    这里我们只需要假设总金额为 118 的最优解法的硬币数有人已经帮我们算好了
    即：dp[118] + 1
  3.拿一枚面值为 5 的硬币 + 总金额为 115 的最优解法的硬币数
    这里我们只需要假设总金额为 115 的最优解法的硬币数有人已经帮我们算好了
    即：dp[115] + 1
    
  - 所以，总金额为 120 的最优解法就是上面这三种解法中最优的一种，也就是硬币数最少
    的一种，我们下面试着用代码来表示一下：
    
  - dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1);
    
  - 推导出「状态转移方程」：
    dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)
    其中 coin 有多少种可能，我们就需要比较多少次，那么我们到底需要比较多少次呢？
    当然是 coins 数组中有几种不同面值的硬币，就是多少次了~ 遍历 coins 数组，
    分别去对比即可
    
  - 上面方程中的 dp[119]，dp[118]，dp[115] 我们继续用这种思想去分解，
    这就是动态规划了，把这种思想，思考问题的方式理解了，这一类型的题目
    问题都不会太大。
```

```js
var coinChange = function(coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity)
  dp[0] = 0
  for(let i = 1; i <= amount; i++) {
    for(let coin of coins) {
      if(i - coin >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1)
      }
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]
};
```

时间复杂度:`O(m * n)`   `m` `n`分别为金额总数和硬币种数

空间复杂度:`O(m)`

## lc53. 最大子数组和

:::tip 题目描述

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

 :::

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

> 思路

状态转移方程`f(i)=max{f(i−1)+nums[i],nums[i]}`

降低空间复杂度用`pre`保存上一个最大连续数组的和

```js
var maxSubArray = function(nums) {
  if(!nums.length) return 0
  let sum = nums[0]
  let pre = 0
  for(let i = 0; i < nums.length; i++) {
    pre = Math.max(pre + nums[i], nums[i])
    sum = Math.max(sum, pre)
  }
  return sum
};
```

#### lc70. 爬楼梯

:::tip 题目描述

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

:::

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

> 思路

状态转移方程：`dp[i] = dp[i - 1] + dp[i - 2]`

```js
var climbStairs = function(n) {
  const dp = []
  dp[1] = 1
  dp[2] = 2
  for(let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
};
```

时间复杂度:`O(n)`

空间复杂度:`O(n)`

## lc121. 买卖股票的最佳时机 I

:::tip 题目描述

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

::: 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

> 思路一

设置一个变量存放最小的值，一个变量存放求和的值

```js
var maxProfit = function(prices) {
  if(!prices.length) return 0
  let min = prices[0]
  let sum = 0
  for(let i = 1; i < prices.length; i++) {
    if(prices[i] < min) min = prices[i]
    if(prices[i] - min > sum) sum = prices[i] - min
  }
  return sum
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

> 思路二：动态规划

对于这道题，我们可以使用**动态规划**来解决。这里我们只需要进行一次买入卖出。那到最后交易时，可能会有三种状态：

- `dp[0]`：一直没有买
- `dp[1]`：：到最后只买了一笔，未卖出
- `dp[2]`：：到最后只卖了一笔，并卖出

由于第一种状态未进行任何操作，所以可以不用记录。然后我们对后两种状态进行转移：

- `dp[1] = Math.min(dp[1], prices[i])`：前一天也是`b1`状态或者是没有任何操作，今天买入一笔变成b1状态；
- `dp[2] = Math.max(dp[2], prices[i] - dp[1])`：前一天也是`s1`状态或者是`b1`状态，今天卖出一笔变成`s1`状态；

```js
var maxProfit = function(prices) {
  if(!prices.length) return 0
  let dp = [0, prices[0], 0]
  for(let i = 1; i < prices.length; i++) {
    dp[1] = Math.min(dp[1], prices[i])
    dp[2] = Math.max(dp[2], prices[i] - dp[1])
  }
  return dp[2]
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

## lc122. 买卖股票的最佳时机 II

:::tip 题目描述

给定一个数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 :::

**示例 1:**

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

> 思路一

跟上题的思路一相仿，这题显得更简单，只有当天比前一天的金额高利润就加上他们的差价

```js
var maxProfit = function(prices) {
  let res = 0
  for(let i = 1; i < prices.length; i++) {
    if(prices[i] > prices[i - 1]) {
      res += (prices[i] - prices[i - 1])
    }
  }
  return res
};
```

时间复杂度:`O(n)`

空间复杂度:`O(1)`

> 思路

对于这道题目，我们可以使用**动态规划**来解答。每个点的状态描述：手里有股票或者没股票。

1. `dp[i][0]`表示：第 `i` 天手里没股票，至今（第 `i` 天）的最大收益。第 `i` 天手里没股票，有两种可能：

- 昨天也没持有股票：`dp[i-1][0]`
- 昨天买了股票，今天卖了: `dp[i-1][1] + prices[i]`(注意⚠️`dp[i - 1][1]`是负数，所以这里是加)
- `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`

2. `dp[i][1]`表示：第 `i` 天手里有股票，至今（第 `i` 天）的最大收益。第 `i` 天手里有股票，有两种可能：

- 昨天也有股票：`dp[i-1][1]`
- 昨天卖了，今天买了: `dp[i-1][0] - prices[i]`
- `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`

最终目标是求出：`dp[prices.length-1][0]`和`dp[prices.length-1][1]`的较大者，前者肯定>=后者，求`dp[prices.length-1][0]`即可。

**对于开始：**

- `day 0` 没买:`dp[0][0] = 0`
- `day 0` 买了:`dp[0][1] = -prices[0]`

```js
function maxProfit(prices) {
  const len = prices.length;
  if (len < 2) {
    return 0;
  };
  const dp = new Array(len);
  dp[0] = [0, -prices[0]];
  for (let i = 1; i < len; i++) {
    dp[i] = new Array(2);
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); // 没有股票
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 有股票
  }
  return dp[len - 1][0];
}
```

- **时间复杂度：** `O(n)`，其中 `n` 为数组的长度。一共有 `2n` 个状态，每次状态转移的时间复杂度为 `O(1)`，因此时间复杂度为 `O(2n)=O(n)`。
- **空间复杂度**：`O(n)`，我们需要开辟`O(n)` 空间存储动态规划中的所有状态。

