---
title: 原型和原型链
date: 2021-11-28 10:03:41
permalink: /pages/e98c4e/
---
# 原型与原型链

::: note 概念
在`js`内部使用构造函数来新建一个对象，每一个构造函数里面都有一个`prototype`属性，他的值是一个对象，包含了由该构造函数的所有实例共享属性和方法，当使用构造函数新建一个对象时。对象内部将包含指针 指向构造函数的`prototype`属性对应的值，获取`prototype`可以用`Object.getPrototypeOf()`
:::


## 原型修改和重写致`constructor`丢失

```javascript
function Person(name) {
	this.name = name
}

// 修改原型
Person.prototype.getName = function() {}
var p = new Person('Hello')
console.log(p.__proto__ === Person.prototype) // true 最终都指向Object
console.log(p.__proto__ ==== p.constructor.prototype) // true p的constructor是Person 因此为true

// 重写原型
Person.prototype = {
	getName: function() {}
}

var p = new Person('Hello')
// p.constructor = Person 这里指回来
console.log(p.__proto__ === Person.prototype) // true 最终都指向Object
console.log(p.__proto__ ==== p.constructor.prototype) // false 给Person的原型对象用对象赋值是，构造函数指向了根构造函数Object 想变成true就得指回来 
```

## 原型继承的几种方式

- 原型链继承

```javascript
function Parent() {
  this.name = 'crucials'
}

Parent.prototype.getName = function() {
  return this.name;
}

function Child() {}

// 这里也可以直接写出Child.prototype = Parent.prototype
// 但是这样就不能访问到父类的构造函数的属性了，即this.name
Child.prototype = new Parent()

var child = new Child()
child.getName() // crucials
// 优点：逻辑简单
// 父类构造函数中的引用类型（比如对象/数组），会被所有子类实例共享。
// 其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变
```

- 构造函数继承

```javascript
function Parent() {
  this.name = ['crucials']
}

function Child() {
  Parent.call(this)
}

var child = new Child()
child.name.push('fe')

var child2 = new Child() // child2.name === ['crucials']
// 优点：解决了原型链继承中构造函数引用类型共享的问题，同时可以向构造函数传参（通过call传参）
// 缺点：所有方法都定义在构造函数中，每次都需要重新创建（对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法）
```

- 组合继承

```javascript
function Parent() {
  this.name = 'crucials'
}

Parent.prototype.getName = function() {
  return this.name
}

function Child() {
  Parent.call(this)
  this.topic = 'fe'
}

Child.prototype = new Parent()
// 需要重新设置子类的constructor，Child.prototype = new Parent()相当于子类的原型对象完全被覆盖了
Child.prototype.constructor = Child

// 优点：同时解决了构造函数引用类型的问题，同时避免了方法会被创建多次的问题
// 缺点：父类构造函数被调用了两次。同时子类实例以及子类原型对象上都会存在name属性。虽然根据原型链机制，并不会访问到原型对象上的同名属性，但总归是不美。
```

- 寄生组合继承

```javascript
function Parent() {
	this.name = 'crucials'
}
Parent.prototype.getName = function () {
	return this.name
}
function Child() {
	Parent.call(this)
}
Child.prototype = Object.create(Parent.prototype)//核心代码
Child.prototype.constructor = Child//核心代码
var s1 = new Child()
console.log(s1 instanceof Child, s1 instanceof Parent) // true true
console.log(s1.constructor) //Child

// 解决上面全部缺点
// 暂时无缺点
```

- ES6

```javascript
class Parent {
  constructor() {
    this.name = 'crucials'
  }

  getName() {
    return this.name
  }
}

class Child extends Parent {
  constructor() {
    // 这里很重要，如果在this.topic = 'fe'后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明
    super()
    this.topic = 'fe'
  }
}

const child = new Child()
child.getName() // crucials
```

## 原型链的终点是什么

`Object.prototype.__proto__ = null`

## 如何获得对象非原型链上的属性

使用`obj.hasOwnProperty(key)`

