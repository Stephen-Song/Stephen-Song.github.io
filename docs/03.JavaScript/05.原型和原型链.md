---
title: 原型和原型链
date: 2021-11-28 10:03:41
permalink: /pages/e98c4e/
---
## 原型与原型链<badge text="特别重要" type="error" />

::: note 概念
在`js`内部使用构造函数来新建一个对象，每一个构造函数里面都有一个`prototype`属性，他的值是一个对象，包含了由该构造函数的所有实例共享属性和方法，当使用构造函数新建一个对象时。对象内部将包含指针 指向构造函数的`prototype`属性对应的值，获取`prototype`可以用`Object.getPrototypeOf()`
:::


## 原型修改和重写致`constructor`丢失

```javascript
function Person(name) {
	this.name = name
}

// 修改原型
Person.prototype.getName = function() {}
var p = new Person('Hello')
console.log(p.__proto__ === Person.prototype) // true 最终都指向Object
console.log(p.__proto__ ==== p.constructor.prototype) // true p的constructor是Person 因此为true

// 重写原型
Person.prototype = {
	getName: function() {}
}

var p = new Person('Hello')
// p.constructor = Person 这里指回来
console.log(p.__proto__ === Person.prototype) // true 最终都指向Object
console.log(p.__proto__ ==== p.constructor.prototype) // false 给Person的原型对象用对象赋值是，构造函数指向了根构造函数Object 想变成true就得指回来 
```

## 继承的几种方式<badge text="特别重要" type="error" />

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201051637255.png)

- 原型链继承

```javascript
function Parent() {
  this.name = 'crucials'
}

Parent.prototype.getName = function() {
  return this.name;
}

function Child() {}

// 这里也可以直接写出Child.prototype = Parent.prototype
// 但是这样就不能访问到父类的构造函数的属性了，即this.name
Child.prototype = new Parent()

var child = new Child()
child.getName() // crucials
// 优点：逻辑简单
// 父类构造函数中的引用类型（比如对象/数组），会被所有子类实例共享。
// 其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变
```

- 构造函数继承

```javascript
function Parent() {
  this.name = ['crucials']
}

function Child() {
  Parent.call(this)
}

var child = new Child()
child.name.push('fe')

var child2 = new Child() // child2.name === ['crucials']
// 优点：解决了原型链继承中构造函数引用类型共享的问题，同时可以向构造函数传参（通过call传参）
// 缺点：所有方法都定义在构造函数中，每次都需要重新创建（对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法）
```

- 组合继承

```javascript
function Parent() {
  this.name = 'crucials'
}

Parent.prototype.getName = function() {
  return this.name
}

function Child() {
  Parent.call(this)
  this.topic = 'fe'
}

Child.prototype = new Parent()
// 需要重新设置子类的constructor，Child.prototype = new Parent()相当于子类的原型对象完全被覆盖了
Child.prototype.constructor = Child

// 优点：同时解决了构造函数引用类型的问题，同时避免了方法会被创建多次的问题
// 缺点：父类构造函数被调用了两次。同时子类实例以及子类原型对象上都会存在name属性。虽然根据原型链机制，并不会访问到原型对象上的同名属性，但总归是不美。
// 具体是Parent.call调用了一次父类构造函数，Child.prototype = new Parent()又调用了一次父类构造函数
```

- 寄生组合继承

```javascript
function Parent() {
	this.name = 'crucials'
}
Parent.prototype.getName = function () {
	return this.name
}
function Child() {
	Parent.call(this)
}
Child.prototype = Object.create(Parent.prototype)//核心代码
Child.prototype.constructor = Child//核心代码
var s1 = new Child()
console.log(s1 instanceof Child, s1 instanceof Parent) // true true
console.log(s1.constructor) //Child

// 解决上面全部缺点
// 暂时无缺点
```

::: warning 问题1传入的为什么是Parent.prototype而不是Parent，问题2为什么Object.create可以不二次调用自身实例上方法

问题一先参考一下[Object.create的实现](/pages/ba01c4/#object-create)，然后会发现他是创建了一个函数，往函数的原型上面添加传入的对象，假如传入的是`Parent`的话他是一个函数，而`prototype`是对象，自然会出现奇奇怪怪的错误导致访问不到原型上面的属性，解决了问题一

而问题二`Object.create`不会调用父类构造函数是因为他只继承`prototype`，并没有调用构造函数，相反[new](/pages/ba01c4/#new操作符)他在改变`this`之后还会执行一下构造函数，问题二解决

:::

- `ES6`

```javascript
class Parent {
  constructor() {
    super()
    this.name = 'crucials'
  }

  getName() {
    return this.name
  }
}

class Child extends Parent {
  constructor() {
    // 这里很重要，如果在this.topic = 'fe'后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明
    super()
    this.topic = 'fe'
  }
}

const child = new Child()
child.getName() // crucials
//注意es6的class可以看成是上面栗子中是parent.call(this, value)
```

## 原型链的终点是什么

`Object.prototype.__proto__ = null`

## 如何获得对象非原型链上的属性

使用`obj.hasOwnProperty(key)`

## `ES5`的继承和`ES6`的继承有什么区别？<badge text="重要" type="warning" />

`ES5`的继承时通过`prototype`或构造函数机制来实现。**`ES5`的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到`this`上**`（Parent.apply(this)）`。

`ES6`的继承机制完全不同，**实质上是先创建父类的实例对象`this`（所以必须先调用父类的`super()`方法），然后再用子类的构造函数修改`this`**。

具体的：`ES6`通过`class`关键字定义类，里面有构造方法，类之间通过`extends`关键字实现继承。子类必须在`constructor`方法中调用`super`方法，否则新建实例报错。因为子类没有自己的`this`对象，而是继承了父类的`this`对象，然后对其进行加工。如果不调用`super`方法，子类得不到`this`对象。

:::warning 值得注意的是

`super`关键字指代父类的实例，即父类的`this`对象。在子类构造函数中，调用`super`后，才可使用`this`关键字，否则报错。

:::
