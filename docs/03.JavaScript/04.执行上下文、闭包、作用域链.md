---
title:  执行上下文/ 闭包/ 作用域链
date: 2021-11-28 10:05:03
permalink: /pages/4a6f6a/
---

# 执行上下文/ 闭包/ 作用域链

## 介绍一下闭包
::: tip 概念
闭包是指有权访问另一个函数作用域里面的函数，举个栗子就是在一个函数`a`创建另一个函数`b` `b`可以访问到`a`的局部变量
:::
用途：

- 通过闭包，可以在外部调用闭包函数 从而从外部调用函数内部的变量，创建私有变量


- 闭包另一个用途是使已经运行结束的函数上下文的变量对象继续留在内存中，因为闭包保留这个变量对象对象的引用，不会被回收



## 对作用域 作用域链的理解

-  全局作用域

    - 最外层函数及外面定义的变量拥有全局作用域
    - 未定义直接赋值的变量拥有全局作用域
    - 所有`window`对象属性拥有全局作用域
    - 会污染全局命名空间，引起命名冲突

-  函数作用域

    - 函数作用域声明在函数内部，一般只有固定代码片段可以访问到
    - 内层作用域可以访问到外层，反之不行

- 块级作用域

    - `let` `const`可以声明块级作用域 可以在函数也可以在`{}`里面
    - 循环中适合绑定块级作用域 可以将声明的计数器变量限制在循环内部

**作用域链是 在当前作用域查找所需的变量，如果在自己的作用域找不到该变量就去父级作用域查找，依次像上级作用域查找，知道访问到window对象终止，这一层层关系就是作用域链**

::: warning 作用域链的作用是 
保证对执行环境有权访问的所有变量和函数的有序访问 ，通过作用域可以访问到外层环境的函数或变量
:::


## 对执行上下文的理解

- **全局上下文**

    - 任何不在函数内部的都是全局执行上下文 会首先创建一个全局的`window`对象，并设置`this`等于全局对象

- **函数执行上下文**

    - 当一个函数被调用 会为这个函数创建一个新的执行上下文

- **`eval`函数上下文**
    - 执行`eval`函数代码会有属于他的执行上下文
    
- **执行上下文栈**

    - 用来管理执行上下文 程序执行时，遇到全局代码，会创建一个全局执行上下文并压入执行栈中，每遇到一个函数调用 会为该函数创建一个新的执行上下文并压入栈顶，当执行完执行上下文从栈顶弹出，继续下一个函数，最后执行完会从栈中弹出全局上下文



## 并行和并发的区别

- 并发是**宏观概念**，我分别有任务 `A` 和任务 `B`，在一段时间内通过任务间的切换完成了这两个任务，称之为并发。
- 并行是**微观概念**，假设 `CPU` 中存在两个核心，那么我就可以同时完成任务 `A`、`B`。同时完成多个任务的情况就可以称之为并行。



## 浏览器的垃圾回收机制

::: theorem 概念
`js`代码运行时 需要分配内存来存储变量和值 当变量不参与运行时就需要系统回收被占用的内存空间
:::
>**垃圾回收的方式**：

- **<mark>标记清除</mark>** 当变量进入执行环境的时候，会被标记"进入环境"，内存不能被回收，因为正在被使用，当变量离开环境的时候，会被标记离开环境，系统会释放该内存

    - 垃圾回收器的作用是给所有变量都加上标记，然后去除那些被使用的变量的标记，在此之后被加上标记的都是准备删除的变量

- **<mark>引用计数</mark>** 简单的来说但变量的引用次数为`0`的时候就会被销毁，内存被释放
- 但是当有循环引用的时候就不会被释放 需要手动设置释放内存`xxx = null`

>**减少垃圾回收**

**当代码很复杂的时候，垃圾回收带来的代价比较大，我们应该尽量减少垃圾回收**

- 对数组进行优化：最简单的方法是赋值为`[]`，但是同时会创建一个新的空对象，所以我们可以把数组的长度设为`0`

- 对`Object`进行优化：对象尽量复用，对不使用的对象，将其设置为`null`

- 对函数的优化：在循环的函数表达式中，如果可以复用，就尽量放在函数外面

>**哪些会导致内存泄露**

- 意外的全局变量：使用未声明的变量会变成全局变量
- 被遗忘的计数器
- 闭包
- 脱离`DOM`的引用：获取`DOM`元素的引用，后面这个元素被删除，由于一直保留这个元素的引用，无法被回收
- 循环引用
- 控制台日志(console.log)