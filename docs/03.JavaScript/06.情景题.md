---
title: 情景题
date: 2022-02-26 10:59:12
permalink: /pages/1ae607/
---

# 情景题

## 当在浏览器输入`google.com`回车之后会发生什么<badge text="本博客最重要的一个问题" type="error" />

![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201081153220.png)

1. 在回车之前，还会执行一次当前页面的`beforeunload`事件，可以让页面退出之前执行一些数据清理工作，或者，有表单没有提交的情况提示用户是否确认离开

2. **解析`URL`** 对`URL`进行解析，分析所用的**传输协议**  **域名** **端口**  **资源路径**，如果不合法，就传递给**搜索引擎**，如果没问题，浏览器检查`URL`是否出现非法字符，若有则进行转义

3. **缓存判断** 判断资源是否存在缓存中，若在缓存且没有失效，就直接使用，否则向服务器发起新请求

   :::note 这里的缓存主要指的是

   - 如果是`https`的话，有可能先找`Service Worker`，比如你设置了请求拦截，离线缓存的话
   - 如果没有，再找浏览器的**内存缓存**（`Memory Cache`)
   - 如果还没有，再找**硬盘缓存**（`Disk Cache`）（ 强缓存和协商缓存都属于硬盘缓存）
   - 如果这三种都没有找到，请求还是`http2`的话，还可能会查找**推送缓存**（`Push Cache`)，就是找`Session`（`Session`会话结束就会释放，所以存在时间很短）

   :::

4. **`DNS`解析** 获取`URL`中的域名的`ip`地址，会判断本地是否有该域名的`ip`地址的缓存，有则使用，没有向本地`dns`服务器请求本地的`dns`服务器也会检查是否存在缓存，如果没有先向根域名服务器发起请求，获得负责的顶级域名服务器的地址再请求，然后获得负责的权威域名服务器的地址再请求，最终获得域名的`ip`地址，本地`dns`服务器再向返回给请求的用户(用户向本地`dns`服务器发起请求是递归请求，本地`dns`向各级域名服务器发起的请求是迭代请求)

   :::warning 值得注意的是

   - 如果没有配置`CDN`，就直接返回解析到的`IP`
   - 如果有配置`CDN`，权威域名会返回一个[CName](/pages/f15087/#cdn工作原理)别名记录，它指向`CDN`网络中的智能`DNS`负载均衡系统，然后负载均衡系统通过智能算法，将最佳`CDN`节点的`IP`返回

   :::

5. **获取`MAC`地址** 当浏览器得到`ip`地址时，数据传输还得知道`mac`地址，数据是从**应用层**下发到**传输层**，`tcp`会指定**源端口号**和**目的端口号**，然后下发给网络层，网络层将本地`ip`作为源地址，获取的`ip`作为目的`ip`，然后下发给数据链路层，数据链路层要加入通信双方的`mac`地址，本地`mac`作为源`mac`地址，目的`mac`地址分情况处理，通过`ip`地址与本地子网掩码相与，判断是否和请求主机处于同一个子网，如果在同一子网，用`ARP`协议获得目的主机的`mac`地址，如果不在，请求转发给网关，由他来转发，此时同样可以通过`arp`协议获得网关的`mac`地址，此时目的主机的`mac`地址为网关的地址

6. **TCP三次握手** 下面是 `TCP` 建立连接的三次握手的过程。

   - 首先客户端向服务器发送一个 `SYN `连接请求报文段和一个随机序号

   - 服务端接收到请求后向客户端发送一个 `SYN ACK`报文段，确认连接请求，并且也向客户端发送一个随机序号。
   - 客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个`ACK `确认报文段
   - 服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了

7. **HTTPS握手** 通信还存在`TLS`的四次挥手

   - 首先客户端向服务端发送**协议的版本号**、**一个随机数**和可以使用的**加密方法**

   - 服务器收到后确认加密方法，向客户端发送一个**随机数**和**自己的数字证书**
   - 客户端收到后检查数字证书是否有效，有效的话再生成一个**随机数**，使用证书的公钥对**随机数加密** 然后发给服务端，并且会提供一个**前面所有内容的`hash`值给服务器检验**
   - 服务器接收后用私钥对**数据解密**，同时**向客户端发送一个前面所有内容的hash值供客户端检验**，双方这时有三个随机数，按之前的加密方法，使用**这三个随机数生成一把密钥**，以后双方传输数据时用这个密钥加密再传输

8. **返回数据** 当页面请求发到服务端，服务端会返回一个`html`文件作为响应，浏览器接到响应 对`html`进行解析，开始页面渲染

9. **TCP四次挥手** 最后一步是` TCP` 断开连接的四次挥手过程。

   - 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。
   - 服务端收到连接释放请求后，会告诉应用层要释放` TCP` 链接。然后会发送 `ACK` 包，并进入 `CLOSE_WAIT` 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。**但是因为 `TCP `连接是双向的，所以服务端仍旧可以发送数据给客户端。**
   - 服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 `LAST-ACK` 状态
   - 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 `TIME-WAIT `状态。该状态会持续 `2MSL`（<mark>最大段生存期，指报文段在网络中生存的时间，超时会被抛弃</mark>） 时间，若该时间段内没有服务端的重发请求的话，就进入` CLOSED` 状态。
   - 当服务端收到确认应答后，也便进入 `CLOSED` 状态。

10. **解析响应数据**

    如果返回的状态码是`301`或`302`就需要`重定向`到其他`URL`，在重定向地址会在响应头的`Location`字段中，然后一切从头开始，否则然后根据情况选择关闭`TCP`连接或者保留重用

    然后网络线程会通过`SafeBrowsing`来检查站点是不是恶意站点，如果是就展示警告页面，告诉你这个站点有安全问题，浏览器会阻止访问，当然也可以强行继续访问。喜欢看岛国小电影的人应该遇到过很多次这种情况

    > **`SafeBrowsing`** 是谷歌内部的一套站点安全系统，通过检查该站点的数据来判断是不是安全，比如通过查看该站点的`IP`有没有在谷歌黑名单中，如果是`Chrome`浏览器的话

    响应成功返回状态码`2xx`，然后判断资源能不能缓存，如果可以就`先缓存`起来

    然后对响应解码，比如`gzip压缩`，然后根据资源类型(`Content-Type`)决定如何处理，如果浏览器判断是下载文件，那么请求会被提交给浏览器的`下载管理器`，同时`URL`请求流程就结束了

    否则网络线程会通知`UI`线程，然后`UI`线程会创建一个渲染器进程来准备渲染页面

    然后浏览器进程通过`IPC`管道将数据传给渲染器进程的主线程，准备`渲染流程`

    > 默认情况下会为每一个标签页配置一个渲染进程，但是也有例外，比如从`A`页面里面打开一个新的页面`B`页面，而`A`页面和`B`页面又属于同一站点的话，`A`和`B`就共用一个渲染进程，其他情况就为`B`创建一个新的渲染进程

    渲染进程收到确认消息后，会和网络进程建立传输数据的管道，开始执行解析数据、下载资源等

    **为什么进入新页面，之前的页面不会立马消失，而是要加载一会才会更新的原因**

    - 因为这时候的旧的文档还在网络进程中，渲染进程准备好了之后，渲染进程会向浏览器进程发出提交文档的消息
    - 浏览器进程收到后会开始清理当前的旧页面的文档，然后发出确认消息给渲染进程，同时浏览器更新浏览器界面(安全状态、`URL`、前进后退历史状态)并更新页面（此时是空白页）

11. **页面渲染** 

    ![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201081158120.png)

    - 渲染进程将 `HTML` 内容转换为能够读懂 `DOM` 树结构。

    - 渲染引擎将 `CSS` 样式表转化为浏览器可以理解的 `styleSheets`，计算出 `DOM` 节点的样式。

    - 创建布局树，并计算元素的布局信息。

    - 对布局树进行分层，并生成分层树。

    - 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。

    - 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上

      :::note 笔记

      其中的构建`dom`树的过程如下

      - 转码（`Bytes -> Characters`）—— 读取接收到的 `HTML` 二进制数据，按指定编码格式将字节转换为 `HTML` 字符串
      - `Tokens` 化（`Characters -> Tokens`）—— 解析 `HTML`，将 `HTML` 字符串转换为结构清晰的 `Tokens`，每个 `Token` 都有特殊的含义同时有自己的一套规则
      - 构建 `Nodes`（`Tokens -> Nodes`）—— 每个 `Node` 都添加特定的属性（或属性访问器）也叫词法分析：将`token`转换为对象并定义属性和规则，通过指针能够确定 `Node` 的父、子、兄弟关系和所属 `treeScope`（例如：`iframe` 的 `treeScope` 与外层页面的 `treeScope` 不同）
      - 构建 `DOM` 树（`Nodes -> DOM Tree`）—— 最重要的工作是建立起每个结点的父子兄弟关系(解析器会维护一个解析栈，栈底为`document`，也就是`DOM`树的根节点,然后根据节点对象关系按顺序依次向解析栈添加，`形成DOM树`)

      ![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202280936284.png)

      > `DOM`树 和 渲染树 的区别：

      - `DOM`树与`HTML`标签一一对应，包括`head`和隐藏元素
      - 渲染树不包括`head`和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的`css`属性

      样式计算

      渲染引擎将 `CSS` 样式表转化为浏览器可以理解的 `styleSheets`，计算出 `DOM` 节点的样式。

      :::warning 值得注意的是

      `CSS`解析和`DOM`解析是可以同时进行的，但是`script`执行和`CSS`解析不能同时进行，`CSS`会阻塞`JS`执行

      因为`JS`执行时可能在文档的解析过程中 获取样式信息，如果样式信息没有加载和解析完毕，`JS`就会得到错误的值，所以会延迟`JS`执行

      :::

      > `CSS` 样式来源主要有 `3` 种，分别是通过 `link` 引用的外部 `CSS` 文件、`style`标签内的 `CSS`、元素的 `style` 属性内嵌的 `CSS`。

      页面布局

      > 布局过程，即`排除 script、meta 等功能化、非视觉节点`，排除 `display: none` 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图

      ![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201081203608.png)

      **生成分层树**

      > 页面中有很多复杂的效果，如一些复杂的 `3D` 变换、页面滚动，或者使用 `z-index` 做 `z` 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（`LayerTree`）

      :::note 具体

      -  拥有层叠上下文属性的元素，比如：

      - `html`
      - `z-index`不为`auto`
      - `position:fixed`
      - `opacity`小于`1`
      - `transform`不为`none`
      - `filter不为none`
      - `-webkit-overflow-scrolling：touch`

      - 有`裁剪`的地方，比如内容溢出裁剪
      - 不裁剪出现滚动条的话，`滚动条`也会被提升为单独的层

      :::

      **栅格化**

      > 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将**图块转换为位图**

      ![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202201081205799.png)

      通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（`viewport`）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

      

      另外渲染引擎还维护了一个**栅格化(光栅化)线程**，合成线程将分割好的图块发送给`栅格化线程`，然后分别栅格化每个图块，再将栅格化之后的图块存储在`GPU内存`中

      合成器线程能够对不同的栅格化线程做优先处理，所以出现在视口内的图块会被**优先栅格化**

      ![](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202280945979.awebp)

12. **合成和显示**：当图块都被栅格化完成后，合成线程会收集栅格化线程的`draw quads`图块信息，该信息记录了图块在内存中的位置信息和图块在页面中的位置信息

    根据这些信息，合成器线程生成一个合成器帧，然后通过`IPC`传给浏览器进程

    浏览器进程里有个叫 `viz` 的组件，用来接收这个合成器帧

    然后浏览器进程再将合成器帧绘制到显存中，再通过 `GPU` 渲染在屏幕上，这时候终于看到了页面内容

    当屏幕内容发生变化，比如滚动了页面，合成器线程就会将栅格化好的层合成一个新的合成器帧，新的帧再传到显存，`GPU` 再渲染到页面上

    :::note 延伸

    **这里可以问到`transform`不用重排，不会导致卡顿的原因**

    刚才的流程我们知道栅格化的整个流程是不占用主线程的，只在合成器线程和栅格线程中运行

    这就意味着它不用`JS`抢主线程，刚才提到反复重绘和重排会导致掉帧，是因为`JS`阻塞了主线程，而通过`CSS`中的动画属性`transform`实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程中，所以不会受到主线程`JS`执行的影响

    更重要的是**通过`transform`实现的动画由于不需要经过布局和绘制，样式计算等操作**，所以节省了很多运算时间

    :::

13. **`JS`引擎解析过程**：调用`JS`引擎执行`JS`代码（`JS`的解释阶段，预处理阶段，执行阶段生成执行上下文，`VO`，作用域链、回收机制等等）

    - 创建`window`对象：`window`对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于`window`的属性和方法，而`DOM Tree`也会映射在`window`的`doucment`对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。
    - 加载文件：完成`js`引擎分析它的语法与词法是否合法，如果合法进入预编译
    - 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为`window`的属性加入到`window`对象中，并给变量赋值为`'undefined'`；寻找全局函数声明，把它作为`window`的方法加入到`window`对象中，并将函数体赋值给他（**匿名函数是不参与预编译的，因为它是变量**）。而变量提升作为不合理的地方在`ES6`中已经解决了，函数提升还存在。
    - 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在`ES5`非严格模式下这个变量会成为`window`的一个属性，也就是成为全局变量。`string`、`int`这样的值就是直接把值放在变量的存储空间里，`object`对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。`JS`作用域其实就是这样的执行流机制实现的。

## 扫码登陆流程

![image-20220226105933315](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202261059558.png)

**问：假设扫码途中`QRCode`刷新了怎么办？**

可以在`PC`端新增状态，已扫码待确认，来阻止轮询超时重新获取二维码

**问：`PC`怎么根据二维码进行响应**

`PC`端可以通过获取二维码的状态来进行相应的响应：

- 二维码`未扫描`：无操作
- 二维码`已失效`：提示刷新二维码
- 二维码`已成功`：从服务端获取`PC token`

**问：可以用长轮询嘛 `ws`呢**

可以。长轮询是指客户端主动给服务端发送二维码状态的查询请求，服务端会按情况对请求进行阻塞，直至二维码信息更新或超时。当客户端接收到返回结果后，若二维码仍未被扫描，则会继续发送查询请求，直至状态变化（已失效或已成功）

![长轮询](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202261108821.awebp)

`Websocket`是指前端在生成二维码后，会与后端建立连接，一旦后端发现二维码状态变化，可直接通过建立的连接主动推送信息给前端。

![Websocket](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202261108891.awebp)

## 为什么通常在发送数据埋点请求的时候使用的是 `1x1` 像素的透明 `gif` 图片<badge text="重要" type="warning" />

- 能够完成整个 `HTTP` 请求+响应（尽管不需要响应内容）
- 触发 `GET` 请求之后不需要获取和处理数据、服务器也不需要发送数据
- 跨域友好
- 执行过程无阻塞
- 相比 `XMLHttpRequest` 对象发送 `GET` 请求，性能上更好
- `GIF`的最低合法体积最小（最小的`BMP`文件需要`74`个字节，`PNG`需要`67`个字节，而合法的`GIF`，只需要`43`个字节）

**为什么不能用请求其他文件资源(`js/css/ttf`)的方式进行上报呢**

创建资源节点后只有将对象注入到浏览器`DOM`树后，浏览器才会实际发送资源请求。而且载入`js/css`资源还会阻塞页面渲染，影响用户体验。

构造图片打点不仅不用插入`DOM`，只要在`js`中`new`出`Image`对象就能发起请求，而且还没有阻塞问题，在没有`js`的浏览器环境中也能通过`img`标签正常打点。

**同样都是图片，上报时选用了`1x1`的透明`GIF`，而不是其他的`PNG/JEPG/BMP`文件**

首先，`1x1`像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。因为需要透明色，所以可以直接排除`JEPG`。

同样的响应，`GIF`可以比`BMP`节约`41%`的流量，比`PNG`节约`35%`的流量。`GIF`才是最佳选择。

- 可以进行跨域
- 不会携带`cookie`
- 不需要等待服务器返回数据

## 简单描述一下 `Babel` 的编译过程<badge text="特别重要" type="error" />

:::tip 概念

`Babel` 是一个 `JavaScript` 编译器，是一个工具链，主要用于将采用 `ECMAScript 2015+` 语法编写的代码转换为向后兼容的 `JavaScript` 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

:::

`Babel` 本质上就是在操作 `AST` 来完成代码的转译。AST是抽象语法树（`Abstract Syntax Tree, AST`）

`Babel` 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：

1. **解析（`Parse`）** ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（`Char Stream`）转换成令牌流（ `Token Stream`），语法分析主要是将令牌流转换成抽象语法树`（Abstract Syntax Tree，AST）`。
2. **转换（`Transform`）** ：通过 `Babel` 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 `AST` 转换成支持低版本语法的 `AST`。让它符合编译器的期望，当然在此过程中也可以对 `AST` 的 `Node` 节点进行优化操作，比如添加、更新以及移除节点等。
3. **生成（`Generate`）** ：将 `AST` 转换成字符串形式的低版本代码，同时也能创建 `Source Map` 映射。

经过这三个阶段，代码就被 `Babel` 转译成功了。

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202051701131.awebp) ![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202051701937.awebp)

## 列举一下有哪些捕获/监控错误的方式<badge text="特别重要" type="error" />

**`try/catch`**

> 能捕获常规运行时错误，语法错误和异步错误不行

```javascript
// 常规运行时错误，可以捕获 ✅
try {
  console.log(notdefined);
} catch(e) {
  console.log('捕获到异常：', e);
}

// 语法错误，不能捕获 ❌
try {
  const notdefined,
} catch(e) {
  console.log('捕获到异常：', e);
}

// 异步错误，不能捕获 ❌
try {
  setTimeout(() => {
    console.log(notdefined);
  }, 0)
} catch(e) {
  console.log('捕获到异常：',e);
}
```

**`window.onerror`**

> `pure js`错误收集，`window.onerror`，当 `JS` 运行时错误发生时，`window` 会触发一个 `ErrorEvent` 接口的 `error` 事件。

```javascript
/**
* @param {String}  message    错误信息
* @param {String}  source    出错文件
* @param {Number}  lineno    行号
* @param {Number}  colno    列号
* @param {Object}  error  Error对象
*/

window.onerror = function(message, source, lineno, colno, error) {
   console.log('捕获到异常：', {message, source, lineno, colno, error});
}
```

先验证下几个错误是否可以捕获。

```javascript
// 常规运行时错误，可以捕获 ✅

window.onerror = function(message, source, lineno, colno, error) {
  console.log('捕获到异常：',{message, source, lineno, colno, error});
}
console.log(notdefined);

// 语法错误，不能捕获 ❌
window.onerror = function(message, source, lineno, colno, error) {
  console.log('捕获到异常：',{message, source, lineno, colno, error});
}
const notdefined,
      
// 异步错误，可以捕获 ✅
window.onerror = function(message, source, lineno, colno, error) {
  console.log('捕获到异常：',{message, source, lineno, colno, error});
}
setTimeout(() => {
  console.log(notdefined);
}, 0)

// 资源错误，不能捕获 ❌
<script>
  window.onerror = function(message, source, lineno, colno, error) {
  console.log('捕获到异常：',{message, source, lineno, colno, error});
  return true;
}
</script>
<img src="https://yun.tuia.cn/image/kkk.png">
```

**`window.addEventListener`**

> 当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 `Event` 接口的 `error` 事件，这些 `error` 事件不会向上冒泡到 `window`，但能被捕获。而`window.onerror`不能监测捕获。

```html
// 图片、script、css加载错误，都能被捕获 ✅
<script>
  window.addEventListener('error', (error) => {
     console.log('捕获到异常：', error);
  }, true)
</script>
<img src="https://yun.tuia.cn/image/kkk.png">
<script src="https://yun.tuia.cn/foundnull.js"></script>
<link href="https://yun.tuia.cn/foundnull.css" rel="stylesheet"/>
  
// new Image错误，不能捕获 ❌
<script>
  window.addEventListener('error', (error) => {
    console.log('捕获到异常：', error);
  }, true)
</script>
<script>
  new Image().src = 'https://yun.tuia.cn/image/lll.png'
</script>

// fetch错误，不能捕获 ❌
<script>
  window.addEventListener('error', (error) => {
    console.log('捕获到异常：', error);
  }, true)
</script>
<script>
  fetch('https://tuia.cn/test')
</script>
```

`new Image`运用的比较少，可以单独自己处理自己的错误。

但通用的`fetch`怎么办呢，`fetch`返回`Promise`，但`Promise`的错误不能被捕获，怎么办呢？

**`Promise`错误**

1. 普通`Promise`错误

> `try/catch`不能捕获`Promise`中的错误

```javascript
// try/catch 不能处理 JSON.parse 的错误，因为它在 Promise 中
try {
  new Promise((resolve,reject) => { 
    JSON.parse('')
    resolve();
  })
} catch(err) {
  console.error('in try catch', err)
}

// 需要使用catch方法
new Promise((resolve,reject) => { 
  JSON.parse('')
  resolve();
}).catch(err => {
  console.log('in catch fn', err)
})
```

1. `async`错误

> `try/catch`不能捕获`async`包裹的错误

```javascript
const getJSON = async () => {
  throw new Error('inner error')
}

// 通过try/catch处理
const makeRequest = async () => {
    try {
        // 捕获不到
        JSON.parse(getJSON());
    } catch (err) {
        console.log('outer', err);
    }
};

try {
    // try/catch不到
    makeRequest()
} catch(err) {
    console.error('in try catch', err)
}

try {
    // 需要await，才能捕获到
    await makeRequest()
} catch(err) {
    console.error('in try catch', err)
}
```

3. `import chunk`错误

> `import`其实返回的也是一个`promise`，因此使用如下两种方式捕获错误

```javascript
// Promise catch方法
import(/* webpackChunkName: "incentive" */'./index').then(module => {
    module.default()
}).catch((err) => {
    console.error('in catch fn', err)
})

// await 方法，try catch
try {
    const module = await import(/* webpackChunkName: "incentive" */'./index');
    module.default()
} catch(err) {
    console.error('in try catch', err)
}
```

以上三种其实归结为`Promise`类型错误，可以通过`unhandledrejection`捕获

```javascript
// 全局统一处理Promise
window.addEventListener("unhandledrejection", function(e){
  console.log('捕获到异常：', e);
});
fetch('https://tuia.cn/test')
```

**`Vue`错误**

> 由于`Vue`会捕获所有`Vue`单文件组件或者`Vue.extend`继承的代码，所以在`Vue`里面出现的错误，并不会直接被`window.onerror`捕获，而是会抛给`Vue.config.errorHandler`。

```javascript
/**
 * 全局捕获Vue错误，直接扔出给onerror处理
 */
Vue.config.errorHandler = function (err) {
  setTimeout(() => {
    throw err
  })
}
```

**`React`错误**

> `react` 通过`componentDidCatch`，声明一个错误边界的组件

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染能够显示降级后的 UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // 你同样可以将错误日志上报给服务器
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // 你可以自定义降级后的 UI 并渲染
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children; 
  }
}

class App extends React.Component {
   
  render() {
    return (
    <ErrorBoundary>
      <MyWidget />
    </ErrorBoundary>  
    )
  }
}
```

但`error boundaries`并不会捕捉以下错误：`React`事件处理，异步代码，`error boundaries`自己抛出的错误

