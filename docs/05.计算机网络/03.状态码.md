---
title: 状态码
date: 2021-12-12 18:08:53
permalink: /pages/0d5c02/
---

# 状态码

## 状态码类别

| `1xx` |   信息性状态码   |      接收的请求正在处理      |
| ----- | :--------------: | :--------------------------: |
| `2xx` |    成功状态码    |       请求正常处理完毕       |
| `3xx` |   重定向状态码   | 需要进行附加操作才能完成请求 |
| `4xx` | 客户端错误状态码 |      服务器无法处理请求      |
| `5xx` | 服务端错误状态码 |      服务器处理请求出错      |

1. `1xx`请求还在处理
   - `100` （客户继续发送请求，这是临时响应） 这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端印当据需发送请求的剩余部分，或者如果请求已经完成，忽略这个响应，服务器必须在请求完成后向客户端发送一个最终响应
   - `101` `Switching Protocols`。在`HTTP`升级为`WebSocket`的时候，如果服务器同意变更，就会发送状态码 `101`
   
1. `2xx`成功
   - `200` `OK` 表示从客户端发的请求服务端正确处理了
   - `204` `No content` 请求成功 响应报文不含实体的主体部分
   - `205` `reset content` 请求成功 响应报文不含实体的主体部分 但与`204`不同的是要求请求方重置内容
   - `206` `partial content` 进行范围请求
1. `3xx`重定向
   1. `301` 永久性重定向 表示资源已被分配了新的`URL`(搜索引擎会记录`301`的`location`指向的地址)
   1. `302` 临时性重定向 表示资源临时被分配了新了`URL`（未登录的用户重定向到登录页面 访问`404`页面重定向到首页）
   1. `303` 资源存在另一个`URL` 应该用`get`方法获取资源(一般用于上传文件后，返回的重定向到消息确认页面或者上传进度页面)
   1. `304` `not modified` 服务器允许访问资源 但是发送请求未满足的情况(浏览器存在缓存)
   1. `307` 临时重定向 但是与`303`不同的是期望客户端保持请求方法不变向新的地址发出请求 （一般浏览器会自动由`post -> get`但是`307`不会 还是`post -> post`）
1. `4xx` 客户端错误
   1. `400` `bad request` 请求报文语法错误或格式不对
   1. `401` `unauthorized` 表示请求需要身份验证
   1. `403` `forbidden` 请求资源被服务器拒绝
   1. `404` `not found` 在服务器未找到请求的资源
   1. `405` `method not allow` 服务器禁止使用这种方法
1. `5xx`服务器错误
   1. `500` `server error` 服务器请求执行时错误
   1. `501` 服务器不支持当前请求的某个功能
   1. `502`（错误网关）服务器作为网关或代理，从上游服务器收到无效响应
   1. `503` `service unavailable`服务器暂时在超负载或停机维护(`nginx`限速)
   1. `504` `gateway timeout` 网关或代理服务器无法在规定时间获得响应(代码执行时间超过 或 死循环)




## 同样是重定向 `302` `303` `307`有什么区别

`302`是`http1.0`的协议状态码，在`1.1`后为了细化`302`，又分出了`303`和`307`

`303`明确了客户端应当采用`get`方法获得资源，会把`post`请求变成`get`请求进行重定向，`307`会遵照浏览器标准，不会从`post`变成`get`

## 浏览器会缓存`301`页面吗，如何清除？

现在我们假设不小心将初始页面永久重定向到了 `301` 页面，现在想取消这一行为，临时重定向到 `302` 页面。

我们发现在`301`之后，浏览器会记住第一次的`301`，忽略之后的其他重定向

原因是**如果我们没有提供明确的缓存头，浏览器就会默认永久缓存 `301` 响应，因为 `301` 是永久重定向的意思。**

<mark>如何清除`301`重定向</mark>

用户端:

- 控制台禁用缓存
- 清除历史记录
- `Network`面板清除缓存

服务端:

- 设置`Cache-Control: no-store/no-cache`

## 介绍下`304`过程

- 浏览器请求资源时首先命中资源的`Expires` 和 `Cache-Control`，`Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过`Cache-control: max-age`指定最大生命周期，状态仍然返回`200`，但不会请求数据，在浏览器中能明显看到`from cache`字样。
- 强缓存失效，进入协商缓存阶段，首先验证`ETag`可以保证每一个资源是唯一的，资源变化都会导致`ETag`变化。服务器根据客户端上送的`If-None-Match`值来判断是否命中缓存。
- 协商缓存`Last-Modified/If-Modified-Since`阶段，客户端第一次请求资源时，服务服返回的`header`中会加上`Last-Modified`，`Last-modified`是一个时间标识该资源的最后修改时间。再次请求该资源时，`request`的请求头中会包含`If-Modified-Since`，该值为缓存之前返回的`Last-Modified`。服务器收到`If-Modified-Since`后，根据资源的最后修改时间判断是否命中缓存

## `HTTP`状态码是`304`多好还是少好<badge text="重要" type="warning" />

状态码`304`是服务器为了提高网站访问速度，而对之前访问的页面指定缓存机制，当客户端对这些页面进行请求，服务端会判断内容是否和之前相同，如果相同客户端调用缓存内容

但是搜索引擎会更加青睐更新频率的网站，通过特定的时间对网站抓取返回的状态码来调节网站抓取频次，若一直是`304`，蜘蛛就会降低抓取次数，相反，若网站变化频率快，每次都能获取新内容，蜘蛛的回访率会变高

**<mark>产生`304`较多的原因：</mark>**

- 页面更新长或不更新
- 纯静态页面

**`304`过多问题**

- 网站快照停止
- 收录减少

- 搜索引擎权重下降

