---
title: HTTP协议与请求方法
date: 2021-11-24 15:31:36
permalink: /pages/2448f7/
---
## 常见的HTTP请求方法

- `get` 向服务器获取数据

- `post` 将实体提交给指定的资源，通常造成服务器资源修改

- `put`上传文件，更新数据
- `delete` 删除服务器上面的对象

- `head` 获取报文首部，与`get`相比不返回报文主体部分
- `options`：询问支持的请求方法，用来跨域请求

- `connect` 要求在与代理服务器通信时建立隧道，使用隧道进行`tcp`通信
- `trace` 回显服务器收到的请求，主要用于测试或诊断

## `get`和`post`的区别

- **应用场景不同：** 一般`get`请求用于服务器资源不会产生影响，比如请求一个网页的资源，但是`post`会对服务器产生影响，比如注册用户之类的
- **缓存不同：** 浏览器一般会对`get`请求缓存，一般不会对`post`请求缓存

- **发送的报文格式不同：** `get`请求的报文实体为空，`post`请求的报文实体一般为向服务器发送的数据
- **安全性不同**： `get`将参数放在`url`的后面，post传递的参数不在`query`上面

- **请求长度：** 浏览器对`url`的长度有限制，会影响`get`请求发送数据的长度
- `post`支持更多的数据类型的数据



## `post`和`put`的区别

- `put`向服务端发送数据，但不会增加数据的种类，无论进行多少次`put`，结果并没有什么不同(理解为更新数据)

- `post`向服务端发送请求，会改变数据的种类，可以理解为创建数据



## 常见的`content-type`有哪些

1. `application/x-www-form-urlencoded `按照`key=value&key=value`进行编码
2. `multipart/form-data` 通常用表单上传文件

1. `application/json` 服务器消息主体是序列化的JSON字符串
2. `text/xml` 主要提交xml格式数据



## `HTTP`状态码是`304`多好还是少好

状态码`304`是服务器为了提高网站访问速度，而对之前访问的页面指定缓存机制，当客户端对这些页面进行请求，服务端会判断内容是否和之前相同，如果相同客户端调用缓存内容

但是搜索引擎会更加青睐更新频率的网站，通过特定的时间对网站抓取返回的状态码来调节网站抓取频次，若一直是304，蜘蛛就会降低抓取次数，相反，若网站变化频率快，每次都能获取新内容，蜘蛛的回访率会变高


**<mark>产生304较多的原因：</mark>**

- 页面更新长或不更新
- 纯静态页面

**304过多问题**

- 网站快照停止
- 收录减少

- 搜索引擎权重下降



## 介绍一下`options`请求

`options`的用途主要有两个

- 获取服务器支持的所有`http`请求方法
- 用于检查访问权限，比如在进行`cors`跨域资源共享的时候，对于复杂请求，就是使用`options`方法发送嗅探请求，判断是否有权限访问指定的资源

## `http1.0`和`http1.1`之间有哪些区别

- **连接方面**：`http1.0`默认支持非持久连接，而`http1.1`默认支持持久连接，`http1.1`通过使用持久连接来使多个`http`请求复用同一个`tcp`连接，避免使用非持久连接每次需要建立的时延
- **资源请求方面**：`http1.0`方面存在浪费带宽(客户端只是需要某个对象的一部分，但是服务器却将整个对象送来了，并且不支持断点续传功能)，`http1.1`在请求头引入`range`头域，它允许之请求资源的某个部分，即返回码是`206(partial content)`，便于开发者自由选择充分利用带宽

- **缓存方面**：在`http1.0`主要使用`header`里的`if-modified-since`、`expire`作为缓存标准判断，`http1.1`加入了`etag` `if-unmodified-since`、`if-match`、`if-none-match`等更多可供选择的缓存头来控制缓存策略
- `http1.1`新增**host字段**,用来指定服务器的域名，`http1.0`认为每台服务器都绑定一个唯一的`ip`，所以请求`url`没有传递主机名，但是随着技术发展，在一台物理机器可以存在多台虚拟主机，共享同一个`ip`地址，这样可以将请求发往同一台服务器的不同网站

- **1.1新增`put` `head` `options`等方法**

## `http1.1`和`2.0`的区别

- **二进制编码**：`2.0`是一个二进制协议，在`1.1`版本中，报文头信息必须是文本(`ASCII编码`)，数据可以是文本，也可以是二进制，`2.0`的头信息和数据体都是**二进制**，统称为**帧**，分为**头信息帧**和**数据帧**
- **多路复用**：`2.0`实现多路复用，复用`tcp`连接，但在一个连接里面客户端和服务端可以同时发送多个请求或响应，而且不用按照顺序一一发送，避免了**队头堵塞**的问题

- **数据流**：`2.0`采用了数据流的概念，因为前面的多路复用讲了，不用按顺序，所以同一个连接里面的数据包，可能属于不同的请求，所以要对数据包做标记，指出他属于哪一个请求。`2.0`将每个请求或回应的所有数据包称为一个数据流，都有一个**独特的编号**，数据包发送时候，都必须标记数据流`id`，来区分属于哪个数据流
- **头信息压缩**：因为`1.1`协议不带状态，每次请求都得附上所有信息，请求很多字段都是重复的，比如`cookies`和`user agent`，一模一样的内容每次请求都得带上，浪费带宽和速度，`2.0`使用`gzip`或`compress`压缩再发出，而客户端和服务端同时维护一张头信息表，所有字段都会存入这张表中，生成一个索引号，以后不发送相同字段 只发索引号，可以提速

- **服务器推送**:`2.0`允许服务器未经请求主动向客户端发送资源，交服务器推送，提前给客户端推送必要的资源，减少延迟时间，需要注意的是`2.0`主动推送的是静态资源，跟`ws`以及使用的`sse`向客户端发送即时数据的推送是不同的

::: tip 队头阻塞

有`HTTP`基本的“请求 - 应答”模型导致的，`http`规定报文必须是一发一收，形成了先进先出的串行队列，队列请求没有优先级，只有入队的顺序，最前面的请求最先被处理，如果队首的请求因为处理的太慢了耽误了时间，那么后面的所有请求也得跟着等待，造成了队头阻塞

:::

## `https`与`http`的区别

- `https`需要`ca`证书，`http`不用
- `http`是**超文本传输协议**，是明文传输，`https`是具有安全性的`ssl`加密传输

- `http`端口是`80` `https`是`443`
- `http`是无状态的协议，`https`是具有`ssl`和`http`协议构建的可加密、身份认证的网络协议，比`http`安全

## `GET`方法对`URL`长度限制的原因

`http`不对`get`方法长度进行限制，其实这个限制是浏览器和服务器对`url`的限制，`ie`对`url`长度限制是`2083`字节(2k+35)，`ie`限制地最小，所以只要不超过`2083`就不会有问题

```javascript
GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）
```



## 当在浏览器输入`google.com`回车之后会发生什么

1. **解析URL** 对`URL`进行解析，分析所用的**传输协议**和**资源路径**，如果不合法，就传递给**搜索引擎**，如果没问题，浏览器检查`URL`是否出现非法字符，若有则进行转义
2. **缓存判断** 判断资源是否存在缓存中，若在缓存且没有失效，就直接使用，否则向服务器发起新请求
1. **DNS解析** 获取`URL`中的域名的`ip`地址，会判断本地是否有该域名的`ip`地址的缓存，有则使用，没有向本地`dns`服务器请求，本地的`dns`服务器也会检查是否存在缓存，如果没有先向根域名服务器发起请求，获得负责的顶级域名服务器的地址再请求，然后获得负责的权威域名服务器的地址再请求，最终获得域名的`ip`地址，本地`dns`服务器再向返回给请求的用户(用户向本地`dns`服务器发起请求是递归请求，本地`dns`向各级域名服务器发起的请求是迭代请求)
4. **获取mac地址** 当浏览器得到`ip`地址时，数据传输还得知道`mac`地址，数据是从**应用层**下发到**传输层**，`tcp`会指定**源端口号**和**目的端口号**，然后下发给网络层，网络层将本地`ip`作为源地址，获取的`ip`作为目的`ip`，然后下发给数据链路层，数据链路层要加入通信双方的`mac`地址，本地`mac`作为源`mac`地址，目的`mac`地址分情况处理，通过`ip`地址与本地子网掩码相与，判断是否和请求主机处于同一个子网，如果在同一子网，用`ARP`协议获得目的主机的`mac`地址，如果不在，请求转发给网关，由他来转发，此时同样可以通过`arp`协议获得网关的`mac`地址，此时目的主机的`mac`地址为网关的地址
5. **TCP三次握手** 下面是 `TCP` 建立连接的三次握手的过程。
   - 首先客户端向服务器发送一个 `SYN `连接请求报文段和一个随机序号
   
   - 服务端接收到请求后向客户端发送一个 `SYN ACK`报文段，确认连接请求，并且也向客户端发送一个随机序号。
   - 客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个`ACK `确认报文段
   - 服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了
6. **HTTPS握手** 通信还存在`TLS`的四次挥手
   - 首先客户端向服务端发送**协议的版本号**、**一个随机数**和可以使用的**加密方法**
   
   - 服务器收到后确认加密方法，向客户端发送一个**随机数**和**自己的数字证书**
   - 客户端收到后检查数字证书是否有效，有效的话再生成一个**随机数**，使用证书的公钥对**随机数加密** 然后发给服务端，并且会提供一个**前面所有内容的hash值给服务器检验**
   - 服务器接收后用私钥对**数据解密**，同时**向客户端发送一个前面所有内容的hash值供客户端检验**，双方这时有三个随机数，按之前的加密方法，使用**这三个随机数生成一把密钥**，以后双方传输数据时用这个密钥加密再传输
7. **返回数据** 当页面请求发到服务端，服务端会返回一个`html`文件作为响应，浏览器接到响应 对`html`进行解析，开始页面渲染
8. **页面渲染** 页面根据`html`文件构建`dom`树，根据`css`构建`cssom`树，如果遇到`script` 判断是否有`defer`或`async`，如果都没有会对页面的渲染堵塞，完了之后构建`render tree`，构建好了之后进行布局，最后使用浏览器的`ui`接口对页面进行绘制，最后页面显示出来
9. **TCP四次挥手** 最后一步是` TCP` 断开连接的四次挥手过程。
   - 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。
   - 服务端收到连接释放请求后，会告诉应用层要释放` TCP` 链接。然后会发送 `ACK` 包，并进入 `CLOSE_WAIT` 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。**但是因为 `TCP `连接是双向的，所以服务端仍旧可以发送数据给客户端。**
   - 服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 `LAST-ACK` 状态
   - 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 `TIME-WAIT `状态。该状态会持续 `2MSL`（<mark>最大段生存期，指报文段在网络中生存的时间，超时会被抛弃</mark>） 时间，若该时间段内没有服务端的重发请求的话，就进入` CLOSED` 状态。
   - 当服务端收到确认应答后，也便进入 `CLOSED` 状态。




## 对`keep-alive`的理解

`http1.0`默认每次请求/应答，客户端和服务端都会新建一个连接，完成之后断开连接，这是短连接

使用keep-alive使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，可以避免建立或重新连接，这是长连接

使用方法：

- 1.0默认没有`keep-alive`，需要的话配置发送`Connection: keep-alive`
- 断开的话发送`Connection: close`

- `1.1`版本默认保持长连接，数据传输完成的时候`tcp`连接不断开，等待同域名下继续使用这个通道传输数据，需要关闭就发送`Connection: close`

`Keep-Alive`的**建立过程**：

- 客户端向服务器在发送请求报文同时在首部添加发送`Connection`字段
- 服务器收到请求并处理 `Connection`字段

- 服务器回送`Connection:Keep-Alive`字段给客户端
- 客户端接收到`Connection`字段

- `Keep-Alive`连接建立成功

**服务端自动断开过程（也就是没有keep-alive）**：

- 客户端向服务器只是发送内容报文（不包含`Connection`字段）
- 服务器收到请求并处理

- 服务器返回客户端请求的资源并关闭连接
- 客户端接收资源，发现没有`Connection`字段，断开连接

**客户端请求断开连接过程**：

- 客户端向服务器发送`Connection:close`字段
- 服务器收到请求并处理`connection`字段

- 服务器回送响应资源并断开连接
- 客户端接收资源并断开连接

开启`Keep-Alive`的**优点：**

- 较少的`CPU`和内存的使⽤（由于同时打开的连接的减少了）；
- 允许请求和应答的`HTTP`管线化；

- 降低拥塞控制 （`TCP`连接减少了）；
- 减少了后续请求的延迟（⽆需再进⾏握⼿）；

- 报告错误⽆需关闭`TCP`连接

开启`Keep-Alive`的**缺点**：

- 长时间的`TCP`连接容易导致系统资源无效占用，浪费系统资源。



## 页面有多张图片，`http`怎么加载

在`http1`，浏览器对一个域名下最大`tcp`连接数为`6`，所以会请求多次，可以用多域名部署解决，可以提高同时请求的数目，加快页面图片的获取速度

在`http2`中，支持多路复用，可以在一个`tcp`连接中发送多个`http`请求



## `http2`头部压缩算法如何实现

`http2`头部压缩是`HPACK`算法，在客户端和服务端两端建立“字典”，用索引号表示重复的字符串，采用**哈夫曼编码压缩整数和字符串**

- 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；
- 首部表在`HTTP/2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新；

- 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。



例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041547556.webp)



## HTTP的请求报文是什么样的

由请求行 请求头部 空行 请求体组成

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041548272.webp)

请求⾏包括：请求⽅法字段、`URL`字段、`HTTP`协议版本字段

请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔

- `User-Agent`：产⽣请求的浏览器类型。
- `Accept`：客户端可识别的内容类型列表。

- `Host`：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。

请求体:`post` `put`等请求携带的数据

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic@main/img/edsfndsjfbwaternark.1uyexsgxywn4.webp)

## HTTP响应报文是什么样的

由响应行 响应头 空行 响应体

![img](https://gitee.com/duochizhacai/generate-pic/raw/master/img/202112121543616.webp)

## `http`的优缺点

`http`是超文本传输协议，定义了客户端和服务端交换报文的格式和方式，默认使用`80`端口，使用`tcp`协议作为**传输层**协议，保证了数据传输的可靠

<mark>优点</mark>：

- **支持客户端/服务端**
- **简单快捷** 客户向服务器请求时 只需传送请求方法和路径 由于`http`协议简单 使得`http`服务器规模小，通信速度快

- **无连接** 限制每次连接只处理一个请求，服务端处理完客户请求，客户收到应答就断开连接，可以节省传输时间
- **无状态** 状态指的是通信上下文信息，缺少状态意味着如果后续处理需要前面的信息，就必须重传，导致每次连接传送的数据量增大，另一方面在服务器不需要之前的信息他的应答就比较快

- **灵活** `http`允许传输任意类型的数据对象，由`content-type`标记

<mark>缺点:</mark>

- **无状态** 服务器不会保存关于客户的任何消息
- **明文传输** 报文采用文本形式 不安全

- **不安全** 使用明文 内容易被窃听；不验证通信方身份，可能伪装；无法验证报文完整性，可能被篡改



## 说一下`http3.0`

基于`UDP`协议实现的类似于`tcp`多路复用的数据流，传输可靠性，称为`QUIC`协议

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041614890.webp)

1. **流量控制、传输可靠性**：`QUIC`在`udp`基础上增加一层保证数据传输可靠性，提供了数据包重传 拥塞控制等
2. **集成TLS加密功能**，减少花费的`RTT`数

1. **多路复用** 同一个物理连接上可以有多个独立的逻辑数据流，实现数据流单独传输，解决`tcp`队头阻塞问题
2. **快速握手** 基于`udp`，可以实现`0-1`个`rtt`来建立连接

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112041614234.webp)

## http性能怎么样

基于`tcp/ip`，使用**请求**和**应答**通信模式，所以性能来说这俩是关键

- 长连接 可以避免每次tcp连接三次握手花费
- `http1.1` 管道网络传输，就是一个tcp连接里面客户端可以发送多个请求
- 队头拥塞 http传输是一发一收 ，里面的任务放在一个任务队列中串行执行 一旦队首请求的太慢会阻塞后面请求的处理
  - 解决方法：
  - **并发连接** 对于一个域名允许分配多个长连接，相当于增加了任务队列
  - **域名分片** 将域名分出很多个二级域名，全都指向同样的一台服务器 能够并发的长连接数变多
