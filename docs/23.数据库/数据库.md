---
title: 数据库
date: 2022-03-01 10:12:44
permalink: /pages/f97cee/
---

## 关系型数据库和非关系型数据库的区别

**数据表 VS 数据集**

主要差异是**数据存储的方式**。

关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。

而非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素



**预定义结构 VS 动态结构**

关系型数据通常对应于**结构化数据**，因为数据表都有预定义好的结构(列的定义)，结构描述了数据的形式和内容。这一点对数据建模至关重要，你必须“第一时间先把结构定义好”。虽然预定义结构带来了可靠性和稳定性，但是已经存入数据的表结构要修改就非常痛苦了。

非关系型数据基于**动态结构**，通常适用于非结构化数据。非关系型数据可以很容易适应数据类型和结构的变化，因为动态结构本身就支持这一点



**纵向扩容 VS 横向扩容**

最大的差别可能是在**扩展方式**上，要支持日益增长的需求当然要扩展。要支持更多并发量，`SQL`数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来客服。虽然`SQL`数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。

而`NoSQL`数据库是横向扩展的。非关系型数据存储天然就是分布式的，`NoSQL`数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载。



**结构化查询 VS 非结构化查询**

关系型数据库通过`SQL`来操作数据。`SQL`支持数据库`CRUD`(增加，查询，更新，删除)操作的功能非常强大。

非关系型数据库以块(像文档一样)为单元操纵数据，使用所谓的非结构化查询语言(`UnQL`)，它是没有标准的，因数据库提供商的不同而不同。关系型表中主键的概念对应非关系存储中的文档`Id`。`SQL`数据库使用预定义优化方式(比如列索引定义)帮助加速查询操作，而`NoSQL`数据库采用更简单而精确的数据访问模式。

**事务性 VS 纯扩展性**

如果你的数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的`SQL`数据库从性能和稳定性方面考虑是你的最佳选择。`SQL`数据库支持对事务原子性细粒度控制，并且易于回滚事务。虽然`NoSQL`数据库也可以使用事务操作，但它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。

:::note 什么是事务

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。
事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。

**四个特性**

- 原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做
- 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，也就是数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
- 隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持续性：也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

:::

## 数据库在数据量较大的时候如何加快查找效率

- 数据库方面

  - 建立索引

  - 分区（如`MySQL`，按时间分区）

-  尽量使用固定长度字段和限制字段长度（如 `varchar(10)`）
  - 优势
  - 降低物理存储空间
  -  提高数据库处理速度
  - 附带校验数据库是否合法功能

-  在数据库 `I/O`方面；
  - 增加缓冲区
  - 如果设计表的级联，不同的表存储在不同磁盘上，以增加 `I/O`速度

-  在 `sql` 语句方面
  - 优化`sql`语句，减少比较次数
  - 限制返回条目数(`mysql`中使用`limit`）

:::note 建立索引

原因：有`3`个未索引的表`t1`、`t2`、`t3`，分别只包含列`c1`、`c2`、`c3`，每个表分别含有`1000`行数据组成，指为1～1000的数值，查找对应值相等行的查询如下所示。

`SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3`

  此查询结果应该为`1000`行，每行包含`3`个相等的值。在无索引的情况下处理此查询，必须寻找`3`个表所有的组合，以便得出与`WHERE`子句相配的那些行。而可能的组合数目为`1000×1000×1000（十亿）`，显然查询将会非常慢。

  如果对每个表进行索引，就能极大地加速查询进程。利用索引的查询处理如下。

1. 从表`t1`中选择第一行，查看此行所包含的数据。

2. 使用表`t2`上的索引，直接定位`t2`中与`t1`的值匹配的行。类似，利用表`t3`上的索引，直接定位`t3`中与来自`t1`的值匹配的行。

3. 扫描表`t1`的下一行并重复前面的过程，直到遍历`t1`中所有的行。

  在此情形下，仍然对表`t1`执行了一个完全扫描，但能够在表`t2`和`t3`上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。

  利用索引，`MySQL`加速了`WHERE`子句满足条件行的搜索，而在多表连接查询时，在执行连接时加快了与其他表中的行匹配的速度。

:::

::: note 分区

分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。

`MySQL`数据库支持的**分区类型为水平分区**（指将同一个表中不同行的记录分配到不同的物理文件中），并不支持垂直分区（指将同一表中不同列的记录分配到不同的物理文件中）。此外，`MySQL`数据库的分区是局部分区索引，一个分区中既存放了数据又存放了索引。而全局分区是指，数据存放在各个分区中，但是所有数据的索引放在一个对象中。目前，`MySQL`数据库还不支持全局分区。





**分区的好处:**

- 可以让单表存储更多的数据

- 分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作
- 部分查询能够从查询条件确定只落在少数分区上，速度会很快（查询条件尽量扫描少的分区）
- 分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备
- 可以使用分区表来避免某些特殊瓶颈，例如`InnoDB`单个索引的互斥访问、`ext3`文件系统的`inode`锁竞争
- 可以备份和恢复单个分区

分区的**限制和缺点**：

- 一个表最多只能有`1024`个分区
- 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
- 分区表无法使用外键约束
- `NULL`值会使分区过滤无效
- 所有分区必须使用相同的存储引擎

**表分区与分表的区别？**

 分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。 

分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表

:::
