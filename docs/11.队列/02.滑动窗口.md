---
title: 滑动窗口
date: 2021-12-22 11:23:31
permalink: /pages/ca30e4/
---
# 滑动窗口

## lc239: 滑动窗口最大值<Badge text="困难" vertical="top" type="warning" />



::: tip 题目描述



给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。



返回滑动窗口中的最大值。

:::

示例 1：



```plain
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值

---------------               -----

[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```



示例 2：



```plain
输入：nums = [1], k = 1
输出：[1]
```



示例 3：



```plain
输入：nums = [1,-1], k = 1
输出：[1,-1]
```



示例 4：



```plain
输入：nums = [9,11], k = 2
输出：[11]
```



示例 5：



```plain
输入：nums = [4,-2], k = 2
输出：[4]
```



> 法一： 暴力法



思路：



- 声明数组`arr`存放滑动窗口 `res`存放最大值
- 进入遍历

- 如果当前索引小于`k - 1`的话 则不满足滑动窗口大小，继续往`arr`插进元素
- 如果当前索引大于等于`k - 1`那就比较里面的k个元素中最大的 然后`push`进`res`中



因为暴力法 会有`n - k + 1`个窗口生成



因此时间复杂度为 `O((n - k + 1)k) = O(nk)` 会超出时间限制



```javascript
var maxSlidingWindow = function(nums, k) {
    if(k === 1) return nums
    const res = [] 
    const arr = []
    for(let i = 0; i < nums.length; i++) {
        arr.push(nums[i])

        if(i >= k - 1) {
            res.push(Math.max(...arr))
            arr.shift()
        }
    }
    return res
};
```



因为超出时间限制，不通过



法二 双向队列(单调队列)



思路：



![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112221115529.gif)



总结就是**保证最大的数字在队头**



假如滑动窗口移动，那么就逐步把其他元素出队



```javascript
const maxSlidingWindow = function (nums, k) {
    const deque = []
    const result = []
    for (let i = 0; i < nums.length; i++) {
        // 把滑动窗口之外的踢出
        if (i - deque[0] >= k) {
            deque.shift()
        }
        while (nums[deque[deque.length - 1]] <= nums[i]) {
            deque.pop()
        }
        deque.push(i)
        if (i >= k - 1) {
            result.push(nums[deque[0]])
        }
    }
    return result
}
```

 

## lc03:无重复字符的最长子串<Badge text="中等" vertical="top"/>



::: tip 题目描述：

给定一个字符串 `s` ，请你找出其中不含有重复字符的 最长子串 的长度。

:::

示例 1:

```plain
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例 2:

```plain
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例 3:

```plain
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

示例 4:

```plain
输入: s = ""
输出: 0
```

> 法一：滑动窗口

- 维护一个队列
- 字符的每个字符准备入队

- 判断队列里是否已经存在相同字符 
  - 如果没有则入队
  - 如果有的话 保存队列中相同字符的索引`index`，并把`0 ~ index + 1`出队 
    - 然后在把这个字符入队

- 判断此时队列的长度和原来的最大值哪个大



时间复杂度`O(n ^ 2) `

​	因为`for`为`O(n)` 里面的 **`arr.indexOf()`** 时间复杂度为 `O(n)` , **`arr.splice(0, index+1)`** 的时间复杂度也为 `O(n)`

空间复杂度`O(n)`

![img](https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202112221135287.png)





```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let arr = [], index, max = 0
    for(let i = 0; i < s.length; i++) {
        index = arr.indexOf(s[i])
        if(index !== -1) {
            arr.splice(0, index + 1)
        }
        arr.push(s.charAt(i))
        max = Math.max(max, arr.length)
    }
    return max
};
```

> 法二：`js api`的`map`



思路：



- 维护一个`map`
- 变量`i`为无重复的起始位，`j`为当前元素的索引值

- 进入一次字符串`s`的循环
- 判断元素`s[i]`是否在`map`里面 

- - 如果有的话，则更新无重复子串开始下标 `i` 为相同字符的下一位置
  - 解释一下上面 假如输入的字符串是`abcabcbb` 那么当`s[i]`为第四个字符`a`的时候`map`里面存在对应的索引为`0`，那么这个时候要比较索引 `0 + 1` 和原来 `i`中谁大

- 更新`max`



**时间复杂度O(n)**



**空间复杂度O(n)**



```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let max = 0
    let map = new Map()
    for(let i = 0, j = 0; j < s.length; j++) {
    	// 为什么下面还需要和原来的i比较呢
    	// 是因为假如输入的是abba
    	// 进行到第三位字符b的时候 i = 2;  j = 2; max = 1
    	// 进行到第四位字符a的时候 假如还是等于map.get(s[j])的话，会导致 i = 1 j = 3 max = 3 
      	// 其最大无重复字符串为bba？
    	// 很显然不对，但Math.max(map.get(s[j]) + 1, i)保证了i不会出错
        if(map.has(s[j])) i = Math.max(map.get(s[j]) + 1, i)

        max = Math.max(j - i + 1, max)
        map.set(s[j], j)
    }
    return max
}
```
