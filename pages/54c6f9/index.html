<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>生命周期 | 小宋爱睡觉</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="🚀一个前端程序员小白的博客🌹">
    <meta name="keywords" content="blog,crucials,frontend,前端,小宋爱睡觉,博客,duochizhacai">
    <meta name="theme-color" content="#60ad81">
    
    <link rel="preload" href="/assets/css/0.styles.65787d8c.css" as="style"><link rel="preload" href="/assets/js/app.95fc12d6.js" as="script"><link rel="preload" href="/assets/js/2.abf57e2f.js" as="script"><link rel="preload" href="/assets/js/45.e623e04e.js" as="script"><link rel="prefetch" href="/assets/js/10.9d6bb65c.js"><link rel="prefetch" href="/assets/js/11.bea1ca2d.js"><link rel="prefetch" href="/assets/js/12.a5ced6a2.js"><link rel="prefetch" href="/assets/js/13.ec1bcac6.js"><link rel="prefetch" href="/assets/js/14.4e5bcc62.js"><link rel="prefetch" href="/assets/js/15.753bb2dc.js"><link rel="prefetch" href="/assets/js/16.a6e51bcc.js"><link rel="prefetch" href="/assets/js/17.25227dca.js"><link rel="prefetch" href="/assets/js/18.19267273.js"><link rel="prefetch" href="/assets/js/19.a9403a12.js"><link rel="prefetch" href="/assets/js/20.c007e659.js"><link rel="prefetch" href="/assets/js/21.dca7af69.js"><link rel="prefetch" href="/assets/js/22.d9f25771.js"><link rel="prefetch" href="/assets/js/23.2668c7ed.js"><link rel="prefetch" href="/assets/js/24.30c858a4.js"><link rel="prefetch" href="/assets/js/25.bd21abb1.js"><link rel="prefetch" href="/assets/js/26.28d250cb.js"><link rel="prefetch" href="/assets/js/27.a60d212f.js"><link rel="prefetch" href="/assets/js/28.8a5c2c34.js"><link rel="prefetch" href="/assets/js/29.4688a5d6.js"><link rel="prefetch" href="/assets/js/3.e687237e.js"><link rel="prefetch" href="/assets/js/30.5985f3b4.js"><link rel="prefetch" href="/assets/js/31.7ee5d916.js"><link rel="prefetch" href="/assets/js/32.2f711dea.js"><link rel="prefetch" href="/assets/js/33.45a4e58a.js"><link rel="prefetch" href="/assets/js/34.6a46cad8.js"><link rel="prefetch" href="/assets/js/35.79084a19.js"><link rel="prefetch" href="/assets/js/36.9a5cf509.js"><link rel="prefetch" href="/assets/js/37.ea6b36a3.js"><link rel="prefetch" href="/assets/js/38.1ebed809.js"><link rel="prefetch" href="/assets/js/39.16200e67.js"><link rel="prefetch" href="/assets/js/4.4a0efd85.js"><link rel="prefetch" href="/assets/js/40.db1f5064.js"><link rel="prefetch" href="/assets/js/41.5c8205b4.js"><link rel="prefetch" href="/assets/js/42.d8e671a9.js"><link rel="prefetch" href="/assets/js/43.80c6d459.js"><link rel="prefetch" href="/assets/js/44.0dc33dbe.js"><link rel="prefetch" href="/assets/js/46.b9a46fc2.js"><link rel="prefetch" href="/assets/js/47.2d5eb349.js"><link rel="prefetch" href="/assets/js/48.8d4e8a09.js"><link rel="prefetch" href="/assets/js/49.f7f58461.js"><link rel="prefetch" href="/assets/js/5.84799806.js"><link rel="prefetch" href="/assets/js/50.b482896d.js"><link rel="prefetch" href="/assets/js/51.9ad2b264.js"><link rel="prefetch" href="/assets/js/52.7862671c.js"><link rel="prefetch" href="/assets/js/53.d8153804.js"><link rel="prefetch" href="/assets/js/54.0af2674d.js"><link rel="prefetch" href="/assets/js/55.597b91b8.js"><link rel="prefetch" href="/assets/js/56.46804158.js"><link rel="prefetch" href="/assets/js/57.006f6db0.js"><link rel="prefetch" href="/assets/js/58.751e40d0.js"><link rel="prefetch" href="/assets/js/59.b0ebe0e6.js"><link rel="prefetch" href="/assets/js/6.f7ec0152.js"><link rel="prefetch" href="/assets/js/60.8d675b12.js"><link rel="prefetch" href="/assets/js/61.55190a7f.js"><link rel="prefetch" href="/assets/js/62.117f5f66.js"><link rel="prefetch" href="/assets/js/63.b848bfe2.js"><link rel="prefetch" href="/assets/js/64.000227a3.js"><link rel="prefetch" href="/assets/js/65.9ec404e1.js"><link rel="prefetch" href="/assets/js/66.1834b2b1.js"><link rel="prefetch" href="/assets/js/67.bf716de8.js"><link rel="prefetch" href="/assets/js/68.6e03054c.js"><link rel="prefetch" href="/assets/js/69.c6605c56.js"><link rel="prefetch" href="/assets/js/7.40c08f02.js"><link rel="prefetch" href="/assets/js/70.30051d78.js"><link rel="prefetch" href="/assets/js/71.1fdc7d36.js"><link rel="prefetch" href="/assets/js/72.4b0ad4ad.js"><link rel="prefetch" href="/assets/js/73.e989ab6d.js"><link rel="prefetch" href="/assets/js/74.02429c23.js"><link rel="prefetch" href="/assets/js/75.8f044cef.js"><link rel="prefetch" href="/assets/js/76.7acc2de5.js"><link rel="prefetch" href="/assets/js/77.ce127400.js"><link rel="prefetch" href="/assets/js/78.deb1ae24.js"><link rel="prefetch" href="/assets/js/79.75a4c78b.js"><link rel="prefetch" href="/assets/js/8.303c64d8.js"><link rel="prefetch" href="/assets/js/80.6c258060.js"><link rel="prefetch" href="/assets/js/81.563a0c28.js"><link rel="prefetch" href="/assets/js/82.143b4caf.js"><link rel="prefetch" href="/assets/js/83.32431b7f.js"><link rel="prefetch" href="/assets/js/84.2320a5a5.js"><link rel="prefetch" href="/assets/js/85.d9a1625a.js"><link rel="prefetch" href="/assets/js/86.dc0f47f2.js"><link rel="prefetch" href="/assets/js/87.8335157f.js"><link rel="prefetch" href="/assets/js/88.2cfc7001.js"><link rel="prefetch" href="/assets/js/89.6bc590c2.js"><link rel="prefetch" href="/assets/js/9.7ba1b2de.js"><link rel="prefetch" href="/assets/js/90.c20801a7.js"><link rel="prefetch" href="/assets/js/91.1a32fafc.js"><link rel="prefetch" href="/assets/js/92.4a802465.js">
    <link rel="stylesheet" href="/assets/css/0.styles.65787d8c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/logo.png" alt="小宋爱睡觉" class="logo"> <span class="site-name can-hide">小宋爱睡觉</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><a href="/pages/56881f/" class="link-title">知识库</a> <span class="title" style="display:none;">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/56881f/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/c0e7f0/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/pages/787250/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/f0a671/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/b7238f/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/pages/2448f7/" class="nav-link">计算机网络</a></li><li class="dropdown-item"><!----> <a href="/pages/b8bd46/" class="nav-link">浏览器原理</a></li><li class="dropdown-item"><!----> <a href="/pages/f15087/" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/pages/e3cba5/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/pages/ba01c4/" class="nav-link">手写系列</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/pages/ad5191/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8ac126/" class="nav-link">字符串</a></li><li class="dropdown-item"><!----> <a href="/pages/251490/" class="nav-link">数组</a></li><li class="dropdown-item"><!----> <a href="/pages/fc9745/" class="nav-link">链表</a></li><li class="dropdown-item"><!----> <a href="/pages/ad5191/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/pages/6aee18/" class="nav-link">动态规划</a></li><li class="dropdown-item"><!----> <a href="/pages/78e948/" class="nav-link">排序算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><a href="/pages/54c6f9/https://github.com/duochizhacai" class="link-title">GitHub</a> <span class="title" style="display:none;">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duochizhacai" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/1249486902410744" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JueJin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><a href="/pages/56881f/" class="link-title">知识库</a> <span class="title" style="display:none;">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/56881f/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/c0e7f0/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/pages/787250/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/f0a671/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/b7238f/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/pages/2448f7/" class="nav-link">计算机网络</a></li><li class="dropdown-item"><!----> <a href="/pages/b8bd46/" class="nav-link">浏览器原理</a></li><li class="dropdown-item"><!----> <a href="/pages/f15087/" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/pages/e3cba5/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/pages/ba01c4/" class="nav-link">手写系列</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/pages/ad5191/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8ac126/" class="nav-link">字符串</a></li><li class="dropdown-item"><!----> <a href="/pages/251490/" class="nav-link">数组</a></li><li class="dropdown-item"><!----> <a href="/pages/fc9745/" class="nav-link">链表</a></li><li class="dropdown-item"><!----> <a href="/pages/ad5191/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/pages/6aee18/" class="nav-link">动态规划</a></li><li class="dropdown-item"><!----> <a href="/pages/78e948/" class="nav-link">排序算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><a href="/pages/54c6f9/https://github.com/duochizhacai" class="link-title">GitHub</a> <span class="title" style="display:none;">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duochizhacai" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/1249486902410744" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JueJin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/b7238f/" class="sidebar-link">事件机制</a></li><li><a href="/pages/24db5f/" class="sidebar-link">数据管理</a></li><li><a href="/pages/54c6f9/" aria-current="page" class="active sidebar-link">生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/54c6f9/#react的生命周期有哪些" class="sidebar-link">React的生命周期有哪些？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/54c6f9/#_1-组件挂载阶段" class="sidebar-link">1. 组件挂载阶段</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#_2-组件更新阶段" class="sidebar-link">2. 组件更新阶段</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#_3-组件卸载阶段" class="sidebar-link">3. 组件卸载阶段</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#_4-错误处理阶段" class="sidebar-link">4. 错误处理阶段</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#react-废弃了哪些生命周期-为什么" class="sidebar-link">React 废弃了哪些生命周期？为什么？</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#react-16-x-中-props-改变后在哪个生命周期中处理" class="sidebar-link">React 16.X 中 props 改变后在哪个生命周期中处理</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#react-性能优化在哪个生命周期-它优化的原理是什么" class="sidebar-link">React 性能优化在哪个生命周期？它优化的原理是什么？</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#state-和-props-触发更新的生命周期分别有什么区别" class="sidebar-link">state 和 props 触发更新的生命周期分别有什么区别？</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#react中发起网络请求应该在哪个生命周期中进行-为什么" class="sidebar-link">React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li><li class="sidebar-sub-header"><a href="/pages/54c6f9/#react-16中新生命周期有哪些" class="sidebar-link">React 16中新生命周期有哪些</a></li></ul></li><li><a href="/pages/be9376/" class="sidebar-link">组件通信</a></li><li><a href="/pages/000594/" class="sidebar-link">路由</a></li><li><a href="/pages/30f7b5/" class="sidebar-link">redux</a></li><li><a href="/pages/6bcb1a/" class="sidebar-link">Hooks</a></li><li><a href="/pages/b06269/" class="sidebar-link">虚拟DOM</a></li><li><a href="/pages/b0c8ad/" class="sidebar-link">其他</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><span data-v-1cd794fe>React</span></li> <!----> <!----></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/duochizhacai" target="_blank" title="作者" class="beLink" data-v-1cd794fe>Crucials</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2022-05-01</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">
          生命周期
        </h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="react的生命周期有哪些"><a href="#react的生命周期有哪些" class="header-anchor">#</a> <code>React</code>的生命周期有哪些？</h2> <p><code>React</code> 通常将组件生命周期分为三个阶段：</p> <ul><li>装载阶段（<code>Mount</code>），组件第一次在<code>DOM</code>树中被渲染的过程；</li> <li>更新过程（<code>Update</code>），组件状态发生变化，重新更新渲染的过程；</li> <li>卸载过程（<code>Unmount</code>），组件从<code>DOM</code>树中被移除的过程；</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202205012338075.awebp" alt="image.png"></p> <h3 id="_1-组件挂载阶段"><a href="#_1-组件挂载阶段" class="header-anchor">#</a> 1. 组件挂载阶段</h3> <p>挂载阶段组件被创建，然后组件实例插入到 <code>DOM</code> 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：</p> <ul><li><code>constructor</code></li> <li><code>getDerivedStateFromProps</code></li> <li><code>render</code></li> <li><code>componentDidMount</code></li></ul> <p><strong><code>constructor</code></strong></p> <p>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 <code>super(props)</code>，否则无法在构造函数中拿到<code>this</code>。</p> <p>如果不初始化 <code>state</code> 或不进行方法绑定，则不需要为 <code>React</code> 组件实现构造函数**<code>Constructor</code>**。</p> <p><code>constructor</code>中通常只做两件事：</p> <ul><li>初始化组件的 <code>state</code></li> <li>给事件处理方法绑定 <code>this</code></li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> counter<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong><code>getDerivedStateFromProps</code></strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这是个静态方法，所以不能在这个函数里使用 <code>this</code>，有两个参数 <code>props</code> 和 <code>state</code>，分别指接收到的新参数和当前组件的 <code>state</code> 对象，这个函数会返回一个对象用来更新当前的 <code>state</code> 对象，如果不需要更新可以返回 <code>null</code>。</p> <p>该函数会在装载时，接收到新的 <code>props</code> 或者调用了 <code>setState</code> 和 <code>forceUpdate</code> 时被调用。如当接收到新的属性想修改 <code>state</code> ，就可以使用。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 当 props.counter 变化时，赋值给 state </span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      counter<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>counter <span class="token operator">!==</span> state<span class="token punctuation">.</span>counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        counter<span class="token operator">:</span> props<span class="token punctuation">.</span>counter
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  
  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      counter<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1 onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>现在可以显式传入 <code>counter</code> ，但是这里有个问题，如果想要通过点击实现 <code>state.counter</code> 的增加，但这时会发现值不会发生任何变化，一直保持 <code>props</code> 传进来的值。这是由于在 <code>React 16.4+</code> 的版本中 <code>setState</code> 和 <code>forceUpdate</code> 也会触发这个生命周期，所以当组件内部 <code>state</code> 变化后，就会重新走这个方法，同时会把 <code>state</code> 值赋值为 <code>props</code> 的值。因此需要多加一个字段来记录之前的 <code>props</code> 值，这样就会解决上述问题。具体如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 这里只列出需要变化的地方</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">// 增加一个 preCounter 来记录之前的 props 传来的值</span>
      preCounter<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      counter<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 跟 state.preCounter 进行比较</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>counter <span class="token operator">!==</span> state<span class="token punctuation">.</span>preCounter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        counter<span class="token operator">:</span> props<span class="token punctuation">.</span>counter<span class="token punctuation">,</span>
        preCounter<span class="token operator">:</span> props<span class="token punctuation">.</span>counter
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      counter<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1 onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p><strong><code>render</code></strong></p> <p><code>render</code>是<code>React</code> 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 <code>state</code> 和属性 <code>props</code> 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：</p> <ul><li><strong><code>React</code> 元素</strong>：这里包括原生的 <code>DOM</code> 以及 <code>React</code> 组件；</li> <li><strong>数组和 <code>Fragment</code>（片段）</strong>：可以返回多个元素；</li> <li><strong><code>Portals</code>（传送门）</strong>：可以将子元素渲染到不同的 <code>DOM</code> 子树种；</li> <li><strong>字符串和数字</strong>：被渲染成 <code>DOM</code> 中的 <code>text</code> 节点；</li> <li><strong>布尔值或 <code>null</code></strong>：不渲染任何内容。</li></ul> <p><strong><code>componentDidMount</code></strong></p> <p><code>componentDidMount()</code>会在组件挂载后（插入 <code>DOM</code> 树中）立即调。该阶段通常进行以下操作：</p> <ul><li>执行依赖于<code>DOM</code>的操作；</li> <li>发送网络请求；（官方建议）</li> <li>添加订阅消息（会在<code>componentWillUnmount</code>取消订阅）；</li></ul> <p>如果在 <code>componentDidMount</code> 中调用 <code>setState</code> ，就会触发一次额外的渲染，多调用了一次 <code>render</code> 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 <code>constructor</code> 中初始化 <code>state</code> 对象。</p> <p>在组件装载之后，将计数数字变为1：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span>  <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      counter<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentDidMount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      counter<span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;counter&quot;</span><span class="token operator">&gt;</span>
        counter值<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="_2-组件更新阶段"><a href="#_2-组件更新阶段" class="header-anchor">#</a> 2. 组件更新阶段</h3> <p>当组件的 <code>props</code> 改变了，或组件内部调用了 <code>setState/forceUpdate</code>，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：</p> <ul><li><code>getDerivedStateFromProps</code></li> <li><code>shouldComponentUpdate</code></li> <li><code>render</code></li> <li><code>getSnapshotBeforeUpdate</code></li> <li><code>componentDidUpdate</code></li></ul> <p><strong><code>shouldComponentUpdate</code></strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在说这个生命周期函数之前，来看两个问题：</p> <ul><li><strong><code>setState</code> 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：</strong></li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>number<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>number<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>如果没有调用 <code>setState</code>，<code>props</code> 值也没有变化，是不是组件就不会重新渲染？</strong></li></ul> <p>第一个问题答案是 <strong>会</strong> ，第二个问题如果是父组件重新渲染时，不管传入的 <code>props</code> 有没有变化，都会引起子组件的重新渲染。</p> <p>那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 <code>shouldComponentUpdate</code> 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 <code>true</code>，可以比较 <code>this.props</code> 和 <code>nextProps</code> ，<code>this.state</code> 和 <code>nextState</code> 值是否变化，来确认返回 true 或者 <code>false</code>。当返回 <code>false</code> 时，组件的更新过程停止，后续的 <code>render</code>、<code>componentDidUpdate</code> 也不会被调用。</p> <p><strong>注意：</strong> 添加 <code>shouldComponentUpdate</code> 方法时，不建议使用深度相等检查（如使用 <code>JSON.stringify()</code>），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。</p> <p><strong><code>getSnapshotBeforeUpdate</code></strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个方法在 <code>render</code> 之后，<code>componentDidUpdate</code> 之前调用，有两个参数 <code>prevProps</code> 和 <code>prevState</code>，表示更新之前的 <code>props</code> 和 <code>state</code>，这个函数必须要和 <code>componentDidUpdate</code> 一起使用，并且要有一个返回值，默认是 <code>null</code>，这个返回值作为第三个参数传给 <code>componentDidUpdate</code>。</p> <p><strong><code>componentDidUpdate</code></strong></p> <p><code>componentDidUpdate()</code> 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：</p> <ul><li>当组件更新后，对 <code>DOM</code> 进行操作；</li> <li>如果你对更新前后的 <code>props</code> 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该方法有三个参数：</p> <ul><li><code>prevProps</code>: 更新前的<code>props</code></li> <li><code>prevState</code>: 更新前的<code>state</code></li> <li><code>snapshot: getSnapshotBeforeUpdate()</code>生命周期的返回值</li></ul> <h3 id="_3-组件卸载阶段"><a href="#_3-组件卸载阶段" class="header-anchor">#</a> 3. 组件卸载阶段</h3> <p>卸载阶段只有一个生命周期函数，<code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：</p> <ul><li>清除 timer，取消网络请求或清除</li> <li>取消在 componentDidMount() 中创建的订阅等；</li></ul> <p>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 <code>setState</code>，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。</p> <h3 id="_4-错误处理阶段"><a href="#_4-错误处理阶段" class="header-anchor">#</a> 4. 错误处理阶段</h3> <p><code>componentDidCatch(error, info)</code>，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶</p> <ul><li><code>error</code>：抛出的错误。</li> <li><code>info</code>：带有 <code>componentStack key</code> 的对象，其中包含有关组件引发错误的栈信息</li></ul> <h2 id="react-废弃了哪些生命周期-为什么"><a href="#react-废弃了哪些生命周期-为什么" class="header-anchor">#</a> <code>React</code> 废弃了哪些生命周期？为什么？</h2> <p>被废弃的三个函数都是在<code>render</code>之前，因为<code>fiber</code>的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外的一个原因则是，<code>React</code>想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及即将废弃的生命周期分析入手</p> <p><strong><code>componentWillMount</code></strong></p> <p>首先这个函数的功能完全可以使用<code>componentDidMount</code>和 <code>constructor</code>来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在<code>constructor</code>中执行，除此之外，如果在 <code>willMount</code> 中订阅事件，但在服务端这并不会执行 <code>willUnMount</code> 事件，也就是说服务端会导致内存泄漏所以 <code>componentWilIMount</code> 完全可以不使用，但使用者有时候难免因为各种各样的情况在 <code>componentWilMount</code>中做一些操作，那么<code>React</code>为了约束开发者，干脆就抛掉了这个<code>API</code></p> <p><strong><code>componentWillReceiveProps</code></strong></p> <p>在老版本的 <code>React</code> 中，如果组件自身的某个 <code>state</code> 跟其 <code>props</code> 密切相关的话，一直都没有一种很优雅的处理方式去更新 <code>state</code>，而是需要在 <code>componentWilReceiveProps</code> 中判断前后两个 <code>props</code> 是否相同，如果不同再将新的 <code>props</code>更新到相应的 <code>state</code> 上去。这样做一来会破坏 <code>state</code> 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 <code>Tab</code> 显然隶属于列表自身的时，根据传入的某个值，直接定位到某个 <code>Tab</code>。为了解决这些问题，<code>React</code>引入了第一个新的生命周期：<code>getDerivedStateFromProps</code>。它有以下的优点∶</p> <ul><li><code>getDSFP</code>是静态方法，在这里不能使用<code>this</code>，也就是一个纯函数，开发者不能写出副作用的代码</li> <li>开发者只能通过<code>prevState</code>而不是<code>prevProps</code>来做对比，保证了<code>state</code>和<code>props</code>之间的简单关系以及不需要处理第一次渲染时<code>prevProps</code>为空的情况</li> <li>基于第一点，将状态变化（<code>setState</code>）和昂贵操作（<code>tabChange</code>）区分开，更加便于 <code>render</code> 和 <code>commit</code> 阶段操作或者说优化。</li></ul> <p><strong><code>componentWillUpdate</code></strong></p> <p>与 <code>componentWillReceiveProps</code> 类似，许多开发者也会在 <code>componentWillUpdate</code> 中根据 <code>props</code> 的变化去触发一些回调 。 但不论是 <code>componentWilReceiveProps</code> 还 是 <code>componentWilUpdate</code>，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 <code>componentDidMount</code> 类似， <code>componentDidUpdate</code> 也不存在这样的问题，一次更新中 <code>componentDidUpdate</code> 只会被调用一次，所以将原先写在 <code>componentWillUpdate</code> 中的回调迁移至 <code>componentDidUpdate</code> 就可以解决这个问题。</p> <p>另外一种情况则是需要获取<code>DOM</code>元素状态，但是由于在<code>fiber</code>中，<code>render</code>可打断，可能在<code>wilMount</code>中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决 <code>getSnapshotBeforeUpdate(prevProps, prevState)</code></p> <p><strong><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></strong></p> <p>返回的值作为<code>componentDidUpdate</code>的第三个参数。与<code>willMount</code>不同的是，<code>getSnapshotBeforeUpdate</code>会在最终确定的<code>render</code>执行之前执行，也就是能保证其获取到的元素状态与<code>didUpdate</code>中获取到的元素状态相同。官方参考代码：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">ScrollingList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 我们是否在 list 中添加新的 items ？</span>
    <span class="token comment">// 捕获滚动位置以便我们稍后调整滚动位置。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevProps<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
      <span class="token keyword">return</span> list<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> list<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span>
    <span class="token comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span>
    <span class="token comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>snapshot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
      list<span class="token punctuation">.</span>scrollTop <span class="token operator">=</span> list<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> snapshot<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token comment">/* ...contents... */</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h2 id="react-16-x-中-props-改变后在哪个生命周期中处理"><a href="#react-16-x-中-props-改变后在哪个生命周期中处理" class="header-anchor">#</a> <code>React 16.X</code> 中 <code>props</code> 改变后在哪个生命周期中处理</h2> <p><strong>在<code>getDerivedStateFromProps</code> 中进行处理。</strong></p> <p>这个生命周期函数是为了替代<code>componentWillReceiveProps</code>存在的，所以在需要使用<code>componentWillReceiveProps</code>时，就可以考虑使用<code>getDerivedStateFromProps</code>来进行替代。</p> <p>两者的参数是不相同的，而<code>getDerivedStateFromProps</code>是一个静态函数，也就是这个函数不能通过<code>this</code>访问到<code>class</code>的属性，也并不推荐直接访问属性。而是应该通过参数提供的<code>nextProps</code>以及<code>prevState</code>来进行判断，根据新传入的<code>props</code>来映射到<code>state</code>。</p> <p>需要注意的是，<strong>如果<code>props</code>传入的内容不需要影响到你的<code>state</code>，那么就需要返回一个<code>null</code></strong>，这个返回值是必须的，所以尽量将其写到函数的末尾：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>type<span class="token punctuation">}</span> <span class="token operator">=</span> nextProps<span class="token punctuation">;</span>
    <span class="token comment">// 当传入的type发生变化的时候，更新state</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            type<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 否则，对于state不进行任何操作</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="react-性能优化在哪个生命周期-它优化的原理是什么"><a href="#react-性能优化在哪个生命周期-它优化的原理是什么" class="header-anchor">#</a> <code>React</code> 性能优化在哪个生命周期？它优化的原理是什么？</h2> <p><code>react</code>的父级组件的<code>render</code>函数重新渲染会引起子组件的<code>render</code>方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件<code>render</code>的执行会影响性能，这时就可以使用<code>shouldComponentUpdate</code>来解决这个问题。</p> <p>使用方法如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nexrProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>num <span class="token operator">===</span> nexrProps<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>shouldComponentUpdate</code>提供了两个参数<code>nextProps</code>和<code>nextState</code>，表示下一次<code>props</code>和一次<code>state</code>的值，当函数返回<code>false</code>时候，<code>render()</code>方法不执行，组件也就不会渲染，返回<code>true</code>时，组件照常重渲染。此方法就是拿当前<code>props</code>中值和下一次<code>props</code>中的值进行对比，数据相等时，返回<code>false</code>，反之返回<code>true</code>。</p> <p>需要注意，在进行新旧对比的时候，是**浅对比，**也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为<code>true</code>。</p> <p>面对这个问题，可以使用如下方法进行解决：</p> <ol><li>使用<code>setState</code>改变数据之前，先采用<code>ES6</code>中<code>assgin</code>进行拷贝，但是<code>assgin</code>只深拷贝的数据的第一层，所以说不是最完美的解决办法：</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> o2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
o2<span class="token punctuation">.</span>student<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token string">'00000'</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  obj<span class="token operator">:</span> o2<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>使用<code>JSON.parse(JSON.stringfy())</code>进行深拷贝，但是遇到数据为<code>undefined</code>和函数时就会错。</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> o2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
o2<span class="token punctuation">.</span>student<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token string">'00000'</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  obj<span class="token operator">:</span> o2<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="state-和-props-触发更新的生命周期分别有什么区别"><a href="#state-和-props-触发更新的生命周期分别有什么区别" class="header-anchor">#</a> <code>state</code> 和 <code>props</code> 触发更新的生命周期分别有什么区别？</h2> <p><strong><code>state</code> 更新流程：</strong> <img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202205020006603.awebp" alt="img"> 这个过程当中涉及的函数：</p> <ol><li><code>shouldComponentUpdate</code>: 当组件的 <code>state</code> 或 <code>props</code> 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：<code>nextProps</code>, <code>nextState</code>——它们分别代表传入的新 <code>props</code> 和新的 <code>state</code> 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 <code>re-render</code>（重渲染）的必要了。如果该函数的返回值为 <code>false</code>，则生命周期终止，反之继续；</li></ol> <blockquote><p>注意：此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 <code>bug</code>。应该<strong>考虑使用内置的 <code>PureComponent</code> 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code></p></blockquote> <ol><li><code>componentWillUpdate</code>：当组件的 <code>state</code> 或 <code>props</code> 发生改变时，会在渲染之前调用 <code>componentWillUpdate</code>。<code>componentWillUpdate</code> <strong>是 <code>React16</code> 废弃的三个生命周期之一</strong>。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 <code>DOM</code> 信息等等），现在我们完全可以在 <code>React16</code> 的 <code>getSnapshotBeforeUpdate</code> 中去做这些事；</li> <li><code>componentDidUpdate</code>：<code>componentDidUpdate()</code> 会在<code>UI</code>更新后会被立即调用。它接收 <code>prevProps</code>（上一次的 <code>props</code> 值）作为入参，也就是说在此处我们仍然可以进行 <code>props</code> 值对比（再次说明 <code>componentWillUpdate</code> 确实鸡肋哈）。</li></ol> <hr> <p><strong><code>props</code> 更新流程：</strong> <img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202205020924415.awebp" alt="img"> 相对于 <code>state</code> 更新，<code>props</code> 更新后唯一的区别是增加了对 <code>componentWillReceiveProps</code> 的调用。关于 <code>componentWillReceiveProps</code>，需要知道这些事情：</p> <ul><li><code>componentWillReceiveProps</code>：它在<code>Component</code>接受到新的 <code>props</code> 时被触发。<code>componentWillReceiveProps</code> 会接收一个名为 <code>nextProps</code> 的参数（对应新的 <code>props</code> 值）。<strong>该生命周期是 <code>React16</code> 废弃掉的三个生命周期之一</strong>。在它被废弃前，可以用它来比较 <code>this.props</code> 和 <code>nextProps</code> 来重新<code>setState</code>。在 <code>React16</code> 中，用一个类似的新生命周期 <code>getDerivedStateFromProps</code> 来代替它。</li></ul> <h2 id="react中发起网络请求应该在哪个生命周期中进行-为什么"><a href="#react中发起网络请求应该在哪个生命周期中进行-为什么" class="header-anchor">#</a> <code>React</code>中发起网络请求应该在哪个生命周期中进行？为什么？</h2> <p>对于异步请求，最好放在<code>componentDidMount</code>中去操作，对于同步的状态改变，可以放在<code>componentWillMount</code>中，一般用的比较少。</p> <p>如果认为在<code>componentWillMount</code>里发起请求能提早获得结果，这种想法其实是错误的，通常<code>componentWillMount</code>比<code>componentDidMount</code>早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。</p> <p><strong><code>react</code>的生命周期：</strong> <code>constructor()</code> -&gt; <code>componentWillMount()</code> -&gt; <code>render()</code> -&gt; <code>componentDidMount()</code></p> <p>上面这些方法的调用是有次序的，由上而下依次调用。</p> <ul><li><code>constructor</code>被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。</li> <li><code>componentWillMount</code>方法的调用在<code>constructor</code>之后，在<code>render</code>之前，在这方法里的代码调用<code>setState</code>方法不会触发重新<code>render</code>，所以它一般不会用来作加载数据之用。</li> <li><code>componentDidMount</code>方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用<code>setState</code>方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在<code>constructor</code>里做，但<code>constructor</code>是做组件<code>state</code>初绐化工作，并不是做加载数据这工作的，<code>constructor</code>里也不能<code>setState</code>，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在<code>componentDidMount</code>方法里。</li></ul> <p>总结：</p> <ul><li>跟服务器端渲染（同构）有关系，如果在<code>componentWillMount</code>里面获取数据，<code>fetch data</code>会执行两次，一次在服务器端一次在客户端。在<code>componentDidMount</code>中可以解决这个问题，<code>componentWillMount</code>同样也会<code>render</code>两次。</li> <li>在<code>componentWillMount</code>中<code>fetch data</code>，数据一定在<code>render</code>后才能到达，如果忘记了设置初始状态，用户体验不好。</li> <li><code>react16.0</code>以后，<code>componentWillMount</code>可能会被执行多次。</li></ul> <h2 id="react-16中新生命周期有哪些"><a href="#react-16中新生命周期有哪些" class="header-anchor">#</a> <code>React 16</code>中新生命周期有哪些</h2> <p>关于 <code>React16</code> 开始应用的新生命周期： <img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202205020929769.awebp" alt="img"> 可以看出，<code>React16</code> 自上而下地对生命周期做了另一种维度的解读：</p> <ul><li><strong><code>Render</code> 阶段</strong>：用于计算一些必要的状态信息。这个阶段可能会被 <code>React</code> 暂停，这一点和 <code>React16</code> 引入的 <code>Fiber</code> 架构（我们后面会重点讲解）是有关的；</li> <li><strong><code>Pre-commit</code>阶段</strong>：所谓“<code>commit</code>”，这里指的是“更新真正的 <code>DOM</code> 节点”这个动作。所谓 <code>Pre-commit</code>，就是说我在这个阶段其实还并没有去更新真实的 <code>DOM</code>，不过 <code>DOM</code> 信息已经是可以读取的了；</li> <li><strong><code>Commit</code> 阶段</strong>：在这一步，<code>React</code> 会完成真实 <code>DOM</code> 的更新工作。<code>Commit</code> 阶段，我们可以拿到真实 <code>DOM</code>（包括 <code>refs</code>）。</li></ul> <p>与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：</p> <ul><li>挂载过程：
<ul><li><strong><code>constructor</code></strong></li> <li><strong><code>getDerivedStateFromProps</code></strong></li> <li><strong><code>render</code></strong></li> <li><strong><code>componentDidMount</code></strong></li></ul></li> <li>更新过程：
<ul><li><strong><code>getDerivedStateFromProps</code></strong></li> <li><strong><code>shouldComponentUpdate</code></strong></li> <li><strong><code>render</code></strong></li> <li><strong><code>getSnapshotBeforeUpdate</code></strong></li> <li><strong><code>componentDidUpdate</code></strong></li></ul></li> <li>卸载过程：
<ul><li><strong><code>componentWillUnmount</code></strong></li></ul></li></ul></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/05/02, 12:25:10</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/24db5f/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">数据管理</div></a> <a href="/pages/be9376/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">组件通信</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/24db5f/" class="prev">数据管理</a></span> <span class="next"><a href="/pages/be9376/">组件通信</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://github.com/duochizhacai" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://juejin.cn/user/1249486902410744" title="JueJin" target="_blank" class="iconfont icon-juejin"></a></div> 
    Copyright © 2021-2022
    <span><a href='https://beian.miit.gov.cn'>粤ICP备2021165371号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.95fc12d6.js" defer></script><script src="/assets/js/2.abf57e2f.js" defer></script><script src="/assets/js/45.e623e04e.js" defer></script>
  </body>
</html>
