<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue基础 | 小宋爱睡觉</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="🚀一个前端程序员小白的博客🌹">
    <meta name="keywords" content="blog,crucials,frontend,前端,小宋爱睡觉,博客,duochizhacai">
    <meta name="theme-color" content="#60ad81">
    
    <link rel="preload" href="/assets/css/0.styles.65787d8c.css" as="style"><link rel="preload" href="/assets/js/app.95fc12d6.js" as="script"><link rel="preload" href="/assets/js/2.abf57e2f.js" as="script"><link rel="preload" href="/assets/js/15.753bb2dc.js" as="script"><link rel="preload" href="/assets/js/3.e687237e.js" as="script"><link rel="prefetch" href="/assets/js/10.9d6bb65c.js"><link rel="prefetch" href="/assets/js/11.bea1ca2d.js"><link rel="prefetch" href="/assets/js/12.a5ced6a2.js"><link rel="prefetch" href="/assets/js/13.ec1bcac6.js"><link rel="prefetch" href="/assets/js/14.4e5bcc62.js"><link rel="prefetch" href="/assets/js/16.a6e51bcc.js"><link rel="prefetch" href="/assets/js/17.25227dca.js"><link rel="prefetch" href="/assets/js/18.19267273.js"><link rel="prefetch" href="/assets/js/19.a9403a12.js"><link rel="prefetch" href="/assets/js/20.c007e659.js"><link rel="prefetch" href="/assets/js/21.dca7af69.js"><link rel="prefetch" href="/assets/js/22.d9f25771.js"><link rel="prefetch" href="/assets/js/23.2668c7ed.js"><link rel="prefetch" href="/assets/js/24.30c858a4.js"><link rel="prefetch" href="/assets/js/25.bd21abb1.js"><link rel="prefetch" href="/assets/js/26.28d250cb.js"><link rel="prefetch" href="/assets/js/27.a60d212f.js"><link rel="prefetch" href="/assets/js/28.8a5c2c34.js"><link rel="prefetch" href="/assets/js/29.4688a5d6.js"><link rel="prefetch" href="/assets/js/30.5985f3b4.js"><link rel="prefetch" href="/assets/js/31.7ee5d916.js"><link rel="prefetch" href="/assets/js/32.2f711dea.js"><link rel="prefetch" href="/assets/js/33.45a4e58a.js"><link rel="prefetch" href="/assets/js/34.6a46cad8.js"><link rel="prefetch" href="/assets/js/35.79084a19.js"><link rel="prefetch" href="/assets/js/36.9a5cf509.js"><link rel="prefetch" href="/assets/js/37.ea6b36a3.js"><link rel="prefetch" href="/assets/js/38.1ebed809.js"><link rel="prefetch" href="/assets/js/39.16200e67.js"><link rel="prefetch" href="/assets/js/4.4a0efd85.js"><link rel="prefetch" href="/assets/js/40.db1f5064.js"><link rel="prefetch" href="/assets/js/41.5c8205b4.js"><link rel="prefetch" href="/assets/js/42.d8e671a9.js"><link rel="prefetch" href="/assets/js/43.80c6d459.js"><link rel="prefetch" href="/assets/js/44.0dc33dbe.js"><link rel="prefetch" href="/assets/js/45.e623e04e.js"><link rel="prefetch" href="/assets/js/46.b9a46fc2.js"><link rel="prefetch" href="/assets/js/47.2d5eb349.js"><link rel="prefetch" href="/assets/js/48.8d4e8a09.js"><link rel="prefetch" href="/assets/js/49.f7f58461.js"><link rel="prefetch" href="/assets/js/5.84799806.js"><link rel="prefetch" href="/assets/js/50.b482896d.js"><link rel="prefetch" href="/assets/js/51.9ad2b264.js"><link rel="prefetch" href="/assets/js/52.7862671c.js"><link rel="prefetch" href="/assets/js/53.d8153804.js"><link rel="prefetch" href="/assets/js/54.0af2674d.js"><link rel="prefetch" href="/assets/js/55.597b91b8.js"><link rel="prefetch" href="/assets/js/56.46804158.js"><link rel="prefetch" href="/assets/js/57.006f6db0.js"><link rel="prefetch" href="/assets/js/58.751e40d0.js"><link rel="prefetch" href="/assets/js/59.b0ebe0e6.js"><link rel="prefetch" href="/assets/js/6.f7ec0152.js"><link rel="prefetch" href="/assets/js/60.8d675b12.js"><link rel="prefetch" href="/assets/js/61.55190a7f.js"><link rel="prefetch" href="/assets/js/62.117f5f66.js"><link rel="prefetch" href="/assets/js/63.b848bfe2.js"><link rel="prefetch" href="/assets/js/64.000227a3.js"><link rel="prefetch" href="/assets/js/65.9ec404e1.js"><link rel="prefetch" href="/assets/js/66.1834b2b1.js"><link rel="prefetch" href="/assets/js/67.bf716de8.js"><link rel="prefetch" href="/assets/js/68.6e03054c.js"><link rel="prefetch" href="/assets/js/69.c6605c56.js"><link rel="prefetch" href="/assets/js/7.40c08f02.js"><link rel="prefetch" href="/assets/js/70.30051d78.js"><link rel="prefetch" href="/assets/js/71.1fdc7d36.js"><link rel="prefetch" href="/assets/js/72.4b0ad4ad.js"><link rel="prefetch" href="/assets/js/73.e989ab6d.js"><link rel="prefetch" href="/assets/js/74.02429c23.js"><link rel="prefetch" href="/assets/js/75.8f044cef.js"><link rel="prefetch" href="/assets/js/76.7acc2de5.js"><link rel="prefetch" href="/assets/js/77.ce127400.js"><link rel="prefetch" href="/assets/js/78.deb1ae24.js"><link rel="prefetch" href="/assets/js/79.75a4c78b.js"><link rel="prefetch" href="/assets/js/8.303c64d8.js"><link rel="prefetch" href="/assets/js/80.6c258060.js"><link rel="prefetch" href="/assets/js/81.563a0c28.js"><link rel="prefetch" href="/assets/js/82.143b4caf.js"><link rel="prefetch" href="/assets/js/83.32431b7f.js"><link rel="prefetch" href="/assets/js/84.2320a5a5.js"><link rel="prefetch" href="/assets/js/85.d9a1625a.js"><link rel="prefetch" href="/assets/js/86.dc0f47f2.js"><link rel="prefetch" href="/assets/js/87.8335157f.js"><link rel="prefetch" href="/assets/js/88.2cfc7001.js"><link rel="prefetch" href="/assets/js/89.6bc590c2.js"><link rel="prefetch" href="/assets/js/9.7ba1b2de.js"><link rel="prefetch" href="/assets/js/90.c20801a7.js"><link rel="prefetch" href="/assets/js/91.1a32fafc.js"><link rel="prefetch" href="/assets/js/92.4a802465.js">
    <link rel="stylesheet" href="/assets/css/0.styles.65787d8c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/logo.png" alt="小宋爱睡觉" class="logo"> <span class="site-name can-hide">小宋爱睡觉</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><a href="/pages/56881f/" class="link-title">知识库</a> <span class="title" style="display:none;">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/56881f/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/c0e7f0/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/pages/787250/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/f0a671/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/b7238f/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/pages/2448f7/" class="nav-link">计算机网络</a></li><li class="dropdown-item"><!----> <a href="/pages/b8bd46/" class="nav-link">浏览器原理</a></li><li class="dropdown-item"><!----> <a href="/pages/f15087/" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/pages/e3cba5/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/pages/ba01c4/" class="nav-link">手写系列</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/pages/ad5191/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8ac126/" class="nav-link">字符串</a></li><li class="dropdown-item"><!----> <a href="/pages/251490/" class="nav-link">数组</a></li><li class="dropdown-item"><!----> <a href="/pages/fc9745/" class="nav-link">链表</a></li><li class="dropdown-item"><!----> <a href="/pages/ad5191/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/pages/6aee18/" class="nav-link">动态规划</a></li><li class="dropdown-item"><!----> <a href="/pages/78e948/" class="nav-link">排序算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><a href="/pages/f0a671/https://github.com/duochizhacai" class="link-title">GitHub</a> <span class="title" style="display:none;">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duochizhacai" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/1249486902410744" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JueJin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识库" class="dropdown-title"><a href="/pages/56881f/" class="link-title">知识库</a> <span class="title" style="display:none;">知识库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/56881f/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/c0e7f0/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/pages/787250/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/f0a671/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/b7238f/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/pages/2448f7/" class="nav-link">计算机网络</a></li><li class="dropdown-item"><!----> <a href="/pages/b8bd46/" class="nav-link">浏览器原理</a></li><li class="dropdown-item"><!----> <a href="/pages/f15087/" class="nav-link">性能优化</a></li><li class="dropdown-item"><!----> <a href="/pages/e3cba5/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><a href="/pages/ba01c4/" class="nav-link">手写系列</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/pages/ad5191/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8ac126/" class="nav-link">字符串</a></li><li class="dropdown-item"><!----> <a href="/pages/251490/" class="nav-link">数组</a></li><li class="dropdown-item"><!----> <a href="/pages/fc9745/" class="nav-link">链表</a></li><li class="dropdown-item"><!----> <a href="/pages/ad5191/" class="nav-link">树</a></li><li class="dropdown-item"><!----> <a href="/pages/6aee18/" class="nav-link">动态规划</a></li><li class="dropdown-item"><!----> <a href="/pages/78e948/" class="nav-link">排序算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><a href="/pages/f0a671/https://github.com/duochizhacai" class="link-title">GitHub</a> <span class="title" style="display:none;">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duochizhacai" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/1249486902410744" target="_blank" rel="noopener noreferrer" class="nav-link external">
  JueJin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/f0a671/" aria-current="page" class="active sidebar-link">Vue基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/f0a671/#介绍一下vue原理" class="sidebar-link">介绍一下Vue原理</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#介绍一下vue双向绑定的原理" class="sidebar-link">介绍一下Vue双向绑定的原理</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#介绍一下什么是mvvm、mvc、mvp" class="sidebar-link">介绍一下什么是MVVM、MVC、MVP</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#说一下computed和watch的区别" class="sidebar-link">说一下computed和watch的区别</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#说一下slot都有哪些用法-原理是什么" class="sidebar-link">说一下slot都有哪些用法 原理是什么</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#介绍一下保存页面状态的方法" class="sidebar-link">介绍一下保存页面状态的方法</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#v-if-和-v-show的区别" class="sidebar-link">v-if 和 v-show的区别</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#v-if原理和v-show原理" class="sidebar-link">v-if原理和v-show原理</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#data为什么是一个函数而不是对象" class="sidebar-link">data为什么是一个函数而不是对象？</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#为什么访问data属性不需要带data" class="sidebar-link">为什么访问data属性不需要带data?</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#v-model的原理" class="sidebar-link">v-model的原理</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#对keep-alive的理解-如何实现-具体是如何缓存的" class="sidebar-link">对keep-alive的理解 如何实现 具体是如何缓存的？</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#nexttick原理" class="sidebar-link">$nextTick原理</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="sidebar-link">Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue模板渲染的原理是什么" class="sidebar-link">Vue模板渲染的原理是什么？</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#子组件可以直接改变父组件的数据吗" class="sidebar-link">子组件可以直接改变父组件的数据吗</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue和react的理解和异同" class="sidebar-link">Vue和React的理解和异同</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue的优点" class="sidebar-link">Vue的优点</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#assets和static的区别" class="sidebar-link">assets和static的区别</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue如何监听对象和数组的某个属性改变" class="sidebar-link">Vue如何监听对象和数组的某个属性改变</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#对ssr的理解" class="sidebar-link">对ssr的理解</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue的性能优化" class="sidebar-link">Vue的性能优化</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#对spa的理解-优缺点是什么" class="sidebar-link">对SPA的理解 优缺点是什么</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#template和jsx区别" class="sidebar-link">template和jsx区别</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue初始化页面为什么会闪动" class="sidebar-link">Vue初始化页面为什么会闪动</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#mixin和mixins区别" class="sidebar-link">mixin和mixins区别</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#mvvm优缺点" class="sidebar-link">MVVM优缺点</a></li><li class="sidebar-sub-header"><a href="/pages/f0a671/#vue中使用了哪些设计模式" class="sidebar-link">vue中使用了哪些设计模式？</a></li></ul></li><li><a href="/pages/4db11c/" class="sidebar-link">Vue生命周期</a></li><li><a href="/pages/43f778/" class="sidebar-link">组件通信</a></li><li><a href="/pages/98d1fc/" class="sidebar-link">Vue-Router</a></li><li><a href="/pages/07ebf2/" class="sidebar-link">VueX</a></li><li><a href="/pages/8630df/" class="sidebar-link">Vue3</a></li><li><a href="/pages/fdc247/" class="sidebar-link">VirtualDOM</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><span data-v-1cd794fe>Vue</span></li> <!----> <!----></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/duochizhacai" target="_blank" title="作者" class="beLink" data-v-1cd794fe>Crucials</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-11-28</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">
          Vue基础
        </h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="vue基础"><a href="#vue基础" class="header-anchor">#</a> Vue基础</h1> <h2 id="介绍一下vue原理"><a href="#介绍一下vue原理" class="header-anchor">#</a> 介绍一下<code>Vue</code>原理<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <p>创建实例 -&gt; 遍历<code>data</code>的属性 -&gt; 用(<code>object.defineProperty/proxy</code>)转化为<code>getter</code>/<code>setter</code>）-&gt; 在实例中的<code>watcher</code>收集<code>data</code>的属性 -&gt; 当<code>data</code>的属性改变触发<code>setter</code>的时候通知<code>watcher</code> -&gt; <code>watch</code>会将关联的组件都更新一遍</p> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202111281717626.png" alt="img"></p> <h2 id="介绍一下vue双向绑定的原理"><a href="#介绍一下vue双向绑定的原理" class="header-anchor">#</a> 介绍一下<code>Vue</code>双向绑定的原理<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <p>采用了<strong>数据劫持</strong>和<strong>发布订阅</strong>的方式</p> <div class="custom-block tip"><p class="custom-block-title">数据劫持的笼统意思</p> <p><code>observe</code>的数据对象进行递归遍历，然后添加上<code>getter</code>和<code>setter</code>，当值改变的时候会触发<code>setter</code>，就能监听到数据的变化了</p></div> <div class="custom-block tip"><p class="custom-block-title">发布订阅的意思</p> <p><code>compile</code>解析模板数据，然后将模板上面的变量替换成数据，然后初始化渲染视图，将每个指令对应的节点绑定更新函数 添加监听数据的订阅者 ，数据变动 -&gt; 收到通知 -&gt; 更新视图</p></div> <p>而<code>watcher</code>订阅者就是连接<code>observe</code>和<code>compile</code>的桥梁</p> <ol><li><p>在属性订阅器中(<code>dep</code>) 添加实例化的<code>watcher</code></p></li> <li><p><code>watcher</code>的实例自身有个<code>update</code>方法</p></li> <li><p>属性变动的时候调用<code>dep.notify()</code></p></li> <li><p>调用节点绑定的更新函数<code>update()</code></p></li> <li><p>触发<code>compile</code>绑定的函数</p></li></ol> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202111281723812.png" alt="img"></p> <p><strong>总结：</strong></p> <ul><li><p><code>Vue</code></p> <ul><li>记录传入的选项，设置 <code>$data/$el</code></li> <li>把 <code>data</code> 的成员注入到 <code>Vue</code> 实例</li> <li>负责调用 <code>Observer</code> 实现数据响应式处理(数据劫持)</li> <li>负责调用 <code>Compiler</code> 编译指令/插值表达式等</li></ul></li> <li><p><code>Observer</code></p> <ul><li>数据劫持
<ul><li>负责把 <code>data</code> 中的成员转换成 <code>getter/setter</code></li> <li>负责把多层属性转换成 <code>getter/setter</code></li> <li>如果给属性赋值为新对象，把新对象的成员设置为 <code>getter/setter</code></li></ul></li> <li>添加 <code>Dep</code> 和 <code>Watcher</code> 的依赖关系</li> <li>数据变化发送通知</li></ul></li> <li><p><code>Compiler</code></p> <ul><li>负责编译模板，解析指令/插值表达式</li> <li>负责页面的首次渲染过程</li> <li>当数据变化后重新渲染</li></ul></li> <li><p><code>Dep</code></p> <ul><li>收集依赖，添加订阅者(<code>watcher</code>)</li> <li>通知所有订阅者</li></ul></li> <li><p><code>Watcher</code></p> <ul><li>自身实例化的时候往<code>dep</code>对象中添加自己</li> <li>当数据变化<code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li></ul></li></ul> <h2 id="介绍一下什么是mvvm、mvc、mvp"><a href="#介绍一下什么是mvvm、mvc、mvp" class="header-anchor">#</a> 介绍一下什么是<code>MVVM</code>、<code>MVC</code>、<code>MVP</code> <span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <blockquote><p><code>mvvm</code>是 <code>model</code> <code>view</code> <code>viewModel</code></p></blockquote> <ul><li><p><code>model</code>层代表数据模型 数据和业务逻辑都在<code>model</code>层</p></li> <li><p><code>view</code>代表<code>ui</code>视图 负责数据的展示</p></li> <li><p><code>viewModel</code> 监听<code>model</code>数据的改变并控制视图更新，处理交互</p></li></ul> <p><code>model</code>和<code>view</code>无直接连接 而是通过<code>viewModel</code>进行联系，<code>model</code>和<code>viewModel</code>数据双向绑定，<code>view</code>层交互改变的数据 <code>model</code>层也会改变，<code>model</code>层数据改变也会触发<code>view</code>层的更新，这样程序猿们就可以专心在<code>viewModel</code>层编写业务逻辑，不用关心数据的传递</p> <p><strong>但是<code>Vue</code> 并没有完全遵循 <code>MVVM</code> 思想呢？</strong></p> <ul><li>严格的 <code>MVVM</code> 要求 <code>View</code> 不能和 <code>Model</code> 直接通信，而 <code>Vue</code> 提供了 <code>$refs</code> 这个属性，让 <code>Model</code> 可以直接操作 <code>View</code>，违反了这一规定，所以说 <code>Vue</code> 没有完全遵循 <code>MVVM</code>。</li></ul> <blockquote><p><code>mvc</code>是<code>model</code> <code>view</code> <code>controller</code></p></blockquote> <ul><li><p><code>view</code>代表<code>ui</code>视图</p></li> <li><p><code>model</code>储存页面的数据</p></li> <li><p><code>controller</code>层负责用户与应用的响应操作</p></li></ul> <p><code>view</code>和<code>model</code>层应用了观察者模式，<code>model</code>层数据变化会通知<code>view</code>进行更新，用户操作 <code>controller</code>触发，调用<code>model</code>修改 然后再通知<code>view</code>进行更新</p> <blockquote><p><code>mvp</code>跟<code>mvc</code>大致相同</p></blockquote> <ul><li><code>mvc</code>中的<code>model</code>和<code>view</code>层都耦合在一起，当逻辑复杂时候会造成代码混乱，通过<code>mvp</code>的<code>presenter</code>层，将<code>model</code>和<code>view</code>绑定在一起，实现同步更新，实现对<code>view</code>和<code>model</code>层的解耦</li></ul> <h2 id="说一下computed和watch的区别"><a href="#说一下computed和watch的区别" class="header-anchor">#</a> 说一下<code>computed</code>和<code>watch</code>的区别<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <p><code>computed</code>计算属性：依赖其他属性值，不支持异步，并且有缓存，只有当依赖的属性值发生改变且有属性值引用它时才会重新计算<code>computed</code>的值（例如购物车的价格就可以用<code>computed</code>）</p> <p><code>watch</code>监听器：只是充当观察作用，支持异步，无缓存，类似某种数据监听回调，当监听的数据变化执行回调进行后续操作（适用于当数据变化需要执行异步方法或开销比较大的操作）</p> <h2 id="说一下slot都有哪些用法-原理是什么"><a href="#说一下slot都有哪些用法-原理是什么" class="header-anchor">#</a> 说一下<code>slot</code>都有哪些用法 原理是什么</h2> <p>默认插槽：没有指定<code>name</code>的时候 会指定默认插槽，一个组件只能有一个</p> <p>具名插槽：指定了<code>name</code>属性的<code>slot</code>，一个组件可以有多个具名插槽</p> <p>作用域插槽：可以是匿名插槽也可以是作用域插槽，可以将子组件内部的数据传递给父组件</p> <blockquote><p>原理：当子组件实例化时，获取父组件传入<code>slot</code>标签的内容，存在<code>vm.$slot</code>，默认插槽为<code>vm.$slot.default</code> 具名插槽为<code>vm.$slot.xxx</code>，当组件执行渲染函数的时候，遇到<code>slot</code>，使用<code>$slot</code>内容替换，此时可以为插槽传递数据，则叫作用域插槽</p></blockquote> <h2 id="介绍一下保存页面状态的方法"><a href="#介绍一下保存页面状态的方法" class="header-anchor">#</a> 介绍一下保存页面状态的方法</h2> <blockquote><p>前组件会被卸载</p></blockquote> <ul><li><p>将当前组件的<code>state</code>通过<code>JSON.stringify()</code>储存在<code>LocalStorage</code> / <code>SessionStorage</code></p> <ul><li><p>优点：兼容性好，不需要额外使用库和工具</p></li> <li><p>缺点：相当于<code>JSON.stringify()</code>的缺点(<code>Date</code>对象<code>Reg</code>对象会出错) 组件回退或者前进会出<code>bug</code></p></li></ul></li> <li><p>通过<code>react-router</code> 的 <code>Link</code> 组件的 <code>prop —— to</code> 可以实现路由间传递参数 通过<code>history.location.state</code>拿到状态进行传参</p></li> <li><p>优点 简单快捷 不污染<code>LocalStorage</code> / <code>SessionStorage</code> 解决<code>JSON.stringify()</code>的缺点</p></li> <li><p>缺点 当前组件可以跳转至多个组件 在跳转组件要多次写相同逻辑</p></li></ul> <blockquote><p>前组件不会被卸载</p></blockquote> <ul><li><p>单页面渲染 要写换的组件作为子组件全屏渲染</p> <ul><li><p>优点 代码少 状态传递不出错</p></li> <li><p>缺点 需要传递额外<code>prop</code>到子组件 无法利用路由定位</p></li></ul></li></ul> <blockquote><p>利用 <code>keep-alive</code> 切换时的<code>actived</code> <code>deactivate</code>被执行</p></blockquote> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>router<span class="token operator">-</span>view v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;$route.meta.keepAlive&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>kepp<span class="token operator">-</span>alive<span class="token operator">&gt;</span>

<span class="token comment">// router.js</span>
<span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../src/views/xxx.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  meta<span class="token operator">:</span><span class="token punctuation">{</span>
    keepAlive<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 需要被缓存</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>缺点很明显，当页面刷新的时候<code>Vue</code>中的数据会丢失</li></ul> <h2 id="v-if-和-v-show的区别"><a href="#v-if-和-v-show的区别" class="header-anchor">#</a> <code>v-if</code> 和 <code>v-show</code>的区别<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <ul><li>手段：<code>v-if</code>是动态向<code>dom</code>树中添加或者删除<code>dom</code> <code>v-show</code>是设置<code>display</code>来隐藏</li> <li>编译过程：<code>v-if</code>有一个局部编译和卸载的过程，切换过程合适地销毁和重建内部的事件监听和子组件 <code>v-show</code>只是基于<code>css</code>切换</li> <li>编译条件：<code>v-if</code>是惰性的 初始条件为假则什么都不做，只有第一次条件为真的时候才局部编译 <code>v-show</code>一开始就编译然后被缓存</li> <li>性能消耗：<code>v-if</code>更高的切换消耗 <code>v-show</code>有更高的初始渲染消耗</li> <li>使用场景：<code>v-if</code>适合运营条件不太改变的场景 <code>v-show</code>适合频繁切换</li></ul> <h2 id="v-if原理和v-show原理"><a href="#v-if原理和v-show原理" class="header-anchor">#</a> <code>v-if</code>原理和<code>v-show</code>原理</h2> <p><strong><code>v-show</code></strong></p> <p>不管初始条件是什么，元素总是会被渲染</p> <p>我们看一下在<code>vue</code>中是如何实现的</p> <p>代码很好理解，有<code>transition</code>就执行<code>transition</code>，没有就直接设置<code>display</code>属性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> vShow<span class="token operator">:</span> ObjectDirective<span class="token operator">&lt;</span>VShowElement<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">beforeMount</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> transition <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    el<span class="token punctuation">.</span>_vod <span class="token operator">=</span> el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">===</span> <span class="token string">'none'</span> <span class="token operator">?</span> <span class="token string">''</span> <span class="token operator">:</span> el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display
    <span class="token keyword">if</span> <span class="token punctuation">(</span>transition <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      transition<span class="token punctuation">.</span><span class="token function">beforeEnter</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">setDisplay</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> transition <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>transition <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      transition<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">updated</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token punctuation">,</span> oldValue <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> transition <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeUnmount</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setDisplay</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong><code>v-if</code></strong></p> <p><code>v-if</code>在实现上比<code>v-show</code>要复杂的多，因为还有<code>else</code> <code>else-if</code> 等条件需要处理，这里我们也只摘抄源码中处理 <code>v-if</code> 的一小部分</p> <p>返回一个<code>node</code>节点，<code>render</code>函数通过表达式的值来决定是否生成<code>DOM</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> transformIf <span class="token operator">=</span> <span class="token function">createStructuralDirectiveTransform</span><span class="token punctuation">(</span>
  <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(if|else|else-if)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">processIf</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">ifNode<span class="token punctuation">,</span> branch<span class="token punctuation">,</span> isRoot</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          ifNode<span class="token punctuation">.</span>codegenNode <span class="token operator">=</span> <span class="token function">createCodegenNodeForBranch</span><span class="token punctuation">(</span>
            branch<span class="token punctuation">,</span>
            key<span class="token punctuation">,</span>
            context
          <span class="token punctuation">)</span> <span class="token keyword">as</span> IfConditionalExpression
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// attach this branch's codegen node to the v-if root.</span>
          <span class="token keyword">const</span> parentCondition <span class="token operator">=</span> <span class="token function">getParentCondition</span><span class="token punctuation">(</span>ifNode<span class="token punctuation">.</span>codegenNode<span class="token operator">!</span><span class="token punctuation">)</span>
          parentCondition<span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token function">createCodegenNodeForBranch</span><span class="token punctuation">(</span>
            branch<span class="token punctuation">,</span>
            key <span class="token operator">+</span> ifNode<span class="token punctuation">.</span>branches<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
            context
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="data为什么是一个函数而不是对象"><a href="#data为什么是一个函数而不是对象" class="header-anchor">#</a> <code>data</code>为什么是一个函数而不是对象？<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <p>如果<code>data</code>是对象时，当组件多次被实例化时，引用的是同一个<code>data</code>对象，会导致不同实例操作数据，会相互影响，所以要写成函数形式，数据以返回值的形式定义，每次复用组件时，会返回新的<code>data</code>，每个组件都有自己私有数据空间，各自维护数据，不干扰其他组件正常运行</p> <h2 id="为什么访问data属性不需要带data"><a href="#为什么访问data属性不需要带data" class="header-anchor">#</a> 为什么访问<code>data</code>属性不需要带<code>data</code>?</h2> <blockquote><p><code>vue</code>中访问属性代理 <code>this.data.xxx</code> 转换 <code>this.xxx</code> 的实现</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">/** 将 某一个对象的属性 访问 映射到 对象的某一个属性成员上 */</span>
<span class="token keyword">function</span> <span class="token function">proxy</span><span class="token punctuation">(</span> <span class="token parameter">target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> key</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span> target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> target<span class="token punctuation">[</span> prop <span class="token punctuation">]</span><span class="token punctuation">[</span> key <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span> <span class="token punctuation">(</span> newVal <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      target<span class="token punctuation">[</span> prop <span class="token punctuation">]</span><span class="token punctuation">[</span> key <span class="token punctuation">]</span> <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="v-model的原理"><a href="#v-model的原理" class="header-anchor">#</a> <code>v-model</code>的原理<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <p>我们在 <code>vue</code> 项目中主要使用 <code>v-model</code> 指令在表单 <code>input</code>、<code>textarea</code>、<code>select</code> 等元素上创建双向数据绑定，我们知道 <code>v-model</code> 本质上不过是语法糖，<code>v-model</code> 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <ul><li><code>text</code> 和 <code>textarea</code> 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li> <li><code>checkbox</code> 和 <code>radio</code> 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li> <li><code>select</code> 字段将 <code>value</code> 作为 <code>prop</code> 并将 <code>change</code> 作为事件。</li></ul> <p>以 <code>input</code> 表单元素为例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">'something'</span><span class="token operator">&gt;</span>
    
<span class="token comment">// 相当于</span>

<span class="token operator">&lt;</span>input v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;something&quot;</span> v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;something = $event.target.value&quot;</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="对keep-alive的理解-如何实现-具体是如何缓存的"><a href="#对keep-alive的理解-如何实现-具体是如何缓存的" class="header-anchor">#</a> 对<code>keep-alive</code>的理解 如何实现 具体是如何缓存的？</h2> <div class="custom-block tip"><p class="custom-block-title">理解</p> <p>当组件需要切换是，保存一些组件 防止多次渲染，用<code>keep-alive</code>包裹</p></div> <p>有三个属性：</p> <ul><li><p><code>include</code> 字符串或正则表达式 只有名称匹配的组件会被匹配</p></li> <li><p><code>exclude</code> 字符串或正则表达式，任何名称匹配的组件都不会被缓存</p></li> <li><p><code>max</code>数字 最多可以缓存多少组件实例</p></li></ul> <p>流程：</p> <ol><li><p>判断组件的<code>name</code> 不在<code>include</code>或在<code>exclude</code>中，直接返回<code>vNode</code>不缓存</p></li> <li><p>获取组件实例<code>key</code></p> <ul><li><code>key</code>生成规则 <code>cid + &quot;::&quot; tag</code> 仅靠<code>cid</code>不够，因为相同构造函数都可以注册为不同本地组件</li></ul></li> <li><p>如果组件已缓存 就从缓存对象中获取组件实例给<code>vNode</code>，不存在则添加进缓存对象里面</p></li> <li><p>超过最大缓存数量，就用<code>LRU</code>清除数组内第一个组件</p></li></ol> <div class="custom-block warning"><p class="custom-block-title">keep-alive中的LRU算法(least recently used)</p> <p>通过<code>cache</code>数组存放所有组件的<code>vNode</code> 当<code>cache</code>中原有的组件被使用的时候，会将该组件的<code>key</code>从<code>keys</code>数组中删去，然后<code>push</code>到<code>keys</code>数组最后，以便超出<code>max</code>后删除最不常用的组件</p></div> <h2 id="nexttick原理"><a href="#nexttick原理" class="header-anchor">#</a> <code>$nextTick</code>原理<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <div class="custom-block tip"><p class="custom-block-title">原理</p> <p>利用<code>JS</code>原生的<code>Promise</code> <code>MutationObserver</code> <code>setImmediate</code> <code>setTimeout</code>的原生<code>JS</code>模拟对应的微/宏任务，为了利用<code>js</code>这种异步回调任务队列来实现<code>Vue</code>中自己的异步回调队列</p></div> <p><code>Vue</code>在更新<code>DOM</code>时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启<code>1</code>个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中<code>1</code>次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的<code>dom</code>操作完成后才调用</p> <p>执行时机：</p> <p>在下次 <code>DOM</code> 更新循环结束之后执行延迟回调，在修改数据之后立即使用 <code>nextTick</code> 来获取更新后的 <code>DOM</code></p> <p><strong><mark>引入原因：</mark></strong></p> <ul><li>如果是同步更新 那么会频繁触发<code>UI/DOM</code>的渲染，可以减少无用渲染</li> <li>由于<code>VirtualDOM</code>的引入 每一次状态改变 信号都会发给<code>DOM</code>进行更新 每次更新状态都会需要更多的计算 这种无用功会浪费更多性能</li> <li><code>Vue</code>采用<code>MVVM</code>，也就是开发者只需<code>modelView</code>层进行业务逻辑，利用数据驱动视图的方式，但是避免不了还是要操作<code>dom</code>，有时候<code>DOM1</code>数据发生变化，此时<code>DOM2</code>需要从<code>DOM1</code>中获取数据，却发现<code>DOM2</code>视图并没有更新，这时候就需要用到<code>nextTick</code></li> <li>还有的情况是在<code>Vue</code>生命周期里面，<code>created</code>钩子进行<code>DOM</code>的操作要放在<code>nextTick</code>中，因为执行<code>created</code>钩子时，<code>DOM</code>还未渲染 无法操作<code>DOM</code></li></ul> <h2 id="vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"><a href="#vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="header-anchor">#</a> <code>Vue</code> <code>data</code> 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h2> <p>不会立即同步执行渲染 而是按照一定的策略进行<code>DOM</code>异步更新，当侦听到数据变化的时候，<code>Vue</code>会开启一个队列，并缓冲同一事件循环中发生的所有数据变更，如果同一个<code>watcher</code>被多次触发，只会被推入队列中一次，这时候去除重复数据对避免不必要的计算和<code>DOM</code>操作，在下一个时间循环<code>Tick</code>中刷新队列并执行(已去重)的工作</p> <h2 id="vue模板渲染的原理是什么"><a href="#vue模板渲染的原理是什么" class="header-anchor">#</a> <code>Vue</code>模板渲染的原理是什么？<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <p><code>vue</code> 中的模板 <code>template</code> 无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的 <code>HTML</code> 语法，所有需要将 <code>template</code> 转化成一个 <code>JavaScript</code> 函数，这样浏览器就可以执行这一个函数并渲染出对应的 <code>HTML</code> 元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。</p> <p>模板编译又分三个阶段，解析 <code>parse</code>，优化 <code>optimize</code>，生成 <code>generate</code>，最终生成可执行函数 <code>render</code>。</p> <ul><li><strong><code>parse</code>阶段</strong>：使用大量的正则表达式对 <code>template</code> 字符串进行解析，将标签、指令、属性等转化为抽象语法树 <code>AST</code>。</li> <li><strong><code>optimize</code>阶段</strong>：遍历 <code>AST</code>，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 <code>diff</code> 比较时，直接跳过这一些静态节点，优化 <code>runtime</code> 的性能。</li> <li><strong><code>generate</code>阶段</strong>：将最终的 <code>AST</code> 转化为 <code>render</code> 函数字符串。</li></ul> <h2 id="子组件可以直接改变父组件的数据吗"><a href="#子组件可以直接改变父组件的数据吗" class="header-anchor">#</a> 子组件可以直接改变父组件的数据吗</h2> <blockquote><p>子组件不可以改变父组件的数据</p></blockquote> <p>主要是为了维护父子组件的单向数据流，为了意外的改变父组件的状态，使得应用的数据流变得难得理解，只能通过<code>$emit</code>派发一个自定义事件，父组件接收到后，由父组件修改</p> <h2 id="vue和react的理解和异同"><a href="#vue和react的理解和异同" class="header-anchor">#</a> <code>Vue</code>和<code>React</code>的理解和异同<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <p><mark>相似：</mark></p> <ul><li><p>都将路由和全局状态管理交给相关库</p></li> <li><p>都用了<code>Virtual Dom</code>提高重绘性能</p></li> <li><p>都有<code>props</code> 允许组件数据传递</p></li> <li><p>都提倡组件化</p></li></ul> <p><mark>不同：</mark></p> <ul><li><p>数据流：<code>Vue</code>默认支持数据双向绑定，<code>React</code>提倡单向数据流</p></li> <li><p><code>Virtual DOM</code>：<code>Vue</code>会跟踪每一个组件的依赖关系，不需要重新渲染整棵树 而<code>React</code>每当应用改变 全部子组件都会重新渲染，可以通过<code>PureComponent</code>/<code>shouldComponentUpdate</code>来控制</p></li> <li><p>模板编写：<code>Vue</code>鼓励常规的<code>HTML</code>模板编写 <code>React</code>推荐用<code>JS</code>的语法扩展 -- <code>JSX</code></p></li> <li><p>监听数据变化的原理：<code>Vue</code>通过<code>getter</code>/<code>setter</code>以及函数劫持，精确知道数据的变化 <code>React</code>通过比较引用的方式进行的，不优化的话会导致大量不必要的<code>vDOM</code>重新渲染</p></li> <li><p>高阶组件：<code>Vue</code>通过<code>mixins</code>扩展 <code>React</code>通过<code>HOC</code>来扩展</p></li></ul> <h2 id="vue的优点"><a href="#vue的优点" class="header-anchor">#</a> <code>Vue</code>的优点<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <ul><li><p>轻量级框架：只关注<code>modelView</code>层</p></li> <li><p>双向数据绑定： 在数据操作方面更为简单</p></li> <li><p>组件化：实现了<code>html</code>形式的封装和重用</p></li> <li><p><code>model</code> <code>modelView</code> <code>view</code>层分离 是开发者只需要操作数据就能完成操作</p></li> <li><p><code>virtualDOM</code> 不用原生的<code>DOM</code>操作节点</p></li></ul> <h2 id="assets和static的区别"><a href="#assets和static的区别" class="header-anchor">#</a> <code>assets</code>和<code>static</code>的区别</h2> <blockquote><p>相同点：都用来存放静态资源</p></blockquote> <blockquote><p>不同点：
<code>static</code>里面的资源文件不经过压缩直接进入打包的目录，而<code>asset</code>里面的文件则经过压缩同<code>static</code>一起上传到服务器上，所以<code>static</code>里面的文件相对<code>assets</code>大一些，我们可以将项目中的<code>js</code>文件放在<code>assets</code>中，项目的<code>iconfont</code>等第三方资源文件放在<code>static</code>中，因为他们已经被处理过了</p></blockquote> <h2 id="vue如何监听对象和数组的某个属性改变"><a href="#vue如何监听对象和数组的某个属性改变" class="header-anchor">#</a> <code>Vue</code>如何监听对象和数组的某个属性改变<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <ol><li><p><code>this.$set(target, key, value)</code></p></li> <li><p><code>splice()</code>、 <code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>sort()</code>、<code>reverse()</code></p></li></ol> <p><strong><mark><code>Vue.$set</code>原理 </mark></strong></p> <ul><li><p>如果是修改数组索引，直接用数组的<code>splice</code>方法触发</p></li> <li><p>如果是对象，判断属性是否存在 是否为响应式 ，通过调用<code>defineReactive</code>(就是<code>Vue</code>初始化对象，给对象采用(<code>Object.defineProperty</code>动态添加<code>getter/setter</code>)</p></li></ul> <h2 id="对ssr的理解"><a href="#对ssr的理解" class="header-anchor">#</a> 对<code>ssr</code>的理解<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <p><code>ssr</code>是服务端渲染，也就是<code>Vue</code>在客户端将标签渲染成<code>HTML</code>放在服务端，服务端直接返回给客户端</p> <p><code>ssr</code>优势：更好的<code>SEO</code>、首屏速度变快</p> <p><code>ssr</code>缺点：服务端渲染只支持<code>beforeCreate</code>和<code>Created</code>两个钩子 更多的服务端负载</p> <h2 id="vue的性能优化"><a href="#vue的性能优化" class="header-anchor">#</a> <code>Vue</code>的性能优化<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <blockquote><p>编码阶段</p></blockquote> <ol><li><p>减少<code>data</code>中的数据，因为<code>data</code>的数据会增加<code>getter</code>和<code>setter</code> 会收集相应的<code>watcher</code></p></li> <li><p><code>v-for</code>里面不能嵌套<code>v-if</code>(因为<code>v-for</code>优先级比<code>v-if</code>高，所以哪怕渲染一小部分的用户的元素，也得在每次重渲染的时候遍历整个列表)</p></li> <li><p><code>spa</code>页面采用<code>keep-alive</code>缓存组件</p></li> <li><p><code>key</code>保证唯一</p></li> <li><p>使用路由懒加载 异步组件</p></li> <li><p>防抖节流</p></li> <li><p>第三方模块按需导入</p></li> <li><p>懒加载</p></li></ol> <blockquote><p><code>SEO</code>优化</p></blockquote> <ol><li>预渲染</li> <li><code>ssr</code></li></ol> <blockquote><p>打包优化</p></blockquote> <ol><li><p>压缩<code>uglify</code>代码</p></li> <li><p><code>tree shaking</code>/ <code>scope Hoisting</code></p></li> <li><p><code>cdn</code>加载第三方模块</p></li> <li><p><code>splitChunk</code>抽离公共文件</p></li> <li><p><code>sourceMap</code>优化</p></li></ol> <blockquote><p>用户体验</p></blockquote> <ol><li><p>骨架屏</p></li> <li><p><code>PWA</code></p></li> <li><p>服务端开启<code>gzip</code>压缩</p></li></ol> <h2 id="对spa的理解-优缺点是什么"><a href="#对spa的理解-优缺点是什么" class="header-anchor">#</a> 对<code>SPA</code>的理解 优缺点是什么</h2> <div class="custom-block tip"><p class="custom-block-title">概念</p> <p><code>SPA</code>是<code>single-page application</code>是仅在<code>web</code>应用初始化的时候加载相应的<code>html</code> <code>css</code>和<code>js</code> ，一旦页面加载完成<code>SPA</code>不会因为用户的操作而进行页面的重新加载或跳转，取而代之的是<code>html</code>内容的变换，<code>ui</code>和用户的交互</p></div> <blockquote><p>优点：</p></blockquote> <ol><li>用户体验好 内容改变不会重新加载页面，避免了不必要的跳转和重复渲染 对服务器压力小</li></ol> <blockquote><p>缺点：</p></blockquote> <ol><li><p>初次加载耗时长，需要在加载页面的时候将<code>js</code>和<code>css</code>统一加载 部分页面按需加载</p></li> <li><p>前进后退路由管理：不能使用浏览器的前进后退功能</p></li> <li><p><code>SEO</code>难度大，所有内容都在一个页面中动态替换</p></li></ol> <h2 id="template和jsx区别"><a href="#template和jsx区别" class="header-anchor">#</a> <code>template</code>和<code>jsx</code>区别</h2> <p>对于<code>runtime</code>来说只要组件存在<code>render</code>函数即可</p> <ul><li><p><code>vue</code>中利用<code>vue-loader</code>编译<code>.vue</code>文件 内部依赖的<code>vue-template-compiler</code> 将<code>template</code>预编译成<code>render</code>函数</p></li> <li><p><code>react</code>利用<code>babel-plugin-transform-vue-jsx</code>这个<code>jsx</code>语法糖解析器就可以了</p></li></ul> <p>所以两者都是<code>render</code> 的表现形式 但是<code>jsx</code>更具有灵活性在复杂组件中有优势 而<code>template</code>在代码结构上符合视图和逻辑分离，更简单 更好维护</p> <h2 id="vue初始化页面为什么会闪动"><a href="#vue初始化页面为什么会闪动" class="header-anchor">#</a> <code>Vue</code>初始化页面为什么会闪动</h2> <p>在<code>vue</code>初始化之前，由于<code>div</code>是不归<code>vue</code>管的 所以在还没解析的情况可能会出现{{<code>message</code>}}的情况</p> <p>解决方法</p> <ul><li><p>在根元素标签上加上<code>v-cloak</code> ，添加<code>css</code>样式 <code>[v-cloak] {display: none;}</code></p></li> <li><p>在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;{display: 'block'}&quot;</code></p></li></ul> <h2 id="mixin和mixins区别"><a href="#mixin和mixins区别" class="header-anchor">#</a> <code>mixin</code>和<code>mixins</code>区别<span class="badge warning" style="vertical-align:top;" data-v-d5affa18>重要</span></h2> <blockquote><p><code>mixin</code>用于全局混入，会影响到每个组件实例</p></blockquote> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    
  <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
    <span class="token comment">// ...逻辑        </span>
    <span class="token comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数    </span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以全局混入封装好的<code>axios</code>等</p> <p><code>mixins</code>用于扩展组件的方式，如果多个组件有相同业务逻辑，可以将逻辑剥离开，通过<code>mixins</code>混入代码，比如上拉下拉加载数据等，另外<code>mixins</code>混入函数会先于组件的钩子函数，当重名的时候，组件的同名函数会覆盖<code>mixins</code>函数</p> <h2 id="mvvm优缺点"><a href="#mvvm优缺点" class="header-anchor">#</a> <code>MVVM</code>优缺点<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <blockquote><p>优点：</p></blockquote> <ol><li><code>低耦合</code>。视图（<code>View</code>）可以独立于<code>Model</code>变化和修改，一个<code>Model</code>可以绑定到不同的<code>View</code>上，当<code>View</code>变化的时候<code>Model</code>可以不变化，当<code>Model</code>变化的时候<code>View</code>也可以不变；</li> <li><code>可重用性</code>。你可以把一些视图逻辑放在一个<code>Model</code>里面，让很多<code>View</code>重用这段视图逻辑。</li> <li><code>独立开发</code>。开发人员可以专注于业务逻辑和数据的开发(<code>ViewModel</code>)，设计人员可以专注于页面设计</li></ol> <blockquote><p>缺点：</p></blockquote> <ul><li><p><code>bug</code>难以调试，使用双向绑定 当页面异常是，可能是<code>view</code>层也可能是<code>model</code>层的代码问题，另外数据绑定的声明是写在<code>view</code>的模板中，没办法断点<code>debug</code></p></li> <li><p>一个大模块的<code>model</code>层也很大，当长期持有，不释放内存会花费更多内存</p></li> <li><p>对于大型的图形应用程序，视图较多，<code>viewmodel</code>的构建和维护成本较高</p></li></ul> <h2 id="vue中使用了哪些设计模式"><a href="#vue中使用了哪些设计模式" class="header-anchor">#</a> vue中使用了哪些设计模式？<span class="badge error" style="vertical-align:top;" data-v-d5affa18>特别重要</span></h2> <ul><li>单例模式：<code>new</code>多次，只有一个实例</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/duochizhacai/generatePic/img/202202042329075.awebp" alt="image.png"></p> <ul><li>工厂模式：传入参数就可以创建实例（虚拟节点的创建）</li> <li>发布订阅模式：<code>eventBus</code></li> <li>观察者模式：<code>watch和dep</code></li> <li>代理模式：<code>_data</code>属性、<code>proxy</code>、防抖、节流</li> <li>中介者模式：<code>vuex</code></li> <li>策略模式</li> <li>外观模式</li></ul></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/03/20, 19:40:28</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/4db11c/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Vue生命周期</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/4db11c/">Vue生命周期</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://github.com/duochizhacai" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://juejin.cn/user/1249486902410744" title="JueJin" target="_blank" class="iconfont icon-juejin"></a></div> 
    Copyright © 2021-2022
    <span><a href='https://beian.miit.gov.cn'>粤ICP备2021165371号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.95fc12d6.js" defer></script><script src="/assets/js/2.abf57e2f.js" defer></script><script src="/assets/js/15.753bb2dc.js" defer></script><script src="/assets/js/3.e687237e.js" defer></script>
  </body>
</html>
